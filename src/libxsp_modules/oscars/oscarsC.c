// =============================================================================
//  DAMSL (xsp)
//
//  Copyright (c) 2010-2016, Trustees of Indiana University,
//  All rights reserved.
//
//  This software may be modified and distributed under the terms of the BSD
//  license.  See the COPYING file for details.
//
//  This software was created at the Indiana University Center for Research in
//  Extreme Scale Technologies (CREST).
// =============================================================================
/* oscarsC.c
   Generated by gSOAP 2.8.1 from oscarsAPI.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   The generated code is released under one of the following licenses:
   GPL OR Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "oscarsH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) oscarsC.c ver 2.8.1 2011-04-04 17:19:48 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean_:
		return soap_in_xsd__boolean_(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_in_wsu__tTimestampFault(soap, NULL, NULL, "wsu:tTimestampFault");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_in__wsa5__IsReferenceParameter(soap, NULL, NULL, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_in_wsa5__FaultCodesType(soap, NULL, NULL, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_in_wsa5__RelationshipType(soap, NULL, NULL, "wsa5:RelationshipType");
	case SOAP_TYPE_ns5__ResourceUnavailableFaultType:
		return soap_in_ns5__ResourceUnavailableFaultType(soap, NULL, NULL, "ns5:ResourceUnavailableFaultType");
	case SOAP_TYPE_ns5__ResourceUnknownFaultType:
		return soap_in_ns5__ResourceUnknownFaultType(soap, NULL, NULL, "ns5:ResourceUnknownFaultType");
	case SOAP_TYPE_ns4__ResumeFailedFaultType:
		return soap_in_ns4__ResumeFailedFaultType(soap, NULL, NULL, "ns4:ResumeFailedFaultType");
	case SOAP_TYPE_ns4__PauseFailedFaultType:
		return soap_in_ns4__PauseFailedFaultType(soap, NULL, NULL, "ns4:PauseFailedFaultType");
	case SOAP_TYPE_ns4__UnableToDestroySubscriptionFaultType:
		return soap_in_ns4__UnableToDestroySubscriptionFaultType(soap, NULL, NULL, "ns4:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_ns4__UnacceptableTerminationTimeFaultType:
		return soap_in_ns4__UnacceptableTerminationTimeFaultType(soap, NULL, NULL, "ns4:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_ns4__UnableToCreatePullPointFaultType:
		return soap_in_ns4__UnableToCreatePullPointFaultType(soap, NULL, NULL, "ns4:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_ns4__UnableToDestroyPullPointFaultType:
		return soap_in_ns4__UnableToDestroyPullPointFaultType(soap, NULL, NULL, "ns4:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_ns4__UnableToGetMessagesFaultType:
		return soap_in_ns4__UnableToGetMessagesFaultType(soap, NULL, NULL, "ns4:UnableToGetMessagesFaultType");
	case SOAP_TYPE_ns4__NoCurrentMessageOnTopicFaultType:
		return soap_in_ns4__NoCurrentMessageOnTopicFaultType(soap, NULL, NULL, "ns4:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_ns4__UnacceptableInitialTerminationTimeFaultType:
		return soap_in_ns4__UnacceptableInitialTerminationTimeFaultType(soap, NULL, NULL, "ns4:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_ns4__NotifyMessageNotSupportedFaultType:
		return soap_in_ns4__NotifyMessageNotSupportedFaultType(soap, NULL, NULL, "ns4:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_ns4__UnsupportedPolicyRequestFaultType:
		return soap_in_ns4__UnsupportedPolicyRequestFaultType(soap, NULL, NULL, "ns4:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_ns4__UnrecognizedPolicyRequestFaultType:
		return soap_in_ns4__UnrecognizedPolicyRequestFaultType(soap, NULL, NULL, "ns4:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_ns4__InvalidMessageContentExpressionFaultType:
		return soap_in_ns4__InvalidMessageContentExpressionFaultType(soap, NULL, NULL, "ns4:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_ns4__InvalidProducerPropertiesExpressionFaultType:
		return soap_in_ns4__InvalidProducerPropertiesExpressionFaultType(soap, NULL, NULL, "ns4:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_ns4__MultipleTopicsSpecifiedFaultType:
		return soap_in_ns4__MultipleTopicsSpecifiedFaultType(soap, NULL, NULL, "ns4:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_ns4__TopicNotSupportedFaultType:
		return soap_in_ns4__TopicNotSupportedFaultType(soap, NULL, NULL, "ns4:TopicNotSupportedFaultType");
	case SOAP_TYPE_ns4__InvalidTopicExpressionFaultType:
		return soap_in_ns4__InvalidTopicExpressionFaultType(soap, NULL, NULL, "ns4:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_ns4__TopicExpressionDialectUnknownFaultType:
		return soap_in_ns4__TopicExpressionDialectUnknownFaultType(soap, NULL, NULL, "ns4:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_ns4__InvalidFilterFaultType:
		return soap_in_ns4__InvalidFilterFaultType(soap, NULL, NULL, "ns4:InvalidFilterFaultType");
	case SOAP_TYPE_ns4__SubscribeCreationFailedFaultType:
		return soap_in_ns4__SubscribeCreationFailedFaultType(soap, NULL, NULL, "ns4:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_ns1__reservationResourceType:
		return soap_in_ns1__reservationResourceType(soap, NULL, NULL, "ns1:reservationResourceType");
	case SOAP_TYPE_ns6__FaultCauseType:
		return soap_in_ns6__FaultCauseType(soap, NULL, NULL, "ns6:FaultCauseType");
	case SOAP_TYPE_ns6__ErrorCodeType:
		return soap_in_ns6__ErrorCodeType(soap, NULL, NULL, "ns6:ErrorCodeType");
	case SOAP_TYPE_ns6__BaseFaultType:
		return soap_in_ns6__BaseFaultType(soap, NULL, NULL, "ns6:BaseFaultType");
	case SOAP_TYPE_ns4__MessageType:
		return soap_in_ns4__MessageType(soap, NULL, NULL, "ns4:MessageType");
	case SOAP_TYPE_ns4__NotificationMessageHolderType:
		return soap_in_ns4__NotificationMessageHolderType(soap, NULL, NULL, "ns4:NotificationMessageHolderType");
	case SOAP_TYPE_ns4__SubscriptionPolicyType:
		return soap_in_ns4__SubscriptionPolicyType(soap, NULL, NULL, "ns4:SubscriptionPolicyType");
	case SOAP_TYPE_ns4__QueryExpressionType:
		return soap_in_ns4__QueryExpressionType(soap, NULL, NULL, "ns4:QueryExpressionType");
	case SOAP_TYPE_ns4__TopicExpressionType:
		return soap_in_ns4__TopicExpressionType(soap, NULL, NULL, "ns4:TopicExpressionType");
	case SOAP_TYPE_ns4__FilterType:
		return soap_in_ns4__FilterType(soap, NULL, NULL, "ns4:FilterType");
	case SOAP_TYPE_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo:
		return soap_in_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, NULL, NULL, "ns3:CtrlPlaneSwitchingCapabilitySpecificInfo");
	case SOAP_TYPE_ns3__Duration:
		return soap_in_ns3__Duration(soap, NULL, NULL, "ns3:Duration");
	case SOAP_TYPE_ns3__TimeContent:
		return soap_in_ns3__TimeContent(soap, NULL, NULL, "ns3:TimeContent");
	case SOAP_TYPE_ns3__CtrlPlaneNextHopContent:
		return soap_in_ns3__CtrlPlaneNextHopContent(soap, NULL, NULL, "ns3:CtrlPlaneNextHopContent");
	case SOAP_TYPE_ns3__CtrlPlaneHopContent:
		return soap_in_ns3__CtrlPlaneHopContent(soap, NULL, NULL, "ns3:CtrlPlaneHopContent");
	case SOAP_TYPE_ns3__CtrlPlaneSwcapContent:
		return soap_in_ns3__CtrlPlaneSwcapContent(soap, NULL, NULL, "ns3:CtrlPlaneSwcapContent");
	case SOAP_TYPE_ns3__CtrlPlaneAdministrativeGroup:
		return soap_in_ns3__CtrlPlaneAdministrativeGroup(soap, NULL, NULL, "ns3:CtrlPlaneAdministrativeGroup");
	case SOAP_TYPE_ns3__CtrlPlaneAddressContent:
		return soap_in_ns3__CtrlPlaneAddressContent(soap, NULL, NULL, "ns3:CtrlPlaneAddressContent");
	case SOAP_TYPE_ns3__CtrlPlaneLinkContent:
		return soap_in_ns3__CtrlPlaneLinkContent(soap, NULL, NULL, "ns3:CtrlPlaneLinkContent");
	case SOAP_TYPE_ns3__CtrlPlanePortContent:
		return soap_in_ns3__CtrlPlanePortContent(soap, NULL, NULL, "ns3:CtrlPlanePortContent");
	case SOAP_TYPE_ns3__CtrlPlaneNodeContent:
		return soap_in_ns3__CtrlPlaneNodeContent(soap, NULL, NULL, "ns3:CtrlPlaneNodeContent");
	case SOAP_TYPE_ns3__Lifetime:
		return soap_in_ns3__Lifetime(soap, NULL, NULL, "ns3:Lifetime");
	case SOAP_TYPE_ns3__CtrlPlaneDomainSignatureContent:
		return soap_in_ns3__CtrlPlaneDomainSignatureContent(soap, NULL, NULL, "ns3:CtrlPlaneDomainSignatureContent");
	case SOAP_TYPE_ns3__CtrlPlaneDomainContent:
		return soap_in_ns3__CtrlPlaneDomainContent(soap, NULL, NULL, "ns3:CtrlPlaneDomainContent");
	case SOAP_TYPE_ns1__localDetails:
		return soap_in_ns1__localDetails(soap, NULL, NULL, "ns1:localDetails");
	case SOAP_TYPE_ns1__msgDetails:
		return soap_in_ns1__msgDetails(soap, NULL, NULL, "ns1:msgDetails");
	case SOAP_TYPE_ns1__eventContent:
		return soap_in_ns1__eventContent(soap, NULL, NULL, "ns1:eventContent");
	case SOAP_TYPE_ns1__mplsInfo:
		return soap_in_ns1__mplsInfo(soap, NULL, NULL, "ns1:mplsInfo");
	case SOAP_TYPE_ns1__layer3Info:
		return soap_in_ns1__layer3Info(soap, NULL, NULL, "ns1:layer3Info");
	case SOAP_TYPE_ns1__layer2Info:
		return soap_in_ns1__layer2Info(soap, NULL, NULL, "ns1:layer2Info");
	case SOAP_TYPE_ns3__CtrlPlanePathContent:
		return soap_in_ns3__CtrlPlanePathContent(soap, NULL, NULL, "ns3:CtrlPlanePathContent");
	case SOAP_TYPE_ns1__forwardReply:
		return soap_in_ns1__forwardReply(soap, NULL, NULL, "ns1:forwardReply");
	case SOAP_TYPE_ns1__globalReservationId:
		return soap_in_ns1__globalReservationId(soap, NULL, NULL, "ns1:globalReservationId");
	case SOAP_TYPE_ns1__forwardPayload:
		return soap_in_ns1__forwardPayload(soap, NULL, NULL, "ns1:forwardPayload");
	case SOAP_TYPE_ns1__listReply:
		return soap_in_ns1__listReply(soap, NULL, NULL, "ns1:listReply");
	case SOAP_TYPE_ns1__vlanTag:
		return soap_in_ns1__vlanTag(soap, NULL, NULL, "ns1:vlanTag");
	case SOAP_TYPE_ns1__listRequest:
		return soap_in_ns1__listRequest(soap, NULL, NULL, "ns1:listRequest");
	case SOAP_TYPE_ns1__teardownPathResponseContent:
		return soap_in_ns1__teardownPathResponseContent(soap, NULL, NULL, "ns1:teardownPathResponseContent");
	case SOAP_TYPE_ns1__teardownPathContent:
		return soap_in_ns1__teardownPathContent(soap, NULL, NULL, "ns1:teardownPathContent");
	case SOAP_TYPE_ns1__refreshPathResponseContent:
		return soap_in_ns1__refreshPathResponseContent(soap, NULL, NULL, "ns1:refreshPathResponseContent");
	case SOAP_TYPE_ns1__refreshPathContent:
		return soap_in_ns1__refreshPathContent(soap, NULL, NULL, "ns1:refreshPathContent");
	case SOAP_TYPE_ns1__createPathResponseContent:
		return soap_in_ns1__createPathResponseContent(soap, NULL, NULL, "ns1:createPathResponseContent");
	case SOAP_TYPE_ns1__createPathContent:
		return soap_in_ns1__createPathContent(soap, NULL, NULL, "ns1:createPathContent");
	case SOAP_TYPE_ns3__CtrlPlaneTopologyContent:
		return soap_in_ns3__CtrlPlaneTopologyContent(soap, NULL, NULL, "ns3:CtrlPlaneTopologyContent");
	case SOAP_TYPE_ns1__getTopologyResponseContent:
		return soap_in_ns1__getTopologyResponseContent(soap, NULL, NULL, "ns1:getTopologyResponseContent");
	case SOAP_TYPE_ns1__getTopologyContent:
		return soap_in_ns1__getTopologyContent(soap, NULL, NULL, "ns1:getTopologyContent");
	case SOAP_TYPE_ns1__resDetails:
		return soap_in_ns1__resDetails(soap, NULL, NULL, "ns1:resDetails");
	case SOAP_TYPE_ns1__modifyResReply:
		return soap_in_ns1__modifyResReply(soap, NULL, NULL, "ns1:modifyResReply");
	case SOAP_TYPE_ns1__modifyResContent:
		return soap_in_ns1__modifyResContent(soap, NULL, NULL, "ns1:modifyResContent");
	case SOAP_TYPE_ns1__createReply:
		return soap_in_ns1__createReply(soap, NULL, NULL, "ns1:createReply");
	case SOAP_TYPE_ns1__pathInfo:
		return soap_in_ns1__pathInfo(soap, NULL, NULL, "ns1:pathInfo");
	case SOAP_TYPE_ns1__resCreateContent:
		return soap_in_ns1__resCreateContent(soap, NULL, NULL, "ns1:resCreateContent");
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return soap_in_xenc__EncryptionPropertyType(soap, NULL, NULL, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return soap_in_xenc__EncryptionPropertiesType(soap, NULL, NULL, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_xenc__ReferenceType:
		return soap_in_xenc__ReferenceType(soap, NULL, NULL, "xenc:ReferenceType");
	case SOAP_TYPE_xenc__AgreementMethodType:
		return soap_in_xenc__AgreementMethodType(soap, NULL, NULL, "xenc:AgreementMethodType");
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return soap_in_xenc__EncryptedKeyType(soap, NULL, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_xenc__EncryptedDataType:
		return soap_in_xenc__EncryptedDataType(soap, NULL, NULL, "xenc:EncryptedDataType");
	case SOAP_TYPE_xenc__TransformsType:
		return soap_in_xenc__TransformsType(soap, NULL, NULL, "xenc:TransformsType");
	case SOAP_TYPE_xenc__CipherReferenceType:
		return soap_in_xenc__CipherReferenceType(soap, NULL, NULL, "xenc:CipherReferenceType");
	case SOAP_TYPE_xenc__CipherDataType:
		return soap_in_xenc__CipherDataType(soap, NULL, NULL, "xenc:CipherDataType");
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return soap_in_xenc__EncryptionMethodType(soap, NULL, NULL, "xenc:EncryptionMethodType");
	case SOAP_TYPE_xenc__EncryptedType:
		return soap_in_xenc__EncryptedType(soap, NULL, NULL, "xenc:EncryptedType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_in_ds__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_in_ds__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_in_ds__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_in_ds__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_ds__TransformsType:
		return soap_in_ds__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_in_ds__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_in_ds__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_in_ds__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_in_ds__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_in_ds__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_in_wsa5__ProblemActionType(soap, NULL, NULL, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_in_wsa5__RelatesToType(soap, NULL, NULL, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_in_wsa5__MetadataType(soap, NULL, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_in_wsa5__ReferenceParametersType(soap, NULL, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_in_wsa5__EndpointReferenceType(soap, NULL, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_ns4__Notify:
		return soap_in_PointerTo_ns4__Notify(soap, NULL, NULL, "ns4:Notify");
	case SOAP_TYPE_PointerTo_ns1__forward:
		return soap_in_PointerTo_ns1__forward(soap, NULL, NULL, "ns1:forward");
	case SOAP_TYPE_PointerTons1__getTopologyResponseContent:
		return soap_in_PointerTons1__getTopologyResponseContent(soap, NULL, NULL, "ns1:getTopologyResponseContent");
	case SOAP_TYPE_PointerTons1__getTopologyContent:
		return soap_in_PointerTons1__getTopologyContent(soap, NULL, NULL, "ns1:getTopologyContent");
	case SOAP_TYPE_PointerTo_ns1__BSSFault:
		return soap_in_PointerTo_ns1__BSSFault(soap, NULL, NULL, "ns1:BSSFault");
	case SOAP_TYPE_PointerTo_ns1__AAAFault:
		return soap_in_PointerTo_ns1__AAAFault(soap, NULL, NULL, "ns1:AAAFault");
	case SOAP_TYPE_PointerTo_QName:
		return soap_in_PointerTo_QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTons6__FaultCauseType:
		return soap_in_PointerTons6__FaultCauseType(soap, NULL, NULL, "ns6:FaultCauseType");
	case SOAP_TYPE_PointerTons6__ErrorCodeType:
		return soap_in_PointerTons6__ErrorCodeType(soap, NULL, NULL, "ns6:ErrorCodeType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_in_PointerTounsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTo_ns4__Subscribe_SubscriptionPolicy:
		return soap_in_PointerTo_ns4__Subscribe_SubscriptionPolicy(soap, NULL, NULL, "ns4:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerToPointerTons4__NotificationMessageHolderType:
		return soap_in_PointerToPointerTons4__NotificationMessageHolderType(soap, NULL, NULL, "ns4:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTons4__NotificationMessageHolderType:
		return soap_in_PointerTons4__NotificationMessageHolderType(soap, NULL, NULL, "ns4:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons4__SubscriptionPolicyType:
		return soap_in_PointerTons4__SubscriptionPolicyType(soap, NULL, NULL, "ns4:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTons4__FilterType:
		return soap_in_PointerTons4__FilterType(soap, NULL, NULL, "ns4:FilterType");
	case SOAP_TYPE_PointerTons4__MessageType:
		return soap_in_PointerTons4__MessageType(soap, NULL, NULL, "ns4:MessageType");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_in_PointerTowsa5__EndpointReferenceType(soap, NULL, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerToPointerTons4__QueryExpressionType:
		return soap_in_PointerToPointerTons4__QueryExpressionType(soap, NULL, NULL, "ns4:QueryExpressionType");
	case SOAP_TYPE_PointerTons4__QueryExpressionType:
		return soap_in_PointerTons4__QueryExpressionType(soap, NULL, NULL, "ns4:QueryExpressionType");
	case SOAP_TYPE_PointerToPointerTons4__TopicExpressionType:
		return soap_in_PointerToPointerTons4__TopicExpressionType(soap, NULL, NULL, "ns4:TopicExpressionType");
	case SOAP_TYPE_PointerTons4__TopicExpressionType:
		return soap_in_PointerTons4__TopicExpressionType(soap, NULL, NULL, "ns4:TopicExpressionType");
	case SOAP_TYPE_PointerToxsd__boolean_:
		return soap_in_PointerToxsd__boolean_(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo:
		return soap_in_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, NULL, NULL, "ns3:CtrlPlaneSwitchingCapabilitySpecificInfo");
	case SOAP_TYPE_PointerTons3__Duration:
		return soap_in_PointerTons3__Duration(soap, NULL, NULL, "ns3:Duration");
	case SOAP_TYPE_PointerTons3__TimeContent:
		return soap_in_PointerTons3__TimeContent(soap, NULL, NULL, "ns3:TimeContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneNextHopContent:
		return soap_in_PointerToPointerTons3__CtrlPlaneNextHopContent(soap, NULL, NULL, "ns3:CtrlPlaneNextHopContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneNextHopContent:
		return soap_in_PointerTons3__CtrlPlaneNextHopContent(soap, NULL, NULL, "ns3:CtrlPlaneNextHopContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneHopContent:
		return soap_in_PointerToPointerTons3__CtrlPlaneHopContent(soap, NULL, NULL, "ns3:CtrlPlaneHopContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneHopContent:
		return soap_in_PointerTons3__CtrlPlaneHopContent(soap, NULL, NULL, "ns3:CtrlPlaneHopContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneSwcapContent:
		return soap_in_PointerTons3__CtrlPlaneSwcapContent(soap, NULL, NULL, "ns3:CtrlPlaneSwcapContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneAdministrativeGroup:
		return soap_in_PointerToPointerTons3__CtrlPlaneAdministrativeGroup(soap, NULL, NULL, "ns3:CtrlPlaneAdministrativeGroup");
	case SOAP_TYPE_PointerTons3__CtrlPlaneAdministrativeGroup:
		return soap_in_PointerTons3__CtrlPlaneAdministrativeGroup(soap, NULL, NULL, "ns3:CtrlPlaneAdministrativeGroup");
	case SOAP_TYPE_PointerTons3__CtrlPlaneAddressContent:
		return soap_in_PointerTons3__CtrlPlaneAddressContent(soap, NULL, NULL, "ns3:CtrlPlaneAddressContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneLinkContent:
		return soap_in_PointerToPointerTons3__CtrlPlaneLinkContent(soap, NULL, NULL, "ns3:CtrlPlaneLinkContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneLinkContent:
		return soap_in_PointerTons3__CtrlPlaneLinkContent(soap, NULL, NULL, "ns3:CtrlPlaneLinkContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlanePortContent:
		return soap_in_PointerToPointerTons3__CtrlPlanePortContent(soap, NULL, NULL, "ns3:CtrlPlanePortContent");
	case SOAP_TYPE_PointerTons3__CtrlPlanePortContent:
		return soap_in_PointerTons3__CtrlPlanePortContent(soap, NULL, NULL, "ns3:CtrlPlanePortContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneNodeContent:
		return soap_in_PointerToPointerTons3__CtrlPlaneNodeContent(soap, NULL, NULL, "ns3:CtrlPlaneNodeContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneNodeContent:
		return soap_in_PointerTons3__CtrlPlaneNodeContent(soap, NULL, NULL, "ns3:CtrlPlaneNodeContent");
	case SOAP_TYPE_PointerTons3__Lifetime:
		return soap_in_PointerTons3__Lifetime(soap, NULL, NULL, "ns3:Lifetime");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneDomainSignatureContent:
		return soap_in_PointerToPointerTons3__CtrlPlaneDomainSignatureContent(soap, NULL, NULL, "ns3:CtrlPlaneDomainSignatureContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneDomainSignatureContent:
		return soap_in_PointerTons3__CtrlPlaneDomainSignatureContent(soap, NULL, NULL, "ns3:CtrlPlaneDomainSignatureContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneDomainContent:
		return soap_in_PointerToPointerTons3__CtrlPlaneDomainContent(soap, NULL, NULL, "ns3:CtrlPlaneDomainContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneDomainContent:
		return soap_in_PointerTons3__CtrlPlaneDomainContent(soap, NULL, NULL, "ns3:CtrlPlaneDomainContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlanePathContent:
		return soap_in_PointerToPointerTons3__CtrlPlanePathContent(soap, NULL, NULL, "ns3:CtrlPlanePathContent");
	case SOAP_TYPE_PointerTons1__forwardReply:
		return soap_in_PointerTons1__forwardReply(soap, NULL, NULL, "ns1:forwardReply");
	case SOAP_TYPE_PointerTons1__forwardPayload:
		return soap_in_PointerTons1__forwardPayload(soap, NULL, NULL, "ns1:forwardPayload");
	case SOAP_TYPE_PointerTons1__localDetails:
		return soap_in_PointerTons1__localDetails(soap, NULL, NULL, "ns1:localDetails");
	case SOAP_TYPE_PointerTons1__msgDetails:
		return soap_in_PointerTons1__msgDetails(soap, NULL, NULL, "ns1:msgDetails");
	case SOAP_TYPE_PointerTons1__mplsInfo:
		return soap_in_PointerTons1__mplsInfo(soap, NULL, NULL, "ns1:mplsInfo");
	case SOAP_TYPE_PointerTons1__layer3Info:
		return soap_in_PointerTons1__layer3Info(soap, NULL, NULL, "ns1:layer3Info");
	case SOAP_TYPE_PointerTons1__layer2Info:
		return soap_in_PointerTons1__layer2Info(soap, NULL, NULL, "ns1:layer2Info");
	case SOAP_TYPE_PointerTons3__CtrlPlanePathContent:
		return soap_in_PointerTons3__CtrlPlanePathContent(soap, NULL, NULL, "ns3:CtrlPlanePathContent");
	case SOAP_TYPE_PointerTons1__teardownPathResponseContent:
		return soap_in_PointerTons1__teardownPathResponseContent(soap, NULL, NULL, "ns1:teardownPathResponseContent");
	case SOAP_TYPE_PointerTons1__refreshPathResponseContent:
		return soap_in_PointerTons1__refreshPathResponseContent(soap, NULL, NULL, "ns1:refreshPathResponseContent");
	case SOAP_TYPE_PointerTons1__createPathResponseContent:
		return soap_in_PointerTons1__createPathResponseContent(soap, NULL, NULL, "ns1:createPathResponseContent");
	case SOAP_TYPE_PointerTons1__listReply:
		return soap_in_PointerTons1__listReply(soap, NULL, NULL, "ns1:listReply");
	case SOAP_TYPE_PointerTons1__modifyResReply:
		return soap_in_PointerTons1__modifyResReply(soap, NULL, NULL, "ns1:modifyResReply");
	case SOAP_TYPE_PointerTons1__createReply:
		return soap_in_PointerTons1__createReply(soap, NULL, NULL, "ns1:createReply");
	case SOAP_TYPE_PointerTons1__teardownPathContent:
		return soap_in_PointerTons1__teardownPathContent(soap, NULL, NULL, "ns1:teardownPathContent");
	case SOAP_TYPE_PointerTons1__refreshPathContent:
		return soap_in_PointerTons1__refreshPathContent(soap, NULL, NULL, "ns1:refreshPathContent");
	case SOAP_TYPE_PointerTons1__createPathContent:
		return soap_in_PointerTons1__createPathContent(soap, NULL, NULL, "ns1:createPathContent");
	case SOAP_TYPE_PointerTons1__listRequest:
		return soap_in_PointerTons1__listRequest(soap, NULL, NULL, "ns1:listRequest");
	case SOAP_TYPE_PointerTons1__globalReservationId:
		return soap_in_PointerTons1__globalReservationId(soap, NULL, NULL, "ns1:globalReservationId");
	case SOAP_TYPE_PointerTons1__modifyResContent:
		return soap_in_PointerTons1__modifyResContent(soap, NULL, NULL, "ns1:modifyResContent");
	case SOAP_TYPE_PointerTons1__resCreateContent:
		return soap_in_PointerTons1__resCreateContent(soap, NULL, NULL, "ns1:resCreateContent");
	case SOAP_TYPE_PointerToPointerTons1__resDetails:
		return soap_in_PointerToPointerTons1__resDetails(soap, NULL, NULL, "ns1:resDetails");
	case SOAP_TYPE_PointerToPointerTons1__vlanTag:
		return soap_in_PointerToPointerTons1__vlanTag(soap, NULL, NULL, "ns1:vlanTag");
	case SOAP_TYPE_PointerTons1__vlanTag:
		return soap_in_PointerTons1__vlanTag(soap, NULL, NULL, "ns1:vlanTag");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons3__CtrlPlaneTopologyContent:
		return soap_in_PointerTons3__CtrlPlaneTopologyContent(soap, NULL, NULL, "ns3:CtrlPlaneTopologyContent");
	case SOAP_TYPE_PointerTons1__resDetails:
		return soap_in_PointerTons1__resDetails(soap, NULL, NULL, "ns1:resDetails");
	case SOAP_TYPE_PointerTons1__pathInfo:
		return soap_in_PointerTons1__pathInfo(soap, NULL, NULL, "ns1:pathInfo");
	case SOAP_TYPE_ns4__AbsoluteOrRelativeTimeType:
	{	char **s;
		s = soap_in_ns4__AbsoluteOrRelativeTimeType(soap, NULL, NULL, "ns4:AbsoluteOrRelativeTimeType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_in_PointerTo_wsse__Security(soap, NULL, NULL, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_in_PointerTods__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		return soap_in_PointerToxenc__EncryptedKeyType(soap, NULL, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_in_PointerTo_wsse__BinarySecurityToken(soap, NULL, NULL, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_in_PointerTo_wsse__UsernameToken(soap, NULL, NULL, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_in_PointerTo_wsu__Timestamp(soap, NULL, NULL, "wsu:Timestamp");
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		return soap_in_PointerTo_xenc__ReferenceList(soap, NULL, NULL, "xenc:ReferenceList");
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		return soap_in_PointerToxenc__ReferenceType(soap, NULL, NULL, "xenc:ReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		return soap_in_PointerToxenc__EncryptionPropertyType(soap, NULL, NULL, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_PointerToxenc__TransformsType:
		return soap_in_PointerToxenc__TransformsType(soap, NULL, NULL, "xenc:TransformsType");
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		return soap_in_PointerToxenc__CipherReferenceType(soap, NULL, NULL, "xenc:CipherReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		return soap_in_PointerToxenc__EncryptionPropertiesType(soap, NULL, NULL, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		return soap_in_PointerToxenc__CipherDataType(soap, NULL, NULL, "xenc:CipherDataType");
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		return soap_in_PointerTo_ds__KeyInfo(soap, NULL, NULL, "ds:KeyInfo");
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		return soap_in_PointerToxenc__EncryptionMethodType(soap, NULL, NULL, "xenc:EncryptionMethodType");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_in_PointerTods__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_in_PointerTods__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_in_PointerTods__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_in_PointerTods__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_in_PointerTods__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_in_PointerTods__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_in_PointerToPointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_in_PointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_in_PointerTods__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_in_PointerTods__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_in_PointerTo_wsse__SecurityTokenReference(soap, NULL, NULL, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_in_PointerTods__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_in_PointerTods__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_in_PointerTods__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, NULL, NULL, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_in_PointerTods__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_in_PointerTods__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_in_PointerTo_wsse__Embedded(soap, NULL, NULL, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_in_PointerTo_wsse__KeyIdentifier(soap, NULL, NULL, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_in_PointerTo_wsse__Reference(soap, NULL, NULL, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_in_PointerTo_wsse__Password(soap, NULL, NULL, "wsse:Password");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_in_PointerTo_wsa5__FaultTo(soap, NULL, NULL, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_in_PointerTo_wsa5__ReplyTo(soap, NULL, NULL, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_in_PointerTo_wsa5__From(soap, NULL, NULL, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_in_PointerTo_wsa5__RelatesTo(soap, NULL, NULL, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
	{	char **s;
		s = soap_in__wsa5__ProblemHeaderQName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_in_PointerTowsa5__MetadataType(soap, NULL, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_in_PointerTowsa5__ReferenceParametersType(soap, NULL, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa5__FaultCodesOpenEnumType(soap, NULL, NULL, "wsa5:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, NULL, NULL, "wsa5:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean_;
			return soap_in_xsd__boolean_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum"))
		{	*type = SOAP_TYPE_wsse__FaultcodeEnum;
			return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:tTimestampFault"))
		{	*type = SOAP_TYPE_wsu__tTimestampFault;
			return soap_in_wsu__tTimestampFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa5__IsReferenceParameter;
			return soap_in__wsa5__IsReferenceParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa5__FaultCodesType;
			return soap_in_wsa5__FaultCodesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipType"))
		{	*type = SOAP_TYPE_wsa5__RelationshipType;
			return soap_in_wsa5__RelationshipType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ResourceUnavailableFaultType"))
		{	*type = SOAP_TYPE_ns5__ResourceUnavailableFaultType;
			return soap_in_ns5__ResourceUnavailableFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ResourceUnknownFaultType"))
		{	*type = SOAP_TYPE_ns5__ResourceUnknownFaultType;
			return soap_in_ns5__ResourceUnknownFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ResumeFailedFaultType"))
		{	*type = SOAP_TYPE_ns4__ResumeFailedFaultType;
			return soap_in_ns4__ResumeFailedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:PauseFailedFaultType"))
		{	*type = SOAP_TYPE_ns4__PauseFailedFaultType;
			return soap_in_ns4__PauseFailedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UnableToDestroySubscriptionFaultType"))
		{	*type = SOAP_TYPE_ns4__UnableToDestroySubscriptionFaultType;
			return soap_in_ns4__UnableToDestroySubscriptionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UnacceptableTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_ns4__UnacceptableTerminationTimeFaultType;
			return soap_in_ns4__UnacceptableTerminationTimeFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UnableToCreatePullPointFaultType"))
		{	*type = SOAP_TYPE_ns4__UnableToCreatePullPointFaultType;
			return soap_in_ns4__UnableToCreatePullPointFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UnableToDestroyPullPointFaultType"))
		{	*type = SOAP_TYPE_ns4__UnableToDestroyPullPointFaultType;
			return soap_in_ns4__UnableToDestroyPullPointFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UnableToGetMessagesFaultType"))
		{	*type = SOAP_TYPE_ns4__UnableToGetMessagesFaultType;
			return soap_in_ns4__UnableToGetMessagesFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:NoCurrentMessageOnTopicFaultType"))
		{	*type = SOAP_TYPE_ns4__NoCurrentMessageOnTopicFaultType;
			return soap_in_ns4__NoCurrentMessageOnTopicFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UnacceptableInitialTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_ns4__UnacceptableInitialTerminationTimeFaultType;
			return soap_in_ns4__UnacceptableInitialTerminationTimeFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:NotifyMessageNotSupportedFaultType"))
		{	*type = SOAP_TYPE_ns4__NotifyMessageNotSupportedFaultType;
			return soap_in_ns4__NotifyMessageNotSupportedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UnsupportedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_ns4__UnsupportedPolicyRequestFaultType;
			return soap_in_ns4__UnsupportedPolicyRequestFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UnrecognizedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_ns4__UnrecognizedPolicyRequestFaultType;
			return soap_in_ns4__UnrecognizedPolicyRequestFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:InvalidMessageContentExpressionFaultType"))
		{	*type = SOAP_TYPE_ns4__InvalidMessageContentExpressionFaultType;
			return soap_in_ns4__InvalidMessageContentExpressionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:InvalidProducerPropertiesExpressionFaultType"))
		{	*type = SOAP_TYPE_ns4__InvalidProducerPropertiesExpressionFaultType;
			return soap_in_ns4__InvalidProducerPropertiesExpressionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:MultipleTopicsSpecifiedFaultType"))
		{	*type = SOAP_TYPE_ns4__MultipleTopicsSpecifiedFaultType;
			return soap_in_ns4__MultipleTopicsSpecifiedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TopicNotSupportedFaultType"))
		{	*type = SOAP_TYPE_ns4__TopicNotSupportedFaultType;
			return soap_in_ns4__TopicNotSupportedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:InvalidTopicExpressionFaultType"))
		{	*type = SOAP_TYPE_ns4__InvalidTopicExpressionFaultType;
			return soap_in_ns4__InvalidTopicExpressionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TopicExpressionDialectUnknownFaultType"))
		{	*type = SOAP_TYPE_ns4__TopicExpressionDialectUnknownFaultType;
			return soap_in_ns4__TopicExpressionDialectUnknownFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:InvalidFilterFaultType"))
		{	*type = SOAP_TYPE_ns4__InvalidFilterFaultType;
			return soap_in_ns4__InvalidFilterFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SubscribeCreationFailedFaultType"))
		{	*type = SOAP_TYPE_ns4__SubscribeCreationFailedFaultType;
			return soap_in_ns4__SubscribeCreationFailedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:reservationResourceType"))
		{	*type = SOAP_TYPE_ns1__reservationResourceType;
			return soap_in_ns1__reservationResourceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:FaultCauseType"))
		{	*type = SOAP_TYPE_ns6__FaultCauseType;
			return soap_in_ns6__FaultCauseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ErrorCodeType"))
		{	*type = SOAP_TYPE_ns6__ErrorCodeType;
			return soap_in_ns6__ErrorCodeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:BaseFaultType"))
		{	*type = SOAP_TYPE_ns6__BaseFaultType;
			return soap_in_ns6__BaseFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:MessageType"))
		{	*type = SOAP_TYPE_ns4__MessageType;
			return soap_in_ns4__MessageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:NotificationMessageHolderType"))
		{	*type = SOAP_TYPE_ns4__NotificationMessageHolderType;
			return soap_in_ns4__NotificationMessageHolderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SubscriptionPolicyType"))
		{	*type = SOAP_TYPE_ns4__SubscriptionPolicyType;
			return soap_in_ns4__SubscriptionPolicyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:QueryExpressionType"))
		{	*type = SOAP_TYPE_ns4__QueryExpressionType;
			return soap_in_ns4__QueryExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TopicExpressionType"))
		{	*type = SOAP_TYPE_ns4__TopicExpressionType;
			return soap_in_ns4__TopicExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:FilterType"))
		{	*type = SOAP_TYPE_ns4__FilterType;
			return soap_in_ns4__FilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlaneSwitchingCapabilitySpecificInfo"))
		{	*type = SOAP_TYPE_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo;
			return soap_in_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Duration"))
		{	*type = SOAP_TYPE_ns3__Duration;
			return soap_in_ns3__Duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TimeContent"))
		{	*type = SOAP_TYPE_ns3__TimeContent;
			return soap_in_ns3__TimeContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlaneNextHopContent"))
		{	*type = SOAP_TYPE_ns3__CtrlPlaneNextHopContent;
			return soap_in_ns3__CtrlPlaneNextHopContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlaneHopContent"))
		{	*type = SOAP_TYPE_ns3__CtrlPlaneHopContent;
			return soap_in_ns3__CtrlPlaneHopContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlaneSwcapContent"))
		{	*type = SOAP_TYPE_ns3__CtrlPlaneSwcapContent;
			return soap_in_ns3__CtrlPlaneSwcapContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlaneAdministrativeGroup"))
		{	*type = SOAP_TYPE_ns3__CtrlPlaneAdministrativeGroup;
			return soap_in_ns3__CtrlPlaneAdministrativeGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlaneAddressContent"))
		{	*type = SOAP_TYPE_ns3__CtrlPlaneAddressContent;
			return soap_in_ns3__CtrlPlaneAddressContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlaneLinkContent"))
		{	*type = SOAP_TYPE_ns3__CtrlPlaneLinkContent;
			return soap_in_ns3__CtrlPlaneLinkContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlanePortContent"))
		{	*type = SOAP_TYPE_ns3__CtrlPlanePortContent;
			return soap_in_ns3__CtrlPlanePortContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlaneNodeContent"))
		{	*type = SOAP_TYPE_ns3__CtrlPlaneNodeContent;
			return soap_in_ns3__CtrlPlaneNodeContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Lifetime"))
		{	*type = SOAP_TYPE_ns3__Lifetime;
			return soap_in_ns3__Lifetime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlaneDomainSignatureContent"))
		{	*type = SOAP_TYPE_ns3__CtrlPlaneDomainSignatureContent;
			return soap_in_ns3__CtrlPlaneDomainSignatureContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlaneDomainContent"))
		{	*type = SOAP_TYPE_ns3__CtrlPlaneDomainContent;
			return soap_in_ns3__CtrlPlaneDomainContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:localDetails"))
		{	*type = SOAP_TYPE_ns1__localDetails;
			return soap_in_ns1__localDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:msgDetails"))
		{	*type = SOAP_TYPE_ns1__msgDetails;
			return soap_in_ns1__msgDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:eventContent"))
		{	*type = SOAP_TYPE_ns1__eventContent;
			return soap_in_ns1__eventContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mplsInfo"))
		{	*type = SOAP_TYPE_ns1__mplsInfo;
			return soap_in_ns1__mplsInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:layer3Info"))
		{	*type = SOAP_TYPE_ns1__layer3Info;
			return soap_in_ns1__layer3Info(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:layer2Info"))
		{	*type = SOAP_TYPE_ns1__layer2Info;
			return soap_in_ns1__layer2Info(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlanePathContent"))
		{	*type = SOAP_TYPE_ns3__CtrlPlanePathContent;
			return soap_in_ns3__CtrlPlanePathContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:forwardReply"))
		{	*type = SOAP_TYPE_ns1__forwardReply;
			return soap_in_ns1__forwardReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:globalReservationId"))
		{	*type = SOAP_TYPE_ns1__globalReservationId;
			return soap_in_ns1__globalReservationId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:forwardPayload"))
		{	*type = SOAP_TYPE_ns1__forwardPayload;
			return soap_in_ns1__forwardPayload(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listReply"))
		{	*type = SOAP_TYPE_ns1__listReply;
			return soap_in_ns1__listReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:vlanTag"))
		{	*type = SOAP_TYPE_ns1__vlanTag;
			return soap_in_ns1__vlanTag(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listRequest"))
		{	*type = SOAP_TYPE_ns1__listRequest;
			return soap_in_ns1__listRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:teardownPathResponseContent"))
		{	*type = SOAP_TYPE_ns1__teardownPathResponseContent;
			return soap_in_ns1__teardownPathResponseContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:teardownPathContent"))
		{	*type = SOAP_TYPE_ns1__teardownPathContent;
			return soap_in_ns1__teardownPathContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:refreshPathResponseContent"))
		{	*type = SOAP_TYPE_ns1__refreshPathResponseContent;
			return soap_in_ns1__refreshPathResponseContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:refreshPathContent"))
		{	*type = SOAP_TYPE_ns1__refreshPathContent;
			return soap_in_ns1__refreshPathContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createPathResponseContent"))
		{	*type = SOAP_TYPE_ns1__createPathResponseContent;
			return soap_in_ns1__createPathResponseContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createPathContent"))
		{	*type = SOAP_TYPE_ns1__createPathContent;
			return soap_in_ns1__createPathContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CtrlPlaneTopologyContent"))
		{	*type = SOAP_TYPE_ns3__CtrlPlaneTopologyContent;
			return soap_in_ns3__CtrlPlaneTopologyContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTopologyResponseContent"))
		{	*type = SOAP_TYPE_ns1__getTopologyResponseContent;
			return soap_in_ns1__getTopologyResponseContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTopologyContent"))
		{	*type = SOAP_TYPE_ns1__getTopologyContent;
			return soap_in_ns1__getTopologyContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:resDetails"))
		{	*type = SOAP_TYPE_ns1__resDetails;
			return soap_in_ns1__resDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyResReply"))
		{	*type = SOAP_TYPE_ns1__modifyResReply;
			return soap_in_ns1__modifyResReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyResContent"))
		{	*type = SOAP_TYPE_ns1__modifyResContent;
			return soap_in_ns1__modifyResContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createReply"))
		{	*type = SOAP_TYPE_ns1__createReply;
			return soap_in_ns1__createReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:pathInfo"))
		{	*type = SOAP_TYPE_ns1__pathInfo;
			return soap_in_ns1__pathInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:resCreateContent"))
		{	*type = SOAP_TYPE_ns1__resCreateContent;
			return soap_in_ns1__resCreateContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionPropertyType"))
		{	*type = SOAP_TYPE_xenc__EncryptionPropertyType;
			return soap_in_xenc__EncryptionPropertyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionPropertiesType"))
		{	*type = SOAP_TYPE_xenc__EncryptionPropertiesType;
			return soap_in_xenc__EncryptionPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:ReferenceType"))
		{	*type = SOAP_TYPE_xenc__ReferenceType;
			return soap_in_xenc__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:AgreementMethodType"))
		{	*type = SOAP_TYPE_xenc__AgreementMethodType;
			return soap_in_xenc__AgreementMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedKeyType"))
		{	*type = SOAP_TYPE_xenc__EncryptedKeyType;
			return soap_in_xenc__EncryptedKeyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedDataType"))
		{	*type = SOAP_TYPE_xenc__EncryptedDataType;
			return soap_in_xenc__EncryptedDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:TransformsType"))
		{	*type = SOAP_TYPE_xenc__TransformsType;
			return soap_in_xenc__TransformsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:CipherReferenceType"))
		{	*type = SOAP_TYPE_xenc__CipherReferenceType;
			return soap_in_xenc__CipherReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:CipherDataType"))
		{	*type = SOAP_TYPE_xenc__CipherDataType;
			return soap_in_xenc__CipherDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionMethodType"))
		{	*type = SOAP_TYPE_xenc__EncryptionMethodType;
			return soap_in_xenc__EncryptionMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedType"))
		{	*type = SOAP_TYPE_xenc__EncryptedType;
			return soap_in_xenc__EncryptedType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__RSAKeyValueType;
			return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__DSAKeyValueType;
			return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType"))
		{	*type = SOAP_TYPE_ds__X509IssuerSerialType;
			return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509DataType"))
		{	*type = SOAP_TYPE_ds__X509DataType;
			return soap_in_ds__X509DataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RetrievalMethodType"))
		{	*type = SOAP_TYPE_ds__RetrievalMethodType;
			return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyValueType"))
		{	*type = SOAP_TYPE_ds__KeyValueType;
			return soap_in_ds__KeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DigestMethodType"))
		{	*type = SOAP_TYPE_ds__DigestMethodType;
			return soap_in_ds__DigestMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformType"))
		{	*type = SOAP_TYPE_ds__TransformType;
			return soap_in_ds__TransformType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformsType"))
		{	*type = SOAP_TYPE_ds__TransformsType;
			return soap_in_ds__TransformsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:ReferenceType"))
		{	*type = SOAP_TYPE_ds__ReferenceType;
			return soap_in_ds__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureMethodType"))
		{	*type = SOAP_TYPE_ds__SignatureMethodType;
			return soap_in_ds__SignatureMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType"))
		{	*type = SOAP_TYPE_ds__CanonicalizationMethodType;
			return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfoType"))
		{	*type = SOAP_TYPE_ds__KeyInfoType;
			return soap_in_ds__KeyInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignedInfoType"))
		{	*type = SOAP_TYPE_ds__SignedInfoType;
			return soap_in_ds__SignedInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureType"))
		{	*type = SOAP_TYPE_ds__SignatureType;
			return soap_in_ds__SignatureType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa5__ProblemActionType;
			return soap_in_wsa5__ProblemActionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesToType"))
		{	*type = SOAP_TYPE_wsa5__RelatesToType;
			return soap_in_wsa5__RelatesToType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:MetadataType"))
		{	*type = SOAP_TYPE_wsa5__MetadataType;
			return soap_in_wsa5__MetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa5__ReferenceParametersType;
			return soap_in_wsa5__ReferenceParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType;
			return soap_in_wsa5__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:AbsoluteOrRelativeTimeType"))
		{	char **s;
			*type = SOAP_TYPE_ns4__AbsoluteOrRelativeTimeType;
			s = soap_in_ns4__AbsoluteOrRelativeTimeType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemHeaderQName;
			s = soap_in__wsa5__ProblemHeaderQName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
			s = soap_in_wsa5__FaultCodesOpenEnumType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
			s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsa5:RetryAfter"))
		{	*type = SOAP_TYPE__wsa5__RetryAfter;
			return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ResumeSubscriptionResponse"))
		{	*type = SOAP_TYPE__ns4__ResumeSubscriptionResponse;
			return soap_in__ns4__ResumeSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ResumeSubscription"))
		{	*type = SOAP_TYPE__ns4__ResumeSubscription;
			return soap_in__ns4__ResumeSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:PauseSubscriptionResponse"))
		{	*type = SOAP_TYPE__ns4__PauseSubscriptionResponse;
			return soap_in__ns4__PauseSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:PauseSubscription"))
		{	*type = SOAP_TYPE__ns4__PauseSubscription;
			return soap_in__ns4__PauseSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UnsubscribeResponse"))
		{	*type = SOAP_TYPE__ns4__UnsubscribeResponse;
			return soap_in__ns4__UnsubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Unsubscribe"))
		{	*type = SOAP_TYPE__ns4__Unsubscribe;
			return soap_in__ns4__Unsubscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RenewResponse"))
		{	*type = SOAP_TYPE__ns4__RenewResponse;
			return soap_in__ns4__RenewResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Renew"))
		{	*type = SOAP_TYPE__ns4__Renew;
			return soap_in__ns4__Renew(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CreatePullPointResponse"))
		{	*type = SOAP_TYPE__ns4__CreatePullPointResponse;
			return soap_in__ns4__CreatePullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CreatePullPoint"))
		{	*type = SOAP_TYPE__ns4__CreatePullPoint;
			return soap_in__ns4__CreatePullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DestroyPullPointResponse"))
		{	*type = SOAP_TYPE__ns4__DestroyPullPointResponse;
			return soap_in__ns4__DestroyPullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DestroyPullPoint"))
		{	*type = SOAP_TYPE__ns4__DestroyPullPoint;
			return soap_in__ns4__DestroyPullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMessagesResponse"))
		{	*type = SOAP_TYPE__ns4__GetMessagesResponse;
			return soap_in__ns4__GetMessagesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetMessages"))
		{	*type = SOAP_TYPE__ns4__GetMessages;
			return soap_in__ns4__GetMessages(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetCurrentMessageResponse"))
		{	*type = SOAP_TYPE__ns4__GetCurrentMessageResponse;
			return soap_in__ns4__GetCurrentMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetCurrentMessage"))
		{	*type = SOAP_TYPE__ns4__GetCurrentMessage;
			return soap_in__ns4__GetCurrentMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SubscribeResponse"))
		{	*type = SOAP_TYPE__ns4__SubscribeResponse;
			return soap_in__ns4__SubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Subscribe-SubscriptionPolicy"))
		{	*type = SOAP_TYPE__ns4__Subscribe_SubscriptionPolicy;
			return soap_in__ns4__Subscribe_SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Subscribe"))
		{	*type = SOAP_TYPE__ns4__Subscribe;
			return soap_in__ns4__Subscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UseRaw"))
		{	*type = SOAP_TYPE__ns4__UseRaw;
			return soap_in__ns4__UseRaw(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Notify"))
		{	*type = SOAP_TYPE__ns4__Notify;
			return soap_in__ns4__Notify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SubscriptionManagerRP"))
		{	*type = SOAP_TYPE__ns4__SubscriptionManagerRP;
			return soap_in__ns4__SubscriptionManagerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SignalFault"))
		{	*type = SOAP_TYPE__ns1__SignalFault;
			return soap_in__ns1__SignalFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TopologyFault"))
		{	*type = SOAP_TYPE__ns1__TopologyFault;
			return soap_in__ns1__TopologyFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BSSFault"))
		{	*type = SOAP_TYPE__ns1__BSSFault;
			return soap_in__ns1__BSSFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AAAFault"))
		{	*type = SOAP_TYPE__ns1__AAAFault;
			return soap_in__ns1__AAAFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:forward"))
		{	*type = SOAP_TYPE__ns1__forward;
			return soap_in__ns1__forward(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Security"))
		{	*type = SOAP_TYPE__wsse__Security;
			return soap_in__wsse__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:ReferenceList"))
		{	*type = SOAP_TYPE__xenc__ReferenceList;
			return soap_in__xenc__ReferenceList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfo"))
		{	*type = SOAP_TYPE__ds__KeyInfo;
			return soap_in__ds__KeyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:Transform"))
		{	*type = SOAP_TYPE__ds__Transform;
			return soap_in__ds__Transform(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces"))
		{	*type = SOAP_TYPE__c14n__InclusiveNamespaces;
			return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:Signature"))
		{	*type = SOAP_TYPE__ds__Signature;
			return soap_in__ds__Signature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference"))
		{	*type = SOAP_TYPE__wsse__SecurityTokenReference;
			return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:KeyIdentifier"))
		{	*type = SOAP_TYPE__wsse__KeyIdentifier;
			return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Embedded"))
		{	*type = SOAP_TYPE__wsse__Embedded;
			return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Reference"))
		{	*type = SOAP_TYPE__wsse__Reference;
			return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken"))
		{	*type = SOAP_TYPE__wsse__BinarySecurityToken;
			return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Password"))
		{	*type = SOAP_TYPE__wsse__Password;
			return soap_in__wsse__Password(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:UsernameToken"))
		{	*type = SOAP_TYPE__wsse__UsernameToken;
			return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:Timestamp"))
		{	*type = SOAP_TYPE__wsu__Timestamp;
			return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemAction"))
		{	*type = SOAP_TYPE__wsa5__ProblemAction;
			return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultTo"))
		{	*type = SOAP_TYPE__wsa5__FaultTo;
			return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:From"))
		{	*type = SOAP_TYPE__wsa5__From;
			return soap_in__wsa5__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReplyTo"))
		{	*type = SOAP_TYPE__wsa5__ReplyTo;
			return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesTo"))
		{	*type = SOAP_TYPE__wsa5__RelatesTo;
			return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:Metadata"))
		{	*type = SOAP_TYPE__wsa5__Metadata;
			return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa5__ReferenceParameters;
			return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReference"))
		{	*type = SOAP_TYPE__wsa5__EndpointReference;
			return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemIRI"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemIRI;
			s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__Action;
			s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__To;
			s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__MessageID;
			s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE__wsa5__RetryAfter:
		return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, NULL);
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean_:
		return soap_out_xsd__boolean_(soap, tag, id, (const enum xsd__boolean_ *)ptr, "xsd:boolean");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
	case SOAP_TYPE_ns5__ResourceUnavailableFaultType:
		return soap_out_ns5__ResourceUnavailableFaultType(soap, tag, id, (const struct ns5__ResourceUnavailableFaultType *)ptr, "ns5:ResourceUnavailableFaultType");
	case SOAP_TYPE_ns5__ResourceUnknownFaultType:
		return soap_out_ns5__ResourceUnknownFaultType(soap, tag, id, (const struct ns5__ResourceUnknownFaultType *)ptr, "ns5:ResourceUnknownFaultType");
	case SOAP_TYPE_ns4__ResumeFailedFaultType:
		return soap_out_ns4__ResumeFailedFaultType(soap, tag, id, (const struct ns4__ResumeFailedFaultType *)ptr, "ns4:ResumeFailedFaultType");
	case SOAP_TYPE_ns4__PauseFailedFaultType:
		return soap_out_ns4__PauseFailedFaultType(soap, tag, id, (const struct ns4__PauseFailedFaultType *)ptr, "ns4:PauseFailedFaultType");
	case SOAP_TYPE_ns4__UnableToDestroySubscriptionFaultType:
		return soap_out_ns4__UnableToDestroySubscriptionFaultType(soap, tag, id, (const struct ns4__UnableToDestroySubscriptionFaultType *)ptr, "ns4:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_ns4__UnacceptableTerminationTimeFaultType:
		return soap_out_ns4__UnacceptableTerminationTimeFaultType(soap, tag, id, (const struct ns4__UnacceptableTerminationTimeFaultType *)ptr, "ns4:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_ns4__UnableToCreatePullPointFaultType:
		return soap_out_ns4__UnableToCreatePullPointFaultType(soap, tag, id, (const struct ns4__UnableToCreatePullPointFaultType *)ptr, "ns4:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_ns4__UnableToDestroyPullPointFaultType:
		return soap_out_ns4__UnableToDestroyPullPointFaultType(soap, tag, id, (const struct ns4__UnableToDestroyPullPointFaultType *)ptr, "ns4:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_ns4__UnableToGetMessagesFaultType:
		return soap_out_ns4__UnableToGetMessagesFaultType(soap, tag, id, (const struct ns4__UnableToGetMessagesFaultType *)ptr, "ns4:UnableToGetMessagesFaultType");
	case SOAP_TYPE_ns4__NoCurrentMessageOnTopicFaultType:
		return soap_out_ns4__NoCurrentMessageOnTopicFaultType(soap, tag, id, (const struct ns4__NoCurrentMessageOnTopicFaultType *)ptr, "ns4:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_ns4__UnacceptableInitialTerminationTimeFaultType:
		return soap_out_ns4__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, (const struct ns4__UnacceptableInitialTerminationTimeFaultType *)ptr, "ns4:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_ns4__NotifyMessageNotSupportedFaultType:
		return soap_out_ns4__NotifyMessageNotSupportedFaultType(soap, tag, id, (const struct ns4__NotifyMessageNotSupportedFaultType *)ptr, "ns4:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_ns4__UnsupportedPolicyRequestFaultType:
		return soap_out_ns4__UnsupportedPolicyRequestFaultType(soap, tag, id, (const struct ns4__UnsupportedPolicyRequestFaultType *)ptr, "ns4:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_ns4__UnrecognizedPolicyRequestFaultType:
		return soap_out_ns4__UnrecognizedPolicyRequestFaultType(soap, tag, id, (const struct ns4__UnrecognizedPolicyRequestFaultType *)ptr, "ns4:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_ns4__InvalidMessageContentExpressionFaultType:
		return soap_out_ns4__InvalidMessageContentExpressionFaultType(soap, tag, id, (const struct ns4__InvalidMessageContentExpressionFaultType *)ptr, "ns4:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_ns4__InvalidProducerPropertiesExpressionFaultType:
		return soap_out_ns4__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, (const struct ns4__InvalidProducerPropertiesExpressionFaultType *)ptr, "ns4:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_ns4__MultipleTopicsSpecifiedFaultType:
		return soap_out_ns4__MultipleTopicsSpecifiedFaultType(soap, tag, id, (const struct ns4__MultipleTopicsSpecifiedFaultType *)ptr, "ns4:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_ns4__TopicNotSupportedFaultType:
		return soap_out_ns4__TopicNotSupportedFaultType(soap, tag, id, (const struct ns4__TopicNotSupportedFaultType *)ptr, "ns4:TopicNotSupportedFaultType");
	case SOAP_TYPE_ns4__InvalidTopicExpressionFaultType:
		return soap_out_ns4__InvalidTopicExpressionFaultType(soap, tag, id, (const struct ns4__InvalidTopicExpressionFaultType *)ptr, "ns4:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_ns4__TopicExpressionDialectUnknownFaultType:
		return soap_out_ns4__TopicExpressionDialectUnknownFaultType(soap, tag, id, (const struct ns4__TopicExpressionDialectUnknownFaultType *)ptr, "ns4:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_ns4__InvalidFilterFaultType:
		return soap_out_ns4__InvalidFilterFaultType(soap, tag, id, (const struct ns4__InvalidFilterFaultType *)ptr, "ns4:InvalidFilterFaultType");
	case SOAP_TYPE_ns4__SubscribeCreationFailedFaultType:
		return soap_out_ns4__SubscribeCreationFailedFaultType(soap, tag, id, (const struct ns4__SubscribeCreationFailedFaultType *)ptr, "ns4:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_ns1__reservationResourceType:
		return soap_out_ns1__reservationResourceType(soap, tag, id, (const struct ns1__reservationResourceType *)ptr, "ns1:reservationResourceType");
	case SOAP_TYPE_ns6__FaultCauseType:
		return soap_out_ns6__FaultCauseType(soap, tag, id, (const struct ns6__FaultCauseType *)ptr, "ns6:FaultCauseType");
	case SOAP_TYPE_ns6__ErrorCodeType:
		return soap_out_ns6__ErrorCodeType(soap, tag, id, (const struct ns6__ErrorCodeType *)ptr, "ns6:ErrorCodeType");
	case SOAP_TYPE_ns6__BaseFaultType:
		return soap_out_ns6__BaseFaultType(soap, tag, id, (const struct ns6__BaseFaultType *)ptr, "ns6:BaseFaultType");
	case SOAP_TYPE__ns4__ResumeSubscriptionResponse:
		return soap_out__ns4__ResumeSubscriptionResponse(soap, "ns4:ResumeSubscriptionResponse", id, (const struct _ns4__ResumeSubscriptionResponse *)ptr, NULL);
	case SOAP_TYPE__ns4__ResumeSubscription:
		return soap_out__ns4__ResumeSubscription(soap, "ns4:ResumeSubscription", id, (const struct _ns4__ResumeSubscription *)ptr, NULL);
	case SOAP_TYPE__ns4__PauseSubscriptionResponse:
		return soap_out__ns4__PauseSubscriptionResponse(soap, "ns4:PauseSubscriptionResponse", id, (const struct _ns4__PauseSubscriptionResponse *)ptr, NULL);
	case SOAP_TYPE__ns4__PauseSubscription:
		return soap_out__ns4__PauseSubscription(soap, "ns4:PauseSubscription", id, (const struct _ns4__PauseSubscription *)ptr, NULL);
	case SOAP_TYPE__ns4__UnsubscribeResponse:
		return soap_out__ns4__UnsubscribeResponse(soap, "ns4:UnsubscribeResponse", id, (const struct _ns4__UnsubscribeResponse *)ptr, NULL);
	case SOAP_TYPE__ns4__Unsubscribe:
		return soap_out__ns4__Unsubscribe(soap, "ns4:Unsubscribe", id, (const struct _ns4__Unsubscribe *)ptr, NULL);
	case SOAP_TYPE__ns4__RenewResponse:
		return soap_out__ns4__RenewResponse(soap, "ns4:RenewResponse", id, (const struct _ns4__RenewResponse *)ptr, NULL);
	case SOAP_TYPE__ns4__Renew:
		return soap_out__ns4__Renew(soap, "ns4:Renew", id, (const struct _ns4__Renew *)ptr, NULL);
	case SOAP_TYPE__ns4__CreatePullPointResponse:
		return soap_out__ns4__CreatePullPointResponse(soap, "ns4:CreatePullPointResponse", id, (const struct _ns4__CreatePullPointResponse *)ptr, NULL);
	case SOAP_TYPE__ns4__CreatePullPoint:
		return soap_out__ns4__CreatePullPoint(soap, "ns4:CreatePullPoint", id, (const struct _ns4__CreatePullPoint *)ptr, NULL);
	case SOAP_TYPE__ns4__DestroyPullPointResponse:
		return soap_out__ns4__DestroyPullPointResponse(soap, "ns4:DestroyPullPointResponse", id, (const struct _ns4__DestroyPullPointResponse *)ptr, NULL);
	case SOAP_TYPE__ns4__DestroyPullPoint:
		return soap_out__ns4__DestroyPullPoint(soap, "ns4:DestroyPullPoint", id, (const struct _ns4__DestroyPullPoint *)ptr, NULL);
	case SOAP_TYPE__ns4__GetMessagesResponse:
		return soap_out__ns4__GetMessagesResponse(soap, "ns4:GetMessagesResponse", id, (const struct _ns4__GetMessagesResponse *)ptr, NULL);
	case SOAP_TYPE__ns4__GetMessages:
		return soap_out__ns4__GetMessages(soap, "ns4:GetMessages", id, (const struct _ns4__GetMessages *)ptr, NULL);
	case SOAP_TYPE__ns4__GetCurrentMessageResponse:
		return soap_out__ns4__GetCurrentMessageResponse(soap, "ns4:GetCurrentMessageResponse", id, (const struct _ns4__GetCurrentMessageResponse *)ptr, NULL);
	case SOAP_TYPE__ns4__GetCurrentMessage:
		return soap_out__ns4__GetCurrentMessage(soap, "ns4:GetCurrentMessage", id, (const struct _ns4__GetCurrentMessage *)ptr, NULL);
	case SOAP_TYPE__ns4__SubscribeResponse:
		return soap_out__ns4__SubscribeResponse(soap, "ns4:SubscribeResponse", id, (const struct _ns4__SubscribeResponse *)ptr, NULL);
	case SOAP_TYPE__ns4__Subscribe_SubscriptionPolicy:
		return soap_out__ns4__Subscribe_SubscriptionPolicy(soap, "ns4:Subscribe-SubscriptionPolicy", id, (const struct _ns4__Subscribe_SubscriptionPolicy *)ptr, NULL);
	case SOAP_TYPE__ns4__Subscribe:
		return soap_out__ns4__Subscribe(soap, "ns4:Subscribe", id, (const struct _ns4__Subscribe *)ptr, NULL);
	case SOAP_TYPE__ns4__UseRaw:
		return soap_out__ns4__UseRaw(soap, "ns4:UseRaw", id, (const struct _ns4__UseRaw *)ptr, NULL);
	case SOAP_TYPE__ns4__Notify:
		return soap_out__ns4__Notify(soap, "ns4:Notify", id, (const struct _ns4__Notify *)ptr, NULL);
	case SOAP_TYPE__ns4__SubscriptionManagerRP:
		return soap_out__ns4__SubscriptionManagerRP(soap, "ns4:SubscriptionManagerRP", id, (const struct _ns4__SubscriptionManagerRP *)ptr, NULL);
	case SOAP_TYPE_ns4__MessageType:
		return soap_out_ns4__MessageType(soap, tag, id, (const struct ns4__MessageType *)ptr, "ns4:MessageType");
	case SOAP_TYPE_ns4__NotificationMessageHolderType:
		return soap_out_ns4__NotificationMessageHolderType(soap, tag, id, (const struct ns4__NotificationMessageHolderType *)ptr, "ns4:NotificationMessageHolderType");
	case SOAP_TYPE_ns4__SubscriptionPolicyType:
		return soap_out_ns4__SubscriptionPolicyType(soap, tag, id, (const struct ns4__SubscriptionPolicyType *)ptr, "ns4:SubscriptionPolicyType");
	case SOAP_TYPE_ns4__QueryExpressionType:
		return soap_out_ns4__QueryExpressionType(soap, tag, id, (const struct ns4__QueryExpressionType *)ptr, "ns4:QueryExpressionType");
	case SOAP_TYPE_ns4__TopicExpressionType:
		return soap_out_ns4__TopicExpressionType(soap, tag, id, (const struct ns4__TopicExpressionType *)ptr, "ns4:TopicExpressionType");
	case SOAP_TYPE_ns4__FilterType:
		return soap_out_ns4__FilterType(soap, tag, id, (const struct ns4__FilterType *)ptr, "ns4:FilterType");
	case SOAP_TYPE_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo:
		return soap_out_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag, id, (const struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *)ptr, "ns3:CtrlPlaneSwitchingCapabilitySpecificInfo");
	case SOAP_TYPE_ns3__Duration:
		return soap_out_ns3__Duration(soap, tag, id, (const struct ns3__Duration *)ptr, "ns3:Duration");
	case SOAP_TYPE_ns3__TimeContent:
		return soap_out_ns3__TimeContent(soap, tag, id, (const struct ns3__TimeContent *)ptr, "ns3:TimeContent");
	case SOAP_TYPE_ns3__CtrlPlaneNextHopContent:
		return soap_out_ns3__CtrlPlaneNextHopContent(soap, tag, id, (const struct ns3__CtrlPlaneNextHopContent *)ptr, "ns3:CtrlPlaneNextHopContent");
	case SOAP_TYPE_ns3__CtrlPlaneHopContent:
		return soap_out_ns3__CtrlPlaneHopContent(soap, tag, id, (const struct ns3__CtrlPlaneHopContent *)ptr, "ns3:CtrlPlaneHopContent");
	case SOAP_TYPE_ns3__CtrlPlaneSwcapContent:
		return soap_out_ns3__CtrlPlaneSwcapContent(soap, tag, id, (const struct ns3__CtrlPlaneSwcapContent *)ptr, "ns3:CtrlPlaneSwcapContent");
	case SOAP_TYPE_ns3__CtrlPlaneAdministrativeGroup:
		return soap_out_ns3__CtrlPlaneAdministrativeGroup(soap, tag, id, (const struct ns3__CtrlPlaneAdministrativeGroup *)ptr, "ns3:CtrlPlaneAdministrativeGroup");
	case SOAP_TYPE_ns3__CtrlPlaneAddressContent:
		return soap_out_ns3__CtrlPlaneAddressContent(soap, tag, id, (const struct ns3__CtrlPlaneAddressContent *)ptr, "ns3:CtrlPlaneAddressContent");
	case SOAP_TYPE_ns3__CtrlPlaneLinkContent:
		return soap_out_ns3__CtrlPlaneLinkContent(soap, tag, id, (const struct ns3__CtrlPlaneLinkContent *)ptr, "ns3:CtrlPlaneLinkContent");
	case SOAP_TYPE_ns3__CtrlPlanePortContent:
		return soap_out_ns3__CtrlPlanePortContent(soap, tag, id, (const struct ns3__CtrlPlanePortContent *)ptr, "ns3:CtrlPlanePortContent");
	case SOAP_TYPE_ns3__CtrlPlaneNodeContent:
		return soap_out_ns3__CtrlPlaneNodeContent(soap, tag, id, (const struct ns3__CtrlPlaneNodeContent *)ptr, "ns3:CtrlPlaneNodeContent");
	case SOAP_TYPE_ns3__Lifetime:
		return soap_out_ns3__Lifetime(soap, tag, id, (const struct ns3__Lifetime *)ptr, "ns3:Lifetime");
	case SOAP_TYPE_ns3__CtrlPlaneDomainSignatureContent:
		return soap_out_ns3__CtrlPlaneDomainSignatureContent(soap, tag, id, (const struct ns3__CtrlPlaneDomainSignatureContent *)ptr, "ns3:CtrlPlaneDomainSignatureContent");
	case SOAP_TYPE_ns3__CtrlPlaneDomainContent:
		return soap_out_ns3__CtrlPlaneDomainContent(soap, tag, id, (const struct ns3__CtrlPlaneDomainContent *)ptr, "ns3:CtrlPlaneDomainContent");
	case SOAP_TYPE__ns1__SignalFault:
		return soap_out__ns1__SignalFault(soap, "ns1:SignalFault", id, (const struct _ns1__SignalFault *)ptr, NULL);
	case SOAP_TYPE__ns1__TopologyFault:
		return soap_out__ns1__TopologyFault(soap, "ns1:TopologyFault", id, (const struct _ns1__TopologyFault *)ptr, NULL);
	case SOAP_TYPE__ns1__BSSFault:
		return soap_out__ns1__BSSFault(soap, "ns1:BSSFault", id, (const struct _ns1__BSSFault *)ptr, NULL);
	case SOAP_TYPE__ns1__AAAFault:
		return soap_out__ns1__AAAFault(soap, "ns1:AAAFault", id, (const struct _ns1__AAAFault *)ptr, NULL);
	case SOAP_TYPE__ns1__forward:
		return soap_out__ns1__forward(soap, "ns1:forward", id, (const struct _ns1__forward *)ptr, NULL);
	case SOAP_TYPE_ns1__localDetails:
		return soap_out_ns1__localDetails(soap, tag, id, (const struct ns1__localDetails *)ptr, "ns1:localDetails");
	case SOAP_TYPE_ns1__msgDetails:
		return soap_out_ns1__msgDetails(soap, tag, id, (const struct ns1__msgDetails *)ptr, "ns1:msgDetails");
	case SOAP_TYPE_ns1__eventContent:
		return soap_out_ns1__eventContent(soap, tag, id, (const struct ns1__eventContent *)ptr, "ns1:eventContent");
	case SOAP_TYPE_ns1__mplsInfo:
		return soap_out_ns1__mplsInfo(soap, tag, id, (const struct ns1__mplsInfo *)ptr, "ns1:mplsInfo");
	case SOAP_TYPE_ns1__layer3Info:
		return soap_out_ns1__layer3Info(soap, tag, id, (const struct ns1__layer3Info *)ptr, "ns1:layer3Info");
	case SOAP_TYPE_ns1__layer2Info:
		return soap_out_ns1__layer2Info(soap, tag, id, (const struct ns1__layer2Info *)ptr, "ns1:layer2Info");
	case SOAP_TYPE_ns3__CtrlPlanePathContent:
		return soap_out_ns3__CtrlPlanePathContent(soap, tag, id, (const struct ns3__CtrlPlanePathContent *)ptr, "ns3:CtrlPlanePathContent");
	case SOAP_TYPE_ns1__forwardReply:
		return soap_out_ns1__forwardReply(soap, tag, id, (const struct ns1__forwardReply *)ptr, "ns1:forwardReply");
	case SOAP_TYPE_ns1__globalReservationId:
		return soap_out_ns1__globalReservationId(soap, tag, id, (const struct ns1__globalReservationId *)ptr, "ns1:globalReservationId");
	case SOAP_TYPE_ns1__forwardPayload:
		return soap_out_ns1__forwardPayload(soap, tag, id, (const struct ns1__forwardPayload *)ptr, "ns1:forwardPayload");
	case SOAP_TYPE_ns1__listReply:
		return soap_out_ns1__listReply(soap, tag, id, (const struct ns1__listReply *)ptr, "ns1:listReply");
	case SOAP_TYPE_ns1__vlanTag:
		return soap_out_ns1__vlanTag(soap, tag, id, (const struct ns1__vlanTag *)ptr, "ns1:vlanTag");
	case SOAP_TYPE_ns1__listRequest:
		return soap_out_ns1__listRequest(soap, tag, id, (const struct ns1__listRequest *)ptr, "ns1:listRequest");
	case SOAP_TYPE_ns1__teardownPathResponseContent:
		return soap_out_ns1__teardownPathResponseContent(soap, tag, id, (const struct ns1__teardownPathResponseContent *)ptr, "ns1:teardownPathResponseContent");
	case SOAP_TYPE_ns1__teardownPathContent:
		return soap_out_ns1__teardownPathContent(soap, tag, id, (const struct ns1__teardownPathContent *)ptr, "ns1:teardownPathContent");
	case SOAP_TYPE_ns1__refreshPathResponseContent:
		return soap_out_ns1__refreshPathResponseContent(soap, tag, id, (const struct ns1__refreshPathResponseContent *)ptr, "ns1:refreshPathResponseContent");
	case SOAP_TYPE_ns1__refreshPathContent:
		return soap_out_ns1__refreshPathContent(soap, tag, id, (const struct ns1__refreshPathContent *)ptr, "ns1:refreshPathContent");
	case SOAP_TYPE_ns1__createPathResponseContent:
		return soap_out_ns1__createPathResponseContent(soap, tag, id, (const struct ns1__createPathResponseContent *)ptr, "ns1:createPathResponseContent");
	case SOAP_TYPE_ns1__createPathContent:
		return soap_out_ns1__createPathContent(soap, tag, id, (const struct ns1__createPathContent *)ptr, "ns1:createPathContent");
	case SOAP_TYPE_ns3__CtrlPlaneTopologyContent:
		return soap_out_ns3__CtrlPlaneTopologyContent(soap, tag, id, (const struct ns3__CtrlPlaneTopologyContent *)ptr, "ns3:CtrlPlaneTopologyContent");
	case SOAP_TYPE_ns1__getTopologyResponseContent:
		return soap_out_ns1__getTopologyResponseContent(soap, tag, id, (const struct ns1__getTopologyResponseContent *)ptr, "ns1:getTopologyResponseContent");
	case SOAP_TYPE_ns1__getTopologyContent:
		return soap_out_ns1__getTopologyContent(soap, tag, id, (const struct ns1__getTopologyContent *)ptr, "ns1:getTopologyContent");
	case SOAP_TYPE_ns1__resDetails:
		return soap_out_ns1__resDetails(soap, tag, id, (const struct ns1__resDetails *)ptr, "ns1:resDetails");
	case SOAP_TYPE_ns1__modifyResReply:
		return soap_out_ns1__modifyResReply(soap, tag, id, (const struct ns1__modifyResReply *)ptr, "ns1:modifyResReply");
	case SOAP_TYPE_ns1__modifyResContent:
		return soap_out_ns1__modifyResContent(soap, tag, id, (const struct ns1__modifyResContent *)ptr, "ns1:modifyResContent");
	case SOAP_TYPE_ns1__createReply:
		return soap_out_ns1__createReply(soap, tag, id, (const struct ns1__createReply *)ptr, "ns1:createReply");
	case SOAP_TYPE_ns1__pathInfo:
		return soap_out_ns1__pathInfo(soap, tag, id, (const struct ns1__pathInfo *)ptr, "ns1:pathInfo");
	case SOAP_TYPE_ns1__resCreateContent:
		return soap_out_ns1__resCreateContent(soap, tag, id, (const struct ns1__resCreateContent *)ptr, "ns1:resCreateContent");
	case SOAP_TYPE__wsse__Security:
		return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, NULL);
	case SOAP_TYPE__xenc__ReferenceList:
		return soap_out__xenc__ReferenceList(soap, "xenc:ReferenceList", id, (const struct _xenc__ReferenceList *)ptr, NULL);
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return soap_out_xenc__EncryptionPropertyType(soap, tag, id, (const struct xenc__EncryptionPropertyType *)ptr, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, (const struct xenc__EncryptionPropertiesType *)ptr, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_xenc__ReferenceType:
		return soap_out_xenc__ReferenceType(soap, tag, id, (const struct xenc__ReferenceType *)ptr, "xenc:ReferenceType");
	case SOAP_TYPE_xenc__AgreementMethodType:
		return soap_out_xenc__AgreementMethodType(soap, tag, id, (const struct xenc__AgreementMethodType *)ptr, "xenc:AgreementMethodType");
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return soap_out_xenc__EncryptedKeyType(soap, tag, id, (const struct xenc__EncryptedKeyType *)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE_xenc__EncryptedDataType:
		return soap_out_xenc__EncryptedDataType(soap, tag, id, (const struct xenc__EncryptedDataType *)ptr, "xenc:EncryptedDataType");
	case SOAP_TYPE_xenc__TransformsType:
		return soap_out_xenc__TransformsType(soap, tag, id, (const struct xenc__TransformsType *)ptr, "xenc:TransformsType");
	case SOAP_TYPE_xenc__CipherReferenceType:
		return soap_out_xenc__CipherReferenceType(soap, tag, id, (const struct xenc__CipherReferenceType *)ptr, "xenc:CipherReferenceType");
	case SOAP_TYPE_xenc__CipherDataType:
		return soap_out_xenc__CipherDataType(soap, tag, id, (const struct xenc__CipherDataType *)ptr, "xenc:CipherDataType");
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return soap_out_xenc__EncryptionMethodType(soap, tag, id, (const struct xenc__EncryptionMethodType *)ptr, "xenc:EncryptionMethodType");
	case SOAP_TYPE_xenc__EncryptedType:
		return soap_out_xenc__EncryptedType(soap, tag, id, (const struct xenc__EncryptedType *)ptr, "xenc:EncryptedType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE__ds__KeyInfo:
		return soap_out__ds__KeyInfo(soap, "ds:KeyInfo", id, (const struct ds__KeyInfoType *)ptr, NULL);
	case SOAP_TYPE_ds__X509DataType:
		return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
	case SOAP_TYPE__ds__Transform:
		return soap_out__ds__Transform(soap, "ds:Transform", id, (const struct ds__TransformType *)ptr, NULL);
	case SOAP_TYPE_ds__TransformType:
		return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, NULL);
	case SOAP_TYPE_ds__TransformsType:
		return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE__ds__Signature:
		return soap_out__ds__Signature(soap, "ds:Signature", id, (const struct ds__SignatureType *)ptr, NULL);
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, NULL);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, NULL);
	case SOAP_TYPE__wsse__Embedded:
		return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, NULL);
	case SOAP_TYPE__wsse__Reference:
		return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, NULL);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, NULL);
	case SOAP_TYPE__wsse__Password:
		return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, NULL);
	case SOAP_TYPE__wsse__UsernameToken:
		return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, NULL);
	case SOAP_TYPE__wsu__Timestamp:
		return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, NULL);
	case SOAP_TYPE__wsa5__ProblemAction:
		return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, NULL);
	case SOAP_TYPE__wsa5__FaultTo:
		return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa5__From:
		return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa5__ReplyTo:
		return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa5__RelatesTo:
		return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, NULL);
	case SOAP_TYPE__wsa5__Metadata:
		return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, NULL);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, NULL);
	case SOAP_TYPE__wsa5__EndpointReference:
		return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_ns4__Notify:
		return soap_out_PointerTo_ns4__Notify(soap, tag, id, (struct _ns4__Notify *const*)ptr, "ns4:Notify");
	case SOAP_TYPE_PointerTo_ns1__forward:
		return soap_out_PointerTo_ns1__forward(soap, tag, id, (struct _ns1__forward *const*)ptr, "ns1:forward");
	case SOAP_TYPE_PointerTons1__getTopologyResponseContent:
		return soap_out_PointerTons1__getTopologyResponseContent(soap, tag, id, (struct ns1__getTopologyResponseContent *const*)ptr, "ns1:getTopologyResponseContent");
	case SOAP_TYPE_PointerTons1__getTopologyContent:
		return soap_out_PointerTons1__getTopologyContent(soap, tag, id, (struct ns1__getTopologyContent *const*)ptr, "ns1:getTopologyContent");
	case SOAP_TYPE_PointerTo_ns1__BSSFault:
		return soap_out_PointerTo_ns1__BSSFault(soap, tag, id, (struct _ns1__BSSFault *const*)ptr, "ns1:BSSFault");
	case SOAP_TYPE_PointerTo_ns1__AAAFault:
		return soap_out_PointerTo_ns1__AAAFault(soap, tag, id, (struct _ns1__AAAFault *const*)ptr, "ns1:AAAFault");
	case SOAP_TYPE_PointerTo_QName:
		return soap_out_PointerTo_QName(soap, tag, id, (char **const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTons6__FaultCauseType:
		return soap_out_PointerTons6__FaultCauseType(soap, tag, id, (struct ns6__FaultCauseType *const*)ptr, "ns6:FaultCauseType");
	case SOAP_TYPE_PointerTons6__ErrorCodeType:
		return soap_out_PointerTons6__ErrorCodeType(soap, tag, id, (struct ns6__ErrorCodeType *const*)ptr, "ns6:ErrorCodeType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_out_PointerTounsignedInt(soap, tag, id, (unsigned int *const*)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTo_ns4__Subscribe_SubscriptionPolicy:
		return soap_out_PointerTo_ns4__Subscribe_SubscriptionPolicy(soap, tag, id, (struct _ns4__Subscribe_SubscriptionPolicy *const*)ptr, "ns4:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerToPointerTons4__NotificationMessageHolderType:
		return soap_out_PointerToPointerTons4__NotificationMessageHolderType(soap, tag, id, (struct ns4__NotificationMessageHolderType **const*)ptr, "ns4:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTons4__NotificationMessageHolderType:
		return soap_out_PointerTons4__NotificationMessageHolderType(soap, tag, id, (struct ns4__NotificationMessageHolderType *const*)ptr, "ns4:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons4__SubscriptionPolicyType:
		return soap_out_PointerTons4__SubscriptionPolicyType(soap, tag, id, (struct ns4__SubscriptionPolicyType *const*)ptr, "ns4:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTons4__FilterType:
		return soap_out_PointerTons4__FilterType(soap, tag, id, (struct ns4__FilterType *const*)ptr, "ns4:FilterType");
	case SOAP_TYPE_PointerTons4__MessageType:
		return soap_out_PointerTons4__MessageType(soap, tag, id, (struct ns4__MessageType *const*)ptr, "ns4:MessageType");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_out_PointerTowsa5__EndpointReferenceType(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerToPointerTons4__QueryExpressionType:
		return soap_out_PointerToPointerTons4__QueryExpressionType(soap, tag, id, (struct ns4__QueryExpressionType **const*)ptr, "ns4:QueryExpressionType");
	case SOAP_TYPE_PointerTons4__QueryExpressionType:
		return soap_out_PointerTons4__QueryExpressionType(soap, tag, id, (struct ns4__QueryExpressionType *const*)ptr, "ns4:QueryExpressionType");
	case SOAP_TYPE_PointerToPointerTons4__TopicExpressionType:
		return soap_out_PointerToPointerTons4__TopicExpressionType(soap, tag, id, (struct ns4__TopicExpressionType **const*)ptr, "ns4:TopicExpressionType");
	case SOAP_TYPE_PointerTons4__TopicExpressionType:
		return soap_out_PointerTons4__TopicExpressionType(soap, tag, id, (struct ns4__TopicExpressionType *const*)ptr, "ns4:TopicExpressionType");
	case SOAP_TYPE_PointerToxsd__boolean_:
		return soap_out_PointerToxsd__boolean_(soap, tag, id, (enum xsd__boolean_ *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo:
		return soap_out_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag, id, (struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *const*)ptr, "ns3:CtrlPlaneSwitchingCapabilitySpecificInfo");
	case SOAP_TYPE_PointerTons3__Duration:
		return soap_out_PointerTons3__Duration(soap, tag, id, (struct ns3__Duration *const*)ptr, "ns3:Duration");
	case SOAP_TYPE_PointerTons3__TimeContent:
		return soap_out_PointerTons3__TimeContent(soap, tag, id, (struct ns3__TimeContent *const*)ptr, "ns3:TimeContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneNextHopContent:
		return soap_out_PointerToPointerTons3__CtrlPlaneNextHopContent(soap, tag, id, (struct ns3__CtrlPlaneNextHopContent **const*)ptr, "ns3:CtrlPlaneNextHopContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneNextHopContent:
		return soap_out_PointerTons3__CtrlPlaneNextHopContent(soap, tag, id, (struct ns3__CtrlPlaneNextHopContent *const*)ptr, "ns3:CtrlPlaneNextHopContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneHopContent:
		return soap_out_PointerToPointerTons3__CtrlPlaneHopContent(soap, tag, id, (struct ns3__CtrlPlaneHopContent **const*)ptr, "ns3:CtrlPlaneHopContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneHopContent:
		return soap_out_PointerTons3__CtrlPlaneHopContent(soap, tag, id, (struct ns3__CtrlPlaneHopContent *const*)ptr, "ns3:CtrlPlaneHopContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneSwcapContent:
		return soap_out_PointerTons3__CtrlPlaneSwcapContent(soap, tag, id, (struct ns3__CtrlPlaneSwcapContent *const*)ptr, "ns3:CtrlPlaneSwcapContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneAdministrativeGroup:
		return soap_out_PointerToPointerTons3__CtrlPlaneAdministrativeGroup(soap, tag, id, (struct ns3__CtrlPlaneAdministrativeGroup **const*)ptr, "ns3:CtrlPlaneAdministrativeGroup");
	case SOAP_TYPE_PointerTons3__CtrlPlaneAdministrativeGroup:
		return soap_out_PointerTons3__CtrlPlaneAdministrativeGroup(soap, tag, id, (struct ns3__CtrlPlaneAdministrativeGroup *const*)ptr, "ns3:CtrlPlaneAdministrativeGroup");
	case SOAP_TYPE_PointerTons3__CtrlPlaneAddressContent:
		return soap_out_PointerTons3__CtrlPlaneAddressContent(soap, tag, id, (struct ns3__CtrlPlaneAddressContent *const*)ptr, "ns3:CtrlPlaneAddressContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneLinkContent:
		return soap_out_PointerToPointerTons3__CtrlPlaneLinkContent(soap, tag, id, (struct ns3__CtrlPlaneLinkContent **const*)ptr, "ns3:CtrlPlaneLinkContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneLinkContent:
		return soap_out_PointerTons3__CtrlPlaneLinkContent(soap, tag, id, (struct ns3__CtrlPlaneLinkContent *const*)ptr, "ns3:CtrlPlaneLinkContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlanePortContent:
		return soap_out_PointerToPointerTons3__CtrlPlanePortContent(soap, tag, id, (struct ns3__CtrlPlanePortContent **const*)ptr, "ns3:CtrlPlanePortContent");
	case SOAP_TYPE_PointerTons3__CtrlPlanePortContent:
		return soap_out_PointerTons3__CtrlPlanePortContent(soap, tag, id, (struct ns3__CtrlPlanePortContent *const*)ptr, "ns3:CtrlPlanePortContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneNodeContent:
		return soap_out_PointerToPointerTons3__CtrlPlaneNodeContent(soap, tag, id, (struct ns3__CtrlPlaneNodeContent **const*)ptr, "ns3:CtrlPlaneNodeContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneNodeContent:
		return soap_out_PointerTons3__CtrlPlaneNodeContent(soap, tag, id, (struct ns3__CtrlPlaneNodeContent *const*)ptr, "ns3:CtrlPlaneNodeContent");
	case SOAP_TYPE_PointerTons3__Lifetime:
		return soap_out_PointerTons3__Lifetime(soap, tag, id, (struct ns3__Lifetime *const*)ptr, "ns3:Lifetime");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneDomainSignatureContent:
		return soap_out_PointerToPointerTons3__CtrlPlaneDomainSignatureContent(soap, tag, id, (struct ns3__CtrlPlaneDomainSignatureContent **const*)ptr, "ns3:CtrlPlaneDomainSignatureContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneDomainSignatureContent:
		return soap_out_PointerTons3__CtrlPlaneDomainSignatureContent(soap, tag, id, (struct ns3__CtrlPlaneDomainSignatureContent *const*)ptr, "ns3:CtrlPlaneDomainSignatureContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneDomainContent:
		return soap_out_PointerToPointerTons3__CtrlPlaneDomainContent(soap, tag, id, (struct ns3__CtrlPlaneDomainContent **const*)ptr, "ns3:CtrlPlaneDomainContent");
	case SOAP_TYPE_PointerTons3__CtrlPlaneDomainContent:
		return soap_out_PointerTons3__CtrlPlaneDomainContent(soap, tag, id, (struct ns3__CtrlPlaneDomainContent *const*)ptr, "ns3:CtrlPlaneDomainContent");
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlanePathContent:
		return soap_out_PointerToPointerTons3__CtrlPlanePathContent(soap, tag, id, (struct ns3__CtrlPlanePathContent **const*)ptr, "ns3:CtrlPlanePathContent");
	case SOAP_TYPE_PointerTons1__forwardReply:
		return soap_out_PointerTons1__forwardReply(soap, tag, id, (struct ns1__forwardReply *const*)ptr, "ns1:forwardReply");
	case SOAP_TYPE_PointerTons1__forwardPayload:
		return soap_out_PointerTons1__forwardPayload(soap, tag, id, (struct ns1__forwardPayload *const*)ptr, "ns1:forwardPayload");
	case SOAP_TYPE_PointerTons1__localDetails:
		return soap_out_PointerTons1__localDetails(soap, tag, id, (struct ns1__localDetails *const*)ptr, "ns1:localDetails");
	case SOAP_TYPE_PointerTons1__msgDetails:
		return soap_out_PointerTons1__msgDetails(soap, tag, id, (struct ns1__msgDetails *const*)ptr, "ns1:msgDetails");
	case SOAP_TYPE_PointerTons1__mplsInfo:
		return soap_out_PointerTons1__mplsInfo(soap, tag, id, (struct ns1__mplsInfo *const*)ptr, "ns1:mplsInfo");
	case SOAP_TYPE_PointerTons1__layer3Info:
		return soap_out_PointerTons1__layer3Info(soap, tag, id, (struct ns1__layer3Info *const*)ptr, "ns1:layer3Info");
	case SOAP_TYPE_PointerTons1__layer2Info:
		return soap_out_PointerTons1__layer2Info(soap, tag, id, (struct ns1__layer2Info *const*)ptr, "ns1:layer2Info");
	case SOAP_TYPE_PointerTons3__CtrlPlanePathContent:
		return soap_out_PointerTons3__CtrlPlanePathContent(soap, tag, id, (struct ns3__CtrlPlanePathContent *const*)ptr, "ns3:CtrlPlanePathContent");
	case SOAP_TYPE_PointerTons1__teardownPathResponseContent:
		return soap_out_PointerTons1__teardownPathResponseContent(soap, tag, id, (struct ns1__teardownPathResponseContent *const*)ptr, "ns1:teardownPathResponseContent");
	case SOAP_TYPE_PointerTons1__refreshPathResponseContent:
		return soap_out_PointerTons1__refreshPathResponseContent(soap, tag, id, (struct ns1__refreshPathResponseContent *const*)ptr, "ns1:refreshPathResponseContent");
	case SOAP_TYPE_PointerTons1__createPathResponseContent:
		return soap_out_PointerTons1__createPathResponseContent(soap, tag, id, (struct ns1__createPathResponseContent *const*)ptr, "ns1:createPathResponseContent");
	case SOAP_TYPE_PointerTons1__listReply:
		return soap_out_PointerTons1__listReply(soap, tag, id, (struct ns1__listReply *const*)ptr, "ns1:listReply");
	case SOAP_TYPE_PointerTons1__modifyResReply:
		return soap_out_PointerTons1__modifyResReply(soap, tag, id, (struct ns1__modifyResReply *const*)ptr, "ns1:modifyResReply");
	case SOAP_TYPE_PointerTons1__createReply:
		return soap_out_PointerTons1__createReply(soap, tag, id, (struct ns1__createReply *const*)ptr, "ns1:createReply");
	case SOAP_TYPE_PointerTons1__teardownPathContent:
		return soap_out_PointerTons1__teardownPathContent(soap, tag, id, (struct ns1__teardownPathContent *const*)ptr, "ns1:teardownPathContent");
	case SOAP_TYPE_PointerTons1__refreshPathContent:
		return soap_out_PointerTons1__refreshPathContent(soap, tag, id, (struct ns1__refreshPathContent *const*)ptr, "ns1:refreshPathContent");
	case SOAP_TYPE_PointerTons1__createPathContent:
		return soap_out_PointerTons1__createPathContent(soap, tag, id, (struct ns1__createPathContent *const*)ptr, "ns1:createPathContent");
	case SOAP_TYPE_PointerTons1__listRequest:
		return soap_out_PointerTons1__listRequest(soap, tag, id, (struct ns1__listRequest *const*)ptr, "ns1:listRequest");
	case SOAP_TYPE_PointerTons1__globalReservationId:
		return soap_out_PointerTons1__globalReservationId(soap, tag, id, (struct ns1__globalReservationId *const*)ptr, "ns1:globalReservationId");
	case SOAP_TYPE_PointerTons1__modifyResContent:
		return soap_out_PointerTons1__modifyResContent(soap, tag, id, (struct ns1__modifyResContent *const*)ptr, "ns1:modifyResContent");
	case SOAP_TYPE_PointerTons1__resCreateContent:
		return soap_out_PointerTons1__resCreateContent(soap, tag, id, (struct ns1__resCreateContent *const*)ptr, "ns1:resCreateContent");
	case SOAP_TYPE_PointerToPointerTons1__resDetails:
		return soap_out_PointerToPointerTons1__resDetails(soap, tag, id, (struct ns1__resDetails **const*)ptr, "ns1:resDetails");
	case SOAP_TYPE_PointerToPointerTons1__vlanTag:
		return soap_out_PointerToPointerTons1__vlanTag(soap, tag, id, (struct ns1__vlanTag **const*)ptr, "ns1:vlanTag");
	case SOAP_TYPE_PointerTons1__vlanTag:
		return soap_out_PointerTons1__vlanTag(soap, tag, id, (struct ns1__vlanTag *const*)ptr, "ns1:vlanTag");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons3__CtrlPlaneTopologyContent:
		return soap_out_PointerTons3__CtrlPlaneTopologyContent(soap, tag, id, (struct ns3__CtrlPlaneTopologyContent *const*)ptr, "ns3:CtrlPlaneTopologyContent");
	case SOAP_TYPE_PointerTons1__resDetails:
		return soap_out_PointerTons1__resDetails(soap, tag, id, (struct ns1__resDetails *const*)ptr, "ns1:resDetails");
	case SOAP_TYPE_PointerTons1__pathInfo:
		return soap_out_PointerTons1__pathInfo(soap, tag, id, (struct ns1__pathInfo *const*)ptr, "ns1:pathInfo");
	case SOAP_TYPE_ns4__AbsoluteOrRelativeTimeType:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns4:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		return soap_out_PointerToxenc__EncryptedKeyType(soap, tag, id, (struct xenc__EncryptedKeyType *const*)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		return soap_out_PointerTo_xenc__ReferenceList(soap, tag, id, (struct _xenc__ReferenceList *const*)ptr, "xenc:ReferenceList");
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		return soap_out_PointerToxenc__ReferenceType(soap, tag, id, (struct xenc__ReferenceType *const*)ptr, "xenc:ReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		return soap_out_PointerToxenc__EncryptionPropertyType(soap, tag, id, (struct xenc__EncryptionPropertyType *const*)ptr, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_PointerToxenc__TransformsType:
		return soap_out_PointerToxenc__TransformsType(soap, tag, id, (struct xenc__TransformsType *const*)ptr, "xenc:TransformsType");
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		return soap_out_PointerToxenc__CipherReferenceType(soap, tag, id, (struct xenc__CipherReferenceType *const*)ptr, "xenc:CipherReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		return soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag, id, (struct xenc__EncryptionPropertiesType *const*)ptr, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		return soap_out_PointerToxenc__CipherDataType(soap, tag, id, (struct xenc__CipherDataType *const*)ptr, "xenc:CipherDataType");
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		return soap_out_PointerTo_ds__KeyInfo(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfo");
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		return soap_out_PointerToxenc__EncryptionMethodType(soap, tag, id, (struct xenc__EncryptionMethodType *const*)ptr, "xenc:EncryptionMethodType");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemIRI:
		return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE__wsa5__Action:
		return soap_out_string(soap, "wsa5:Action", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa5__To:
		return soap_out_string(soap, "wsa5:To", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa5__MessageID:
		return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa5:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa5:RelationshipTypeOpenEnum");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns1__Notify:
		soap_serialize___ns1__Notify(soap, (const struct __ns1__Notify *)ptr);
		break;
	case SOAP_TYPE___ns1__forward:
		soap_serialize___ns1__forward(soap, (const struct __ns1__forward *)ptr);
		break;
	case SOAP_TYPE___ns1__teardownPath:
		soap_serialize___ns1__teardownPath(soap, (const struct __ns1__teardownPath *)ptr);
		break;
	case SOAP_TYPE___ns1__refreshPath:
		soap_serialize___ns1__refreshPath(soap, (const struct __ns1__refreshPath *)ptr);
		break;
	case SOAP_TYPE___ns1__createPath:
		soap_serialize___ns1__createPath(soap, (const struct __ns1__createPath *)ptr);
		break;
	case SOAP_TYPE___ns1__getNetworkTopology:
		soap_serialize___ns1__getNetworkTopology(soap, (const struct __ns1__getNetworkTopology *)ptr);
		break;
	case SOAP_TYPE___ns1__modifyReservation:
		soap_serialize___ns1__modifyReservation(soap, (const struct __ns1__modifyReservation *)ptr);
		break;
	case SOAP_TYPE___ns1__cancelReservation:
		soap_serialize___ns1__cancelReservation(soap, (const struct __ns1__cancelReservation *)ptr);
		break;
	case SOAP_TYPE___ns1__cancelReservationResponse:
		soap_serialize___ns1__cancelReservationResponse(soap, (const struct __ns1__cancelReservationResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__listReservations:
		soap_serialize___ns1__listReservations(soap, (const struct __ns1__listReservations *)ptr);
		break;
	case SOAP_TYPE___ns1__queryReservation:
		soap_serialize___ns1__queryReservation(soap, (const struct __ns1__queryReservation *)ptr);
		break;
	case SOAP_TYPE___ns1__createReservation:
		soap_serialize___ns1__createReservation(soap, (const struct __ns1__createReservation *)ptr);
		break;
	case SOAP_TYPE_ns5__ResourceUnavailableFaultType:
		soap_serialize_ns5__ResourceUnavailableFaultType(soap, (const struct ns5__ResourceUnavailableFaultType *)ptr);
		break;
	case SOAP_TYPE_ns5__ResourceUnknownFaultType:
		soap_serialize_ns5__ResourceUnknownFaultType(soap, (const struct ns5__ResourceUnknownFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__ResumeFailedFaultType:
		soap_serialize_ns4__ResumeFailedFaultType(soap, (const struct ns4__ResumeFailedFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__PauseFailedFaultType:
		soap_serialize_ns4__PauseFailedFaultType(soap, (const struct ns4__PauseFailedFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__UnableToDestroySubscriptionFaultType:
		soap_serialize_ns4__UnableToDestroySubscriptionFaultType(soap, (const struct ns4__UnableToDestroySubscriptionFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__UnacceptableTerminationTimeFaultType:
		soap_serialize_ns4__UnacceptableTerminationTimeFaultType(soap, (const struct ns4__UnacceptableTerminationTimeFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__UnableToCreatePullPointFaultType:
		soap_serialize_ns4__UnableToCreatePullPointFaultType(soap, (const struct ns4__UnableToCreatePullPointFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__UnableToDestroyPullPointFaultType:
		soap_serialize_ns4__UnableToDestroyPullPointFaultType(soap, (const struct ns4__UnableToDestroyPullPointFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__UnableToGetMessagesFaultType:
		soap_serialize_ns4__UnableToGetMessagesFaultType(soap, (const struct ns4__UnableToGetMessagesFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__NoCurrentMessageOnTopicFaultType:
		soap_serialize_ns4__NoCurrentMessageOnTopicFaultType(soap, (const struct ns4__NoCurrentMessageOnTopicFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__UnacceptableInitialTerminationTimeFaultType:
		soap_serialize_ns4__UnacceptableInitialTerminationTimeFaultType(soap, (const struct ns4__UnacceptableInitialTerminationTimeFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__NotifyMessageNotSupportedFaultType:
		soap_serialize_ns4__NotifyMessageNotSupportedFaultType(soap, (const struct ns4__NotifyMessageNotSupportedFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__UnsupportedPolicyRequestFaultType:
		soap_serialize_ns4__UnsupportedPolicyRequestFaultType(soap, (const struct ns4__UnsupportedPolicyRequestFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__UnrecognizedPolicyRequestFaultType:
		soap_serialize_ns4__UnrecognizedPolicyRequestFaultType(soap, (const struct ns4__UnrecognizedPolicyRequestFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__InvalidMessageContentExpressionFaultType:
		soap_serialize_ns4__InvalidMessageContentExpressionFaultType(soap, (const struct ns4__InvalidMessageContentExpressionFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__InvalidProducerPropertiesExpressionFaultType:
		soap_serialize_ns4__InvalidProducerPropertiesExpressionFaultType(soap, (const struct ns4__InvalidProducerPropertiesExpressionFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__MultipleTopicsSpecifiedFaultType:
		soap_serialize_ns4__MultipleTopicsSpecifiedFaultType(soap, (const struct ns4__MultipleTopicsSpecifiedFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__TopicNotSupportedFaultType:
		soap_serialize_ns4__TopicNotSupportedFaultType(soap, (const struct ns4__TopicNotSupportedFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__InvalidTopicExpressionFaultType:
		soap_serialize_ns4__InvalidTopicExpressionFaultType(soap, (const struct ns4__InvalidTopicExpressionFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__TopicExpressionDialectUnknownFaultType:
		soap_serialize_ns4__TopicExpressionDialectUnknownFaultType(soap, (const struct ns4__TopicExpressionDialectUnknownFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__InvalidFilterFaultType:
		soap_serialize_ns4__InvalidFilterFaultType(soap, (const struct ns4__InvalidFilterFaultType *)ptr);
		break;
	case SOAP_TYPE_ns4__SubscribeCreationFailedFaultType:
		soap_serialize_ns4__SubscribeCreationFailedFaultType(soap, (const struct ns4__SubscribeCreationFailedFaultType *)ptr);
		break;
	case SOAP_TYPE___ns1__reservationResourceType_sequence:
		soap_serialize___ns1__reservationResourceType_sequence(soap, (const struct __ns1__reservationResourceType_sequence *)ptr);
		break;
	case SOAP_TYPE_ns1__reservationResourceType:
		soap_serialize_ns1__reservationResourceType(soap, (const struct ns1__reservationResourceType *)ptr);
		break;
	case SOAP_TYPE_ns6__FaultCauseType:
		soap_serialize_ns6__FaultCauseType(soap, (const struct ns6__FaultCauseType *)ptr);
		break;
	case SOAP_TYPE_ns6__ErrorCodeType:
		soap_serialize_ns6__ErrorCodeType(soap, (const struct ns6__ErrorCodeType *)ptr);
		break;
	case SOAP_TYPE_ns6__BaseFaultType:
		soap_serialize_ns6__BaseFaultType(soap, (const struct ns6__BaseFaultType *)ptr);
		break;
	case SOAP_TYPE__ns4__ResumeSubscriptionResponse:
		soap_serialize__ns4__ResumeSubscriptionResponse(soap, (const struct _ns4__ResumeSubscriptionResponse *)ptr);
		break;
	case SOAP_TYPE__ns4__ResumeSubscription:
		soap_serialize__ns4__ResumeSubscription(soap, (const struct _ns4__ResumeSubscription *)ptr);
		break;
	case SOAP_TYPE__ns4__PauseSubscriptionResponse:
		soap_serialize__ns4__PauseSubscriptionResponse(soap, (const struct _ns4__PauseSubscriptionResponse *)ptr);
		break;
	case SOAP_TYPE__ns4__PauseSubscription:
		soap_serialize__ns4__PauseSubscription(soap, (const struct _ns4__PauseSubscription *)ptr);
		break;
	case SOAP_TYPE__ns4__UnsubscribeResponse:
		soap_serialize__ns4__UnsubscribeResponse(soap, (const struct _ns4__UnsubscribeResponse *)ptr);
		break;
	case SOAP_TYPE__ns4__Unsubscribe:
		soap_serialize__ns4__Unsubscribe(soap, (const struct _ns4__Unsubscribe *)ptr);
		break;
	case SOAP_TYPE__ns4__RenewResponse:
		soap_serialize__ns4__RenewResponse(soap, (const struct _ns4__RenewResponse *)ptr);
		break;
	case SOAP_TYPE__ns4__Renew:
		soap_serialize__ns4__Renew(soap, (const struct _ns4__Renew *)ptr);
		break;
	case SOAP_TYPE__ns4__CreatePullPointResponse:
		soap_serialize__ns4__CreatePullPointResponse(soap, (const struct _ns4__CreatePullPointResponse *)ptr);
		break;
	case SOAP_TYPE__ns4__CreatePullPoint:
		soap_serialize__ns4__CreatePullPoint(soap, (const struct _ns4__CreatePullPoint *)ptr);
		break;
	case SOAP_TYPE__ns4__DestroyPullPointResponse:
		soap_serialize__ns4__DestroyPullPointResponse(soap, (const struct _ns4__DestroyPullPointResponse *)ptr);
		break;
	case SOAP_TYPE__ns4__DestroyPullPoint:
		soap_serialize__ns4__DestroyPullPoint(soap, (const struct _ns4__DestroyPullPoint *)ptr);
		break;
	case SOAP_TYPE__ns4__GetMessagesResponse:
		soap_serialize__ns4__GetMessagesResponse(soap, (const struct _ns4__GetMessagesResponse *)ptr);
		break;
	case SOAP_TYPE__ns4__GetMessages:
		soap_serialize__ns4__GetMessages(soap, (const struct _ns4__GetMessages *)ptr);
		break;
	case SOAP_TYPE__ns4__GetCurrentMessageResponse:
		soap_serialize__ns4__GetCurrentMessageResponse(soap, (const struct _ns4__GetCurrentMessageResponse *)ptr);
		break;
	case SOAP_TYPE__ns4__GetCurrentMessage:
		soap_serialize__ns4__GetCurrentMessage(soap, (const struct _ns4__GetCurrentMessage *)ptr);
		break;
	case SOAP_TYPE__ns4__SubscribeResponse:
		soap_serialize__ns4__SubscribeResponse(soap, (const struct _ns4__SubscribeResponse *)ptr);
		break;
	case SOAP_TYPE__ns4__Subscribe_SubscriptionPolicy:
		soap_serialize__ns4__Subscribe_SubscriptionPolicy(soap, (const struct _ns4__Subscribe_SubscriptionPolicy *)ptr);
		break;
	case SOAP_TYPE__ns4__Subscribe:
		soap_serialize__ns4__Subscribe(soap, (const struct _ns4__Subscribe *)ptr);
		break;
	case SOAP_TYPE__ns4__UseRaw:
		soap_serialize__ns4__UseRaw(soap, (const struct _ns4__UseRaw *)ptr);
		break;
	case SOAP_TYPE__ns4__Notify:
		soap_serialize__ns4__Notify(soap, (const struct _ns4__Notify *)ptr);
		break;
	case SOAP_TYPE__ns4__SubscriptionManagerRP:
		soap_serialize__ns4__SubscriptionManagerRP(soap, (const struct _ns4__SubscriptionManagerRP *)ptr);
		break;
	case SOAP_TYPE_ns4__MessageType:
		soap_serialize_ns4__MessageType(soap, (const struct ns4__MessageType *)ptr);
		break;
	case SOAP_TYPE_ns4__NotificationMessageHolderType:
		soap_serialize_ns4__NotificationMessageHolderType(soap, (const struct ns4__NotificationMessageHolderType *)ptr);
		break;
	case SOAP_TYPE_ns4__SubscriptionPolicyType:
		soap_serialize_ns4__SubscriptionPolicyType(soap, (const struct ns4__SubscriptionPolicyType *)ptr);
		break;
	case SOAP_TYPE_ns4__QueryExpressionType:
		soap_serialize_ns4__QueryExpressionType(soap, (const struct ns4__QueryExpressionType *)ptr);
		break;
	case SOAP_TYPE_ns4__TopicExpressionType:
		soap_serialize_ns4__TopicExpressionType(soap, (const struct ns4__TopicExpressionType *)ptr);
		break;
	case SOAP_TYPE_ns4__FilterType:
		soap_serialize_ns4__FilterType(soap, (const struct ns4__FilterType *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo:
		soap_serialize_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, (const struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *)ptr);
		break;
	case SOAP_TYPE_ns3__Duration:
		soap_serialize_ns3__Duration(soap, (const struct ns3__Duration *)ptr);
		break;
	case SOAP_TYPE_ns3__TimeContent:
		soap_serialize_ns3__TimeContent(soap, (const struct ns3__TimeContent *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlaneNextHopContent:
		soap_serialize_ns3__CtrlPlaneNextHopContent(soap, (const struct ns3__CtrlPlaneNextHopContent *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlaneHopContent:
		soap_serialize_ns3__CtrlPlaneHopContent(soap, (const struct ns3__CtrlPlaneHopContent *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlaneSwcapContent:
		soap_serialize_ns3__CtrlPlaneSwcapContent(soap, (const struct ns3__CtrlPlaneSwcapContent *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlaneAdministrativeGroup:
		soap_serialize_ns3__CtrlPlaneAdministrativeGroup(soap, (const struct ns3__CtrlPlaneAdministrativeGroup *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlaneAddressContent:
		soap_serialize_ns3__CtrlPlaneAddressContent(soap, (const struct ns3__CtrlPlaneAddressContent *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlaneLinkContent:
		soap_serialize_ns3__CtrlPlaneLinkContent(soap, (const struct ns3__CtrlPlaneLinkContent *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlanePortContent:
		soap_serialize_ns3__CtrlPlanePortContent(soap, (const struct ns3__CtrlPlanePortContent *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlaneNodeContent:
		soap_serialize_ns3__CtrlPlaneNodeContent(soap, (const struct ns3__CtrlPlaneNodeContent *)ptr);
		break;
	case SOAP_TYPE_ns3__Lifetime:
		soap_serialize_ns3__Lifetime(soap, (const struct ns3__Lifetime *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlaneDomainSignatureContent:
		soap_serialize_ns3__CtrlPlaneDomainSignatureContent(soap, (const struct ns3__CtrlPlaneDomainSignatureContent *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlaneDomainContent:
		soap_serialize_ns3__CtrlPlaneDomainContent(soap, (const struct ns3__CtrlPlaneDomainContent *)ptr);
		break;
	case SOAP_TYPE__ns1__SignalFault:
		soap_serialize__ns1__SignalFault(soap, (const struct _ns1__SignalFault *)ptr);
		break;
	case SOAP_TYPE__ns1__TopologyFault:
		soap_serialize__ns1__TopologyFault(soap, (const struct _ns1__TopologyFault *)ptr);
		break;
	case SOAP_TYPE__ns1__BSSFault:
		soap_serialize__ns1__BSSFault(soap, (const struct _ns1__BSSFault *)ptr);
		break;
	case SOAP_TYPE__ns1__AAAFault:
		soap_serialize__ns1__AAAFault(soap, (const struct _ns1__AAAFault *)ptr);
		break;
	case SOAP_TYPE__ns1__forward:
		soap_serialize__ns1__forward(soap, (const struct _ns1__forward *)ptr);
		break;
	case SOAP_TYPE_ns1__localDetails:
		soap_serialize_ns1__localDetails(soap, (const struct ns1__localDetails *)ptr);
		break;
	case SOAP_TYPE_ns1__msgDetails:
		soap_serialize_ns1__msgDetails(soap, (const struct ns1__msgDetails *)ptr);
		break;
	case SOAP_TYPE_ns1__eventContent:
		soap_serialize_ns1__eventContent(soap, (const struct ns1__eventContent *)ptr);
		break;
	case SOAP_TYPE_ns1__mplsInfo:
		soap_serialize_ns1__mplsInfo(soap, (const struct ns1__mplsInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__layer3Info:
		soap_serialize_ns1__layer3Info(soap, (const struct ns1__layer3Info *)ptr);
		break;
	case SOAP_TYPE_ns1__layer2Info:
		soap_serialize_ns1__layer2Info(soap, (const struct ns1__layer2Info *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlanePathContent:
		soap_serialize_ns3__CtrlPlanePathContent(soap, (const struct ns3__CtrlPlanePathContent *)ptr);
		break;
	case SOAP_TYPE_ns1__forwardReply:
		soap_serialize_ns1__forwardReply(soap, (const struct ns1__forwardReply *)ptr);
		break;
	case SOAP_TYPE_ns1__globalReservationId:
		soap_serialize_ns1__globalReservationId(soap, (const struct ns1__globalReservationId *)ptr);
		break;
	case SOAP_TYPE_ns1__forwardPayload:
		soap_serialize_ns1__forwardPayload(soap, (const struct ns1__forwardPayload *)ptr);
		break;
	case SOAP_TYPE_ns1__listReply:
		soap_serialize_ns1__listReply(soap, (const struct ns1__listReply *)ptr);
		break;
	case SOAP_TYPE_ns1__vlanTag:
		soap_serialize_ns1__vlanTag(soap, (const struct ns1__vlanTag *)ptr);
		break;
	case SOAP_TYPE___ns1__listRequest_sequence:
		soap_serialize___ns1__listRequest_sequence(soap, (const struct __ns1__listRequest_sequence *)ptr);
		break;
	case SOAP_TYPE_ns1__listRequest:
		soap_serialize_ns1__listRequest(soap, (const struct ns1__listRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__teardownPathResponseContent:
		soap_serialize_ns1__teardownPathResponseContent(soap, (const struct ns1__teardownPathResponseContent *)ptr);
		break;
	case SOAP_TYPE_ns1__teardownPathContent:
		soap_serialize_ns1__teardownPathContent(soap, (const struct ns1__teardownPathContent *)ptr);
		break;
	case SOAP_TYPE_ns1__refreshPathResponseContent:
		soap_serialize_ns1__refreshPathResponseContent(soap, (const struct ns1__refreshPathResponseContent *)ptr);
		break;
	case SOAP_TYPE_ns1__refreshPathContent:
		soap_serialize_ns1__refreshPathContent(soap, (const struct ns1__refreshPathContent *)ptr);
		break;
	case SOAP_TYPE_ns1__createPathResponseContent:
		soap_serialize_ns1__createPathResponseContent(soap, (const struct ns1__createPathResponseContent *)ptr);
		break;
	case SOAP_TYPE_ns1__createPathContent:
		soap_serialize_ns1__createPathContent(soap, (const struct ns1__createPathContent *)ptr);
		break;
	case SOAP_TYPE_ns3__CtrlPlaneTopologyContent:
		soap_serialize_ns3__CtrlPlaneTopologyContent(soap, (const struct ns3__CtrlPlaneTopologyContent *)ptr);
		break;
	case SOAP_TYPE_ns1__getTopologyResponseContent:
		soap_serialize_ns1__getTopologyResponseContent(soap, (const struct ns1__getTopologyResponseContent *)ptr);
		break;
	case SOAP_TYPE_ns1__getTopologyContent:
		soap_serialize_ns1__getTopologyContent(soap, (const struct ns1__getTopologyContent *)ptr);
		break;
	case SOAP_TYPE_ns1__resDetails:
		soap_serialize_ns1__resDetails(soap, (const struct ns1__resDetails *)ptr);
		break;
	case SOAP_TYPE_ns1__modifyResReply:
		soap_serialize_ns1__modifyResReply(soap, (const struct ns1__modifyResReply *)ptr);
		break;
	case SOAP_TYPE_ns1__modifyResContent:
		soap_serialize_ns1__modifyResContent(soap, (const struct ns1__modifyResContent *)ptr);
		break;
	case SOAP_TYPE_ns1__createReply:
		soap_serialize_ns1__createReply(soap, (const struct ns1__createReply *)ptr);
		break;
	case SOAP_TYPE_ns1__pathInfo:
		soap_serialize_ns1__pathInfo(soap, (const struct ns1__pathInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__resCreateContent:
		soap_serialize_ns1__resCreateContent(soap, (const struct ns1__resCreateContent *)ptr);
		break;
	case SOAP_TYPE__wsse__Security:
		soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
		break;
	case SOAP_TYPE___xenc__union_ReferenceList:
		soap_serialize___xenc__union_ReferenceList(soap, (const struct __xenc__union_ReferenceList *)ptr);
		break;
	case SOAP_TYPE__xenc__ReferenceList:
		soap_serialize__xenc__ReferenceList(soap, (const struct _xenc__ReferenceList *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		soap_serialize_xenc__EncryptionPropertyType(soap, (const struct xenc__EncryptionPropertyType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		soap_serialize_xenc__EncryptionPropertiesType(soap, (const struct xenc__EncryptionPropertiesType *)ptr);
		break;
	case SOAP_TYPE_xenc__ReferenceType:
		soap_serialize_xenc__ReferenceType(soap, (const struct xenc__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_xenc__AgreementMethodType:
		soap_serialize_xenc__AgreementMethodType(soap, (const struct xenc__AgreementMethodType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedKeyType:
		soap_serialize_xenc__EncryptedKeyType(soap, (const struct xenc__EncryptedKeyType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedDataType:
		soap_serialize_xenc__EncryptedDataType(soap, (const struct xenc__EncryptedDataType *)ptr);
		break;
	case SOAP_TYPE_xenc__TransformsType:
		soap_serialize_xenc__TransformsType(soap, (const struct xenc__TransformsType *)ptr);
		break;
	case SOAP_TYPE_xenc__CipherReferenceType:
		soap_serialize_xenc__CipherReferenceType(soap, (const struct xenc__CipherReferenceType *)ptr);
		break;
	case SOAP_TYPE_xenc__CipherDataType:
		soap_serialize_xenc__CipherDataType(soap, (const struct xenc__CipherDataType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionMethodType:
		soap_serialize_xenc__EncryptionMethodType(soap, (const struct xenc__EncryptionMethodType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedType:
		soap_serialize_xenc__EncryptedType(soap, (const struct xenc__EncryptedType *)ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
		break;
	case SOAP_TYPE__ds__KeyInfo:
		soap_serialize__ds__KeyInfo(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
		break;
	case SOAP_TYPE__ds__Transform:
		soap_serialize__ds__Transform(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
		break;
	case SOAP_TYPE__ds__Signature:
		soap_serialize__ds__Signature(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__Notify:
		soap_serialize_PointerTo_ns4__Notify(soap, (struct _ns4__Notify *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__forward:
		soap_serialize_PointerTo_ns1__forward(soap, (struct _ns1__forward *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getTopologyResponseContent:
		soap_serialize_PointerTons1__getTopologyResponseContent(soap, (struct ns1__getTopologyResponseContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getTopologyContent:
		soap_serialize_PointerTons1__getTopologyContent(soap, (struct ns1__getTopologyContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BSSFault:
		soap_serialize_PointerTo_ns1__BSSFault(soap, (struct _ns1__BSSFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AAAFault:
		soap_serialize_PointerTo_ns1__AAAFault(soap, (struct _ns1__AAAFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_QName:
		soap_serialize_PointerTo_QName(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns1__reservationResourceType_sequence:
		soap_serialize_PointerTo__ns1__reservationResourceType_sequence(soap, (struct __ns1__reservationResourceType_sequence *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__FaultCauseType:
		soap_serialize_PointerTons6__FaultCauseType(soap, (struct ns6__FaultCauseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ErrorCodeType:
		soap_serialize_PointerTons6__ErrorCodeType(soap, (struct ns6__ErrorCodeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedInt:
		soap_serialize_PointerTounsignedInt(soap, (unsigned int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__Subscribe_SubscriptionPolicy:
		soap_serialize_PointerTo_ns4__Subscribe_SubscriptionPolicy(soap, (struct _ns4__Subscribe_SubscriptionPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__NotificationMessageHolderType:
		soap_serialize_PointerToPointerTons4__NotificationMessageHolderType(soap, (struct ns4__NotificationMessageHolderType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__NotificationMessageHolderType:
		soap_serialize_PointerTons4__NotificationMessageHolderType(soap, (struct ns4__NotificationMessageHolderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__SubscriptionPolicyType:
		soap_serialize_PointerTons4__SubscriptionPolicyType(soap, (struct ns4__SubscriptionPolicyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__FilterType:
		soap_serialize_PointerTons4__FilterType(soap, (struct ns4__FilterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__MessageType:
		soap_serialize_PointerTons4__MessageType(soap, (struct ns4__MessageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		soap_serialize_PointerTowsa5__EndpointReferenceType(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__QueryExpressionType:
		soap_serialize_PointerToPointerTons4__QueryExpressionType(soap, (struct ns4__QueryExpressionType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__QueryExpressionType:
		soap_serialize_PointerTons4__QueryExpressionType(soap, (struct ns4__QueryExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__TopicExpressionType:
		soap_serialize_PointerToPointerTons4__TopicExpressionType(soap, (struct ns4__TopicExpressionType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__TopicExpressionType:
		soap_serialize_PointerTons4__TopicExpressionType(soap, (struct ns4__TopicExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean_:
		soap_serialize_PointerToxsd__boolean_(soap, (enum xsd__boolean_ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo:
		soap_serialize_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, (struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__Duration:
		soap_serialize_PointerTons3__Duration(soap, (struct ns3__Duration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TimeContent:
		soap_serialize_PointerTons3__TimeContent(soap, (struct ns3__TimeContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneNextHopContent:
		soap_serialize_PointerToPointerTons3__CtrlPlaneNextHopContent(soap, (struct ns3__CtrlPlaneNextHopContent **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlaneNextHopContent:
		soap_serialize_PointerTons3__CtrlPlaneNextHopContent(soap, (struct ns3__CtrlPlaneNextHopContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneHopContent:
		soap_serialize_PointerToPointerTons3__CtrlPlaneHopContent(soap, (struct ns3__CtrlPlaneHopContent **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlaneHopContent:
		soap_serialize_PointerTons3__CtrlPlaneHopContent(soap, (struct ns3__CtrlPlaneHopContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlaneSwcapContent:
		soap_serialize_PointerTons3__CtrlPlaneSwcapContent(soap, (struct ns3__CtrlPlaneSwcapContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneAdministrativeGroup:
		soap_serialize_PointerToPointerTons3__CtrlPlaneAdministrativeGroup(soap, (struct ns3__CtrlPlaneAdministrativeGroup **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlaneAdministrativeGroup:
		soap_serialize_PointerTons3__CtrlPlaneAdministrativeGroup(soap, (struct ns3__CtrlPlaneAdministrativeGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlaneAddressContent:
		soap_serialize_PointerTons3__CtrlPlaneAddressContent(soap, (struct ns3__CtrlPlaneAddressContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneLinkContent:
		soap_serialize_PointerToPointerTons3__CtrlPlaneLinkContent(soap, (struct ns3__CtrlPlaneLinkContent **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlaneLinkContent:
		soap_serialize_PointerTons3__CtrlPlaneLinkContent(soap, (struct ns3__CtrlPlaneLinkContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlanePortContent:
		soap_serialize_PointerToPointerTons3__CtrlPlanePortContent(soap, (struct ns3__CtrlPlanePortContent **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlanePortContent:
		soap_serialize_PointerTons3__CtrlPlanePortContent(soap, (struct ns3__CtrlPlanePortContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneNodeContent:
		soap_serialize_PointerToPointerTons3__CtrlPlaneNodeContent(soap, (struct ns3__CtrlPlaneNodeContent **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlaneNodeContent:
		soap_serialize_PointerTons3__CtrlPlaneNodeContent(soap, (struct ns3__CtrlPlaneNodeContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__Lifetime:
		soap_serialize_PointerTons3__Lifetime(soap, (struct ns3__Lifetime *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneDomainSignatureContent:
		soap_serialize_PointerToPointerTons3__CtrlPlaneDomainSignatureContent(soap, (struct ns3__CtrlPlaneDomainSignatureContent **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlaneDomainSignatureContent:
		soap_serialize_PointerTons3__CtrlPlaneDomainSignatureContent(soap, (struct ns3__CtrlPlaneDomainSignatureContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlaneDomainContent:
		soap_serialize_PointerToPointerTons3__CtrlPlaneDomainContent(soap, (struct ns3__CtrlPlaneDomainContent **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlaneDomainContent:
		soap_serialize_PointerTons3__CtrlPlaneDomainContent(soap, (struct ns3__CtrlPlaneDomainContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__CtrlPlanePathContent:
		soap_serialize_PointerToPointerTons3__CtrlPlanePathContent(soap, (struct ns3__CtrlPlanePathContent **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__forwardReply:
		soap_serialize_PointerTons1__forwardReply(soap, (struct ns1__forwardReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__forwardPayload:
		soap_serialize_PointerTons1__forwardPayload(soap, (struct ns1__forwardPayload *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__localDetails:
		soap_serialize_PointerTons1__localDetails(soap, (struct ns1__localDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__msgDetails:
		soap_serialize_PointerTons1__msgDetails(soap, (struct ns1__msgDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mplsInfo:
		soap_serialize_PointerTons1__mplsInfo(soap, (struct ns1__mplsInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__layer3Info:
		soap_serialize_PointerTons1__layer3Info(soap, (struct ns1__layer3Info *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__layer2Info:
		soap_serialize_PointerTons1__layer2Info(soap, (struct ns1__layer2Info *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlanePathContent:
		soap_serialize_PointerTons3__CtrlPlanePathContent(soap, (struct ns3__CtrlPlanePathContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__teardownPathResponseContent:
		soap_serialize_PointerTons1__teardownPathResponseContent(soap, (struct ns1__teardownPathResponseContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__refreshPathResponseContent:
		soap_serialize_PointerTons1__refreshPathResponseContent(soap, (struct ns1__refreshPathResponseContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createPathResponseContent:
		soap_serialize_PointerTons1__createPathResponseContent(soap, (struct ns1__createPathResponseContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listReply:
		soap_serialize_PointerTons1__listReply(soap, (struct ns1__listReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyResReply:
		soap_serialize_PointerTons1__modifyResReply(soap, (struct ns1__modifyResReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createReply:
		soap_serialize_PointerTons1__createReply(soap, (struct ns1__createReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__teardownPathContent:
		soap_serialize_PointerTons1__teardownPathContent(soap, (struct ns1__teardownPathContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__refreshPathContent:
		soap_serialize_PointerTons1__refreshPathContent(soap, (struct ns1__refreshPathContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createPathContent:
		soap_serialize_PointerTons1__createPathContent(soap, (struct ns1__createPathContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listRequest:
		soap_serialize_PointerTons1__listRequest(soap, (struct ns1__listRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__globalReservationId:
		soap_serialize_PointerTons1__globalReservationId(soap, (struct ns1__globalReservationId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__modifyResContent:
		soap_serialize_PointerTons1__modifyResContent(soap, (struct ns1__modifyResContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__resCreateContent:
		soap_serialize_PointerTons1__resCreateContent(soap, (struct ns1__resCreateContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__resDetails:
		soap_serialize_PointerToPointerTons1__resDetails(soap, (struct ns1__resDetails **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__vlanTag:
		soap_serialize_PointerToPointerTons1__vlanTag(soap, (struct ns1__vlanTag **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__vlanTag:
		soap_serialize_PointerTons1__vlanTag(soap, (struct ns1__vlanTag *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns1__listRequest_sequence:
		soap_serialize_PointerTo__ns1__listRequest_sequence(soap, (struct __ns1__listRequest_sequence *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CtrlPlaneTopologyContent:
		soap_serialize_PointerTons3__CtrlPlaneTopologyContent(soap, (struct ns3__CtrlPlaneTopologyContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__resDetails:
		soap_serialize_PointerTons1__resDetails(soap, (struct ns1__resDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__pathInfo:
		soap_serialize_PointerTons1__pathInfo(soap, (struct ns1__pathInfo *const*)ptr);
		break;
	case SOAP_TYPE_ns4__AbsoluteOrRelativeTimeType:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Security:
		soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureType:
		soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		soap_serialize_PointerToxenc__EncryptedKeyType(soap, (struct xenc__EncryptedKeyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		soap_serialize_PointerTo_xenc__ReferenceList(soap, (struct _xenc__ReferenceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__xenc__union_ReferenceList:
		soap_serialize_PointerTo__xenc__union_ReferenceList(soap, (struct __xenc__union_ReferenceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		soap_serialize_PointerToxenc__ReferenceType(soap, (struct xenc__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		soap_serialize_PointerToxenc__EncryptionPropertyType(soap, (struct xenc__EncryptionPropertyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__TransformsType:
		soap_serialize_PointerToxenc__TransformsType(soap, (struct xenc__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		soap_serialize_PointerToxenc__CipherReferenceType(soap, (struct xenc__CipherReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, (struct xenc__EncryptionPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		soap_serialize_PointerToxenc__CipherDataType(soap, (struct xenc__CipherDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		soap_serialize_PointerTo_ds__KeyInfo(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		soap_serialize_PointerToxenc__EncryptionMethodType(soap, (struct xenc__EncryptionMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformType:
		soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DigestMethodType:
		soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformsType:
		soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__ReferenceType:
		soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509DataType:
		soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyValueType:
		soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyInfoType:
		soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignedInfoType:
		soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Reference:
		soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Password:
		soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__From:
		soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemIRI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__Action:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__To:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__MessageID:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
	p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean_(struct soap *soap, enum xsd__boolean_ *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean_
	*a = SOAP_DEFAULT_xsd__boolean_;
#else
	*a = (enum xsd__boolean_)0;
#endif
}

static const struct soap_code_map soap_codes_xsd__boolean_[] =
{	{ (long)_false, "false" },
	{ (long)_true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean_2s(struct soap *soap, enum xsd__boolean_ n)
{	const char *s = soap_code_str(soap_codes_xsd__boolean_, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean_(struct soap *soap, const char *tag, int id, const enum xsd__boolean_ *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean_), type) || soap_send(soap, soap_xsd__boolean_2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean_(struct soap *soap, const char *s, enum xsd__boolean_ *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean_, s);
	if (map)
		*a = (enum xsd__boolean_)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean_)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean_ * SOAP_FMAC4 soap_in_xsd__boolean_(struct soap *soap, const char *tag, enum xsd__boolean_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum xsd__boolean_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean_, sizeof(enum xsd__boolean_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean_(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean_, 0, sizeof(enum xsd__boolean_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean_(struct soap *soap, const enum xsd__boolean_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean_);
	if (soap_out_xsd__boolean_(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean_ * SOAP_FMAC4 soap_get_xsd__boolean_(struct soap *soap, enum xsd__boolean_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsse__FaultcodeEnum
	*a = SOAP_DEFAULT_wsse__FaultcodeEnum;
#else
	*a = (enum wsse__FaultcodeEnum)0;
#endif
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (long)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (long)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (long)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (long)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (long)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (long)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (long)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, 0, sizeof(enum wsse__FaultcodeEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsse__FaultcodeEnum);
	if (soap_out_wsse__FaultcodeEnum(soap, tag?tag:"wsse:FaultcodeEnum", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsu__tTimestampFault
	*a = SOAP_DEFAULT_wsu__tTimestampFault;
#else
	*a = (enum wsu__tTimestampFault)0;
#endif
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (long)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsu__tTimestampFault(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, 0, sizeof(enum wsu__tTimestampFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsu__tTimestampFault);
	if (soap_out_wsu__tTimestampFault(soap, tag?tag:"wsu:tTimestampFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__wsa5__IsReferenceParameter
	*a = SOAP_DEFAULT__wsa5__IsReferenceParameter;
#else
	*a = (enum _wsa5__IsReferenceParameter)0;
#endif
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (long)wsa5__false, "wsa5:false" },
	{ (long)wsa5__true, "wsa5:true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, t);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, 0, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa5__IsReferenceParameter);
	if (soap_out__wsa5__IsReferenceParameter(soap, tag?tag:"wsa5:IsReferenceParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__FaultCodesType
	*a = SOAP_DEFAULT_wsa5__FaultCodesType;
#else
	*a = (enum wsa5__FaultCodesType)0;
#endif
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (long)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (long)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (long)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (long)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (long)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (long)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (long)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (long)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (long)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (long)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (long)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, 0, sizeof(enum wsa5__FaultCodesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__FaultCodesType);
	if (soap_out_wsa5__FaultCodesType(soap, tag?tag:"wsa5:FaultCodesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__RelationshipType
	*a = SOAP_DEFAULT_wsa5__RelationshipType;
#else
	*a = (enum wsa5__RelationshipType)0;
#endif
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (long)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsa5__RelationshipType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, 0, sizeof(enum wsa5__RelationshipType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelationshipType);
	if (soap_out_wsa5__RelationshipType(soap, tag?tag:"wsa5:RelationshipType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Notify(struct soap *soap, struct __ns1__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__Notify = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Notify(struct soap *soap, const struct __ns1__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__Notify(soap, &a->ns4__Notify);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Notify(struct soap *soap, const char *tag, int id, const struct __ns1__Notify *a, const char *type)
{
	if (soap_out_PointerTo_ns4__Notify(soap, "ns4:Notify", -1, &a->ns4__Notify, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Notify * SOAP_FMAC4 soap_in___ns1__Notify(struct soap *soap, const char *tag, struct __ns1__Notify *a, const char *type)
{
	size_t soap_flag_ns4__Notify = 1;
	short soap_flag;
	a = (struct __ns1__Notify *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Notify, sizeof(struct __ns1__Notify), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Notify(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__Notify && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__Notify(soap, "ns4:Notify", &a->ns4__Notify, ""))
				{	soap_flag_ns4__Notify--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Notify(struct soap *soap, const struct __ns1__Notify *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Notify(soap, tag?tag:"-ns1:Notify", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Notify * SOAP_FMAC4 soap_get___ns1__Notify(struct soap *soap, struct __ns1__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__forward(struct soap *soap, struct __ns1__forward *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__forward = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__forward(struct soap *soap, const struct __ns1__forward *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__forward(soap, &a->ns1__forward);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__forward(struct soap *soap, const char *tag, int id, const struct __ns1__forward *a, const char *type)
{
	if (soap_out_PointerTo_ns1__forward(soap, "ns1:forward", -1, &a->ns1__forward, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__forward * SOAP_FMAC4 soap_in___ns1__forward(struct soap *soap, const char *tag, struct __ns1__forward *a, const char *type)
{
	size_t soap_flag_ns1__forward = 1;
	short soap_flag;
	a = (struct __ns1__forward *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__forward, sizeof(struct __ns1__forward), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__forward(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__forward && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__forward(soap, "ns1:forward", &a->ns1__forward, ""))
				{	soap_flag_ns1__forward--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__forward(struct soap *soap, const struct __ns1__forward *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__forward(soap, tag?tag:"-ns1:forward", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__forward * SOAP_FMAC4 soap_get___ns1__forward(struct soap *soap, struct __ns1__forward *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__forward(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__teardownPath(struct soap *soap, struct __ns1__teardownPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__teardownPath = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__teardownPath(struct soap *soap, const struct __ns1__teardownPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__teardownPathContent(soap, &a->ns1__teardownPath);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__teardownPath(struct soap *soap, const char *tag, int id, const struct __ns1__teardownPath *a, const char *type)
{
	if (soap_out_PointerTons1__teardownPathContent(soap, "ns1:teardownPath", -1, &a->ns1__teardownPath, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__teardownPath * SOAP_FMAC4 soap_in___ns1__teardownPath(struct soap *soap, const char *tag, struct __ns1__teardownPath *a, const char *type)
{
	size_t soap_flag_ns1__teardownPath = 1;
	short soap_flag;
	a = (struct __ns1__teardownPath *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__teardownPath, sizeof(struct __ns1__teardownPath), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__teardownPath(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__teardownPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__teardownPathContent(soap, "ns1:teardownPath", &a->ns1__teardownPath, "ns1:teardownPathContent"))
				{	soap_flag_ns1__teardownPath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__teardownPath(struct soap *soap, const struct __ns1__teardownPath *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__teardownPath(soap, tag?tag:"-ns1:teardownPath", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__teardownPath * SOAP_FMAC4 soap_get___ns1__teardownPath(struct soap *soap, struct __ns1__teardownPath *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__teardownPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__refreshPath(struct soap *soap, struct __ns1__refreshPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__refreshPath = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__refreshPath(struct soap *soap, const struct __ns1__refreshPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__refreshPathContent(soap, &a->ns1__refreshPath);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__refreshPath(struct soap *soap, const char *tag, int id, const struct __ns1__refreshPath *a, const char *type)
{
	if (soap_out_PointerTons1__refreshPathContent(soap, "ns1:refreshPath", -1, &a->ns1__refreshPath, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__refreshPath * SOAP_FMAC4 soap_in___ns1__refreshPath(struct soap *soap, const char *tag, struct __ns1__refreshPath *a, const char *type)
{
	size_t soap_flag_ns1__refreshPath = 1;
	short soap_flag;
	a = (struct __ns1__refreshPath *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__refreshPath, sizeof(struct __ns1__refreshPath), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__refreshPath(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__refreshPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__refreshPathContent(soap, "ns1:refreshPath", &a->ns1__refreshPath, "ns1:refreshPathContent"))
				{	soap_flag_ns1__refreshPath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__refreshPath(struct soap *soap, const struct __ns1__refreshPath *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__refreshPath(soap, tag?tag:"-ns1:refreshPath", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__refreshPath * SOAP_FMAC4 soap_get___ns1__refreshPath(struct soap *soap, struct __ns1__refreshPath *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__refreshPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createPath(struct soap *soap, struct __ns1__createPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__createPath = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createPath(struct soap *soap, const struct __ns1__createPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__createPathContent(soap, &a->ns1__createPath);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createPath(struct soap *soap, const char *tag, int id, const struct __ns1__createPath *a, const char *type)
{
	if (soap_out_PointerTons1__createPathContent(soap, "ns1:createPath", -1, &a->ns1__createPath, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createPath * SOAP_FMAC4 soap_in___ns1__createPath(struct soap *soap, const char *tag, struct __ns1__createPath *a, const char *type)
{
	size_t soap_flag_ns1__createPath = 1;
	short soap_flag;
	a = (struct __ns1__createPath *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createPath, sizeof(struct __ns1__createPath), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createPath(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createPathContent(soap, "ns1:createPath", &a->ns1__createPath, "ns1:createPathContent"))
				{	soap_flag_ns1__createPath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createPath(struct soap *soap, const struct __ns1__createPath *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__createPath(soap, tag?tag:"-ns1:createPath", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createPath * SOAP_FMAC4 soap_get___ns1__createPath(struct soap *soap, struct __ns1__createPath *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getNetworkTopology(struct soap *soap, struct __ns1__getNetworkTopology *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getNetworkTopology = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getNetworkTopology(struct soap *soap, const struct __ns1__getNetworkTopology *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getTopologyContent(soap, &a->ns1__getNetworkTopology);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getNetworkTopology(struct soap *soap, const char *tag, int id, const struct __ns1__getNetworkTopology *a, const char *type)
{
	if (soap_out_PointerTons1__getTopologyContent(soap, "ns1:getNetworkTopology", -1, &a->ns1__getNetworkTopology, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNetworkTopology * SOAP_FMAC4 soap_in___ns1__getNetworkTopology(struct soap *soap, const char *tag, struct __ns1__getNetworkTopology *a, const char *type)
{
	size_t soap_flag_ns1__getNetworkTopology = 1;
	short soap_flag;
	a = (struct __ns1__getNetworkTopology *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getNetworkTopology, sizeof(struct __ns1__getNetworkTopology), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getNetworkTopology(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getNetworkTopology && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getTopologyContent(soap, "ns1:getNetworkTopology", &a->ns1__getNetworkTopology, "ns1:getTopologyContent"))
				{	soap_flag_ns1__getNetworkTopology--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getNetworkTopology(struct soap *soap, const struct __ns1__getNetworkTopology *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getNetworkTopology(soap, tag?tag:"-ns1:getNetworkTopology", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNetworkTopology * SOAP_FMAC4 soap_get___ns1__getNetworkTopology(struct soap *soap, struct __ns1__getNetworkTopology *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getNetworkTopology(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyReservation(struct soap *soap, struct __ns1__modifyReservation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__modifyReservation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyReservation(struct soap *soap, const struct __ns1__modifyReservation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__modifyResContent(soap, &a->ns1__modifyReservation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyReservation(struct soap *soap, const char *tag, int id, const struct __ns1__modifyReservation *a, const char *type)
{
	if (soap_out_PointerTons1__modifyResContent(soap, "ns1:modifyReservation", -1, &a->ns1__modifyReservation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyReservation * SOAP_FMAC4 soap_in___ns1__modifyReservation(struct soap *soap, const char *tag, struct __ns1__modifyReservation *a, const char *type)
{
	size_t soap_flag_ns1__modifyReservation = 1;
	short soap_flag;
	a = (struct __ns1__modifyReservation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyReservation, sizeof(struct __ns1__modifyReservation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__modifyReservation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyResContent(soap, "ns1:modifyReservation", &a->ns1__modifyReservation, "ns1:modifyResContent"))
				{	soap_flag_ns1__modifyReservation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyReservation(struct soap *soap, const struct __ns1__modifyReservation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__modifyReservation(soap, tag?tag:"-ns1:modifyReservation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyReservation * SOAP_FMAC4 soap_get___ns1__modifyReservation(struct soap *soap, struct __ns1__modifyReservation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__modifyReservation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cancelReservation(struct soap *soap, struct __ns1__cancelReservation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cancelReservation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cancelReservation(struct soap *soap, const struct __ns1__cancelReservation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__globalReservationId(soap, &a->ns1__cancelReservation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cancelReservation(struct soap *soap, const char *tag, int id, const struct __ns1__cancelReservation *a, const char *type)
{
	if (soap_out_PointerTons1__globalReservationId(soap, "ns1:cancelReservation", -1, &a->ns1__cancelReservation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cancelReservation * SOAP_FMAC4 soap_in___ns1__cancelReservation(struct soap *soap, const char *tag, struct __ns1__cancelReservation *a, const char *type)
{
	size_t soap_flag_ns1__cancelReservation = 1;
	short soap_flag;
	a = (struct __ns1__cancelReservation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cancelReservation, sizeof(struct __ns1__cancelReservation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cancelReservation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cancelReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__globalReservationId(soap, "ns1:cancelReservation", &a->ns1__cancelReservation, "ns1:globalReservationId"))
				{	soap_flag_ns1__cancelReservation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cancelReservation(struct soap *soap, const struct __ns1__cancelReservation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cancelReservation(soap, tag?tag:"-ns1:cancelReservation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cancelReservation * SOAP_FMAC4 soap_get___ns1__cancelReservation(struct soap *soap, struct __ns1__cancelReservation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cancelReservation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cancelReservationResponse(struct soap *soap, struct __ns1__cancelReservationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cancelReservationResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cancelReservationResponse(struct soap *soap, const struct __ns1__cancelReservationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->ns1__cancelReservationResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cancelReservationResponse(struct soap *soap, const char *tag, int id, const struct __ns1__cancelReservationResponse *a, const char *type)
{
	if (a->ns1__cancelReservationResponse)
		soap_element_result(soap, "ns1:cancelReservationResponse");
	if (soap_out_PointerTostring(soap, "ns1:cancelReservationResponse", -1, &a->ns1__cancelReservationResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cancelReservationResponse * SOAP_FMAC4 soap_in___ns1__cancelReservationResponse(struct soap *soap, const char *tag, struct __ns1__cancelReservationResponse *a, const char *type)
{
	size_t soap_flag_ns1__cancelReservationResponse = 1;
	short soap_flag;
	a = (struct __ns1__cancelReservationResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cancelReservationResponse, sizeof(struct __ns1__cancelReservationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cancelReservationResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cancelReservationResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "ns1:cancelReservationResponse", &a->ns1__cancelReservationResponse, "xsd:string"))
				{	soap_flag_ns1__cancelReservationResponse--;
					continue;
				}
			soap_check_result(soap, "ns1:cancelReservationResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cancelReservationResponse(struct soap *soap, const struct __ns1__cancelReservationResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cancelReservationResponse(soap, tag?tag:"-ns1:cancelReservationResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cancelReservationResponse * SOAP_FMAC4 soap_get___ns1__cancelReservationResponse(struct soap *soap, struct __ns1__cancelReservationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cancelReservationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listReservations(struct soap *soap, struct __ns1__listReservations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__listReservations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listReservations(struct soap *soap, const struct __ns1__listReservations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__listRequest(soap, &a->ns1__listReservations);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listReservations(struct soap *soap, const char *tag, int id, const struct __ns1__listReservations *a, const char *type)
{
	if (soap_out_PointerTons1__listRequest(soap, "ns1:listReservations", -1, &a->ns1__listReservations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listReservations * SOAP_FMAC4 soap_in___ns1__listReservations(struct soap *soap, const char *tag, struct __ns1__listReservations *a, const char *type)
{
	size_t soap_flag_ns1__listReservations = 1;
	short soap_flag;
	a = (struct __ns1__listReservations *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listReservations, sizeof(struct __ns1__listReservations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listReservations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__listReservations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listRequest(soap, "ns1:listReservations", &a->ns1__listReservations, "ns1:listRequest"))
				{	soap_flag_ns1__listReservations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listReservations(struct soap *soap, const struct __ns1__listReservations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listReservations(soap, tag?tag:"-ns1:listReservations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listReservations * SOAP_FMAC4 soap_get___ns1__listReservations(struct soap *soap, struct __ns1__listReservations *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listReservations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryReservation(struct soap *soap, struct __ns1__queryReservation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryReservation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryReservation(struct soap *soap, const struct __ns1__queryReservation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__globalReservationId(soap, &a->ns1__queryReservation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryReservation(struct soap *soap, const char *tag, int id, const struct __ns1__queryReservation *a, const char *type)
{
	if (soap_out_PointerTons1__globalReservationId(soap, "ns1:queryReservation", -1, &a->ns1__queryReservation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryReservation * SOAP_FMAC4 soap_in___ns1__queryReservation(struct soap *soap, const char *tag, struct __ns1__queryReservation *a, const char *type)
{
	size_t soap_flag_ns1__queryReservation = 1;
	short soap_flag;
	a = (struct __ns1__queryReservation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryReservation, sizeof(struct __ns1__queryReservation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryReservation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__globalReservationId(soap, "ns1:queryReservation", &a->ns1__queryReservation, "ns1:globalReservationId"))
				{	soap_flag_ns1__queryReservation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryReservation(struct soap *soap, const struct __ns1__queryReservation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryReservation(soap, tag?tag:"-ns1:queryReservation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryReservation * SOAP_FMAC4 soap_get___ns1__queryReservation(struct soap *soap, struct __ns1__queryReservation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryReservation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createReservation(struct soap *soap, struct __ns1__createReservation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__createReservation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createReservation(struct soap *soap, const struct __ns1__createReservation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__resCreateContent(soap, &a->ns1__createReservation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createReservation(struct soap *soap, const char *tag, int id, const struct __ns1__createReservation *a, const char *type)
{
	if (soap_out_PointerTons1__resCreateContent(soap, "ns1:createReservation", -1, &a->ns1__createReservation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createReservation * SOAP_FMAC4 soap_in___ns1__createReservation(struct soap *soap, const char *tag, struct __ns1__createReservation *a, const char *type)
{
	size_t soap_flag_ns1__createReservation = 1;
	short soap_flag;
	a = (struct __ns1__createReservation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createReservation, sizeof(struct __ns1__createReservation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createReservation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__resCreateContent(soap, "ns1:createReservation", &a->ns1__createReservation, "ns1:resCreateContent"))
				{	soap_flag_ns1__createReservation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createReservation(struct soap *soap, const struct __ns1__createReservation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__createReservation(soap, tag?tag:"-ns1:createReservation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createReservation * SOAP_FMAC4 soap_get___ns1__createReservation(struct soap *soap, struct __ns1__createReservation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createReservation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->ns1__AAAFault = NULL;
	a->ns1__BSSFault = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AAAFault(soap, &a->ns1__AAAFault);
	soap_serialize_PointerTo_ns1__BSSFault(soap, &a->ns1__BSSFault);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_out_PointerTo_ns1__AAAFault(soap, "ns1:AAAFault", -1, &a->ns1__AAAFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__BSSFault(soap, "ns1:BSSFault", -1, &a->ns1__BSSFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_ns1__AAAFault = 1;
	size_t soap_flag_ns1__BSSFault = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AAAFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AAAFault(soap, "ns1:AAAFault", &a->ns1__AAAFault, ""))
				{	soap_flag_ns1__AAAFault--;
					continue;
				}
			if (soap_flag_ns1__BSSFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BSSFault(soap, "ns1:BSSFault", &a->ns1__BSSFault, ""))
				{	soap_flag_ns1__BSSFault--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__ResourceUnavailableFaultType(struct soap *soap, struct ns5__ResourceUnavailableFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__ResourceUnavailableFaultType(struct soap *soap, const struct ns5__ResourceUnavailableFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ResourceUnavailableFaultType(struct soap *soap, const char *tag, int id, const struct ns5__ResourceUnavailableFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ResourceUnavailableFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__ResourceUnavailableFaultType * SOAP_FMAC4 soap_in_ns5__ResourceUnavailableFaultType(struct soap *soap, const char *tag, struct ns5__ResourceUnavailableFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__ResourceUnavailableFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ResourceUnavailableFaultType, sizeof(struct ns5__ResourceUnavailableFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__ResourceUnavailableFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns5__ResourceUnavailableFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ResourceUnavailableFaultType, 0, sizeof(struct ns5__ResourceUnavailableFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__ResourceUnavailableFaultType(struct soap *soap, const struct ns5__ResourceUnavailableFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__ResourceUnavailableFaultType);
	if (soap_out_ns5__ResourceUnavailableFaultType(soap, tag?tag:"ns5:ResourceUnavailableFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__ResourceUnavailableFaultType * SOAP_FMAC4 soap_get_ns5__ResourceUnavailableFaultType(struct soap *soap, struct ns5__ResourceUnavailableFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ResourceUnavailableFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__ResourceUnknownFaultType(struct soap *soap, struct ns5__ResourceUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__ResourceUnknownFaultType(struct soap *soap, const struct ns5__ResourceUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ResourceUnknownFaultType(struct soap *soap, const char *tag, int id, const struct ns5__ResourceUnknownFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ResourceUnknownFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__ResourceUnknownFaultType * SOAP_FMAC4 soap_in_ns5__ResourceUnknownFaultType(struct soap *soap, const char *tag, struct ns5__ResourceUnknownFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__ResourceUnknownFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ResourceUnknownFaultType, sizeof(struct ns5__ResourceUnknownFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__ResourceUnknownFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns5__ResourceUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ResourceUnknownFaultType, 0, sizeof(struct ns5__ResourceUnknownFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__ResourceUnknownFaultType(struct soap *soap, const struct ns5__ResourceUnknownFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__ResourceUnknownFaultType);
	if (soap_out_ns5__ResourceUnknownFaultType(soap, tag?tag:"ns5:ResourceUnknownFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__ResourceUnknownFaultType * SOAP_FMAC4 soap_get_ns5__ResourceUnknownFaultType(struct soap *soap, struct ns5__ResourceUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ResourceUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ResumeFailedFaultType(struct soap *soap, struct ns4__ResumeFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ResumeFailedFaultType(struct soap *soap, const struct ns4__ResumeFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, const struct ns4__ResumeFailedFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ResumeFailedFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ResumeFailedFaultType * SOAP_FMAC4 soap_in_ns4__ResumeFailedFaultType(struct soap *soap, const char *tag, struct ns4__ResumeFailedFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ResumeFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ResumeFailedFaultType, sizeof(struct ns4__ResumeFailedFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ResumeFailedFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ResumeFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ResumeFailedFaultType, 0, sizeof(struct ns4__ResumeFailedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ResumeFailedFaultType(struct soap *soap, const struct ns4__ResumeFailedFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ResumeFailedFaultType);
	if (soap_out_ns4__ResumeFailedFaultType(soap, tag?tag:"ns4:ResumeFailedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ResumeFailedFaultType * SOAP_FMAC4 soap_get_ns4__ResumeFailedFaultType(struct soap *soap, struct ns4__ResumeFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__PauseFailedFaultType(struct soap *soap, struct ns4__PauseFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__PauseFailedFaultType(struct soap *soap, const struct ns4__PauseFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__PauseFailedFaultType(struct soap *soap, const char *tag, int id, const struct ns4__PauseFailedFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__PauseFailedFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__PauseFailedFaultType * SOAP_FMAC4 soap_in_ns4__PauseFailedFaultType(struct soap *soap, const char *tag, struct ns4__PauseFailedFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__PauseFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__PauseFailedFaultType, sizeof(struct ns4__PauseFailedFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__PauseFailedFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__PauseFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__PauseFailedFaultType, 0, sizeof(struct ns4__PauseFailedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__PauseFailedFaultType(struct soap *soap, const struct ns4__PauseFailedFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__PauseFailedFaultType);
	if (soap_out_ns4__PauseFailedFaultType(soap, tag?tag:"ns4:PauseFailedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__PauseFailedFaultType * SOAP_FMAC4 soap_get_ns4__PauseFailedFaultType(struct soap *soap, struct ns4__PauseFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UnableToDestroySubscriptionFaultType(struct soap *soap, struct ns4__UnableToDestroySubscriptionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UnableToDestroySubscriptionFaultType(struct soap *soap, const struct ns4__UnableToDestroySubscriptionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, const struct ns4__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UnableToDestroySubscriptionFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_in_ns4__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, struct ns4__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UnableToDestroySubscriptionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UnableToDestroySubscriptionFaultType, sizeof(struct ns4__UnableToDestroySubscriptionFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UnableToDestroySubscriptionFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__UnableToDestroySubscriptionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UnableToDestroySubscriptionFaultType, 0, sizeof(struct ns4__UnableToDestroySubscriptionFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UnableToDestroySubscriptionFaultType(struct soap *soap, const struct ns4__UnableToDestroySubscriptionFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UnableToDestroySubscriptionFaultType);
	if (soap_out_ns4__UnableToDestroySubscriptionFaultType(soap, tag?tag:"ns4:UnableToDestroySubscriptionFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_get_ns4__UnableToDestroySubscriptionFaultType(struct soap *soap, struct ns4__UnableToDestroySubscriptionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UnacceptableTerminationTimeFaultType(struct soap *soap, struct ns4__UnacceptableTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
	soap_default_time(soap, &a->MinimumTime);
	a->MaximumTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UnacceptableTerminationTimeFaultType(struct soap *soap, const struct ns4__UnacceptableTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
	soap_embedded(soap, &a->MinimumTime, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &a->MaximumTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const struct ns4__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UnacceptableTerminationTimeFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	if (soap_out_time(soap, "ns4:MinimumTime", -1, &a->MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns4:MaximumTime", -1, &a->MaximumTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_in_ns4__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, struct ns4__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	size_t soap_flag_MinimumTime = 1;
	size_t soap_flag_MaximumTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UnacceptableTerminationTimeFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UnacceptableTerminationTimeFaultType, sizeof(struct ns4__UnacceptableTerminationTimeFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UnacceptableTerminationTimeFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns4:MinimumTime", &a->MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime--;
					continue;
				}
			if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:MaximumTime", &a->MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__UnacceptableTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UnacceptableTerminationTimeFaultType, 0, sizeof(struct ns4__UnacceptableTerminationTimeFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0 || soap_flag_MinimumTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UnacceptableTerminationTimeFaultType(struct soap *soap, const struct ns4__UnacceptableTerminationTimeFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UnacceptableTerminationTimeFaultType);
	if (soap_out_ns4__UnacceptableTerminationTimeFaultType(soap, tag?tag:"ns4:UnacceptableTerminationTimeFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_get_ns4__UnacceptableTerminationTimeFaultType(struct soap *soap, struct ns4__UnacceptableTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UnableToCreatePullPointFaultType(struct soap *soap, struct ns4__UnableToCreatePullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UnableToCreatePullPointFaultType(struct soap *soap, const struct ns4__UnableToCreatePullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, const struct ns4__UnableToCreatePullPointFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UnableToCreatePullPointFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_in_ns4__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, struct ns4__UnableToCreatePullPointFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UnableToCreatePullPointFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UnableToCreatePullPointFaultType, sizeof(struct ns4__UnableToCreatePullPointFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UnableToCreatePullPointFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__UnableToCreatePullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UnableToCreatePullPointFaultType, 0, sizeof(struct ns4__UnableToCreatePullPointFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UnableToCreatePullPointFaultType(struct soap *soap, const struct ns4__UnableToCreatePullPointFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UnableToCreatePullPointFaultType);
	if (soap_out_ns4__UnableToCreatePullPointFaultType(soap, tag?tag:"ns4:UnableToCreatePullPointFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_get_ns4__UnableToCreatePullPointFaultType(struct soap *soap, struct ns4__UnableToCreatePullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UnableToDestroyPullPointFaultType(struct soap *soap, struct ns4__UnableToDestroyPullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UnableToDestroyPullPointFaultType(struct soap *soap, const struct ns4__UnableToDestroyPullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, const struct ns4__UnableToDestroyPullPointFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UnableToDestroyPullPointFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_in_ns4__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, struct ns4__UnableToDestroyPullPointFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UnableToDestroyPullPointFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UnableToDestroyPullPointFaultType, sizeof(struct ns4__UnableToDestroyPullPointFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UnableToDestroyPullPointFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__UnableToDestroyPullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UnableToDestroyPullPointFaultType, 0, sizeof(struct ns4__UnableToDestroyPullPointFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UnableToDestroyPullPointFaultType(struct soap *soap, const struct ns4__UnableToDestroyPullPointFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UnableToDestroyPullPointFaultType);
	if (soap_out_ns4__UnableToDestroyPullPointFaultType(soap, tag?tag:"ns4:UnableToDestroyPullPointFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_get_ns4__UnableToDestroyPullPointFaultType(struct soap *soap, struct ns4__UnableToDestroyPullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UnableToGetMessagesFaultType(struct soap *soap, struct ns4__UnableToGetMessagesFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UnableToGetMessagesFaultType(struct soap *soap, const struct ns4__UnableToGetMessagesFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, const struct ns4__UnableToGetMessagesFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UnableToGetMessagesFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_in_ns4__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, struct ns4__UnableToGetMessagesFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UnableToGetMessagesFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UnableToGetMessagesFaultType, sizeof(struct ns4__UnableToGetMessagesFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UnableToGetMessagesFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__UnableToGetMessagesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UnableToGetMessagesFaultType, 0, sizeof(struct ns4__UnableToGetMessagesFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UnableToGetMessagesFaultType(struct soap *soap, const struct ns4__UnableToGetMessagesFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UnableToGetMessagesFaultType);
	if (soap_out_ns4__UnableToGetMessagesFaultType(soap, tag?tag:"ns4:UnableToGetMessagesFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_get_ns4__UnableToGetMessagesFaultType(struct soap *soap, struct ns4__UnableToGetMessagesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct ns4__NoCurrentMessageOnTopicFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__NoCurrentMessageOnTopicFaultType(struct soap *soap, const struct ns4__NoCurrentMessageOnTopicFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, const struct ns4__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__NoCurrentMessageOnTopicFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_in_ns4__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, struct ns4__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__NoCurrentMessageOnTopicFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__NoCurrentMessageOnTopicFaultType, sizeof(struct ns4__NoCurrentMessageOnTopicFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__NoCurrentMessageOnTopicFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__NoCurrentMessageOnTopicFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__NoCurrentMessageOnTopicFaultType, 0, sizeof(struct ns4__NoCurrentMessageOnTopicFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__NoCurrentMessageOnTopicFaultType(struct soap *soap, const struct ns4__NoCurrentMessageOnTopicFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__NoCurrentMessageOnTopicFaultType);
	if (soap_out_ns4__NoCurrentMessageOnTopicFaultType(soap, tag?tag:"ns4:NoCurrentMessageOnTopicFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_get_ns4__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct ns4__NoCurrentMessageOnTopicFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct ns4__UnacceptableInitialTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
	soap_default_time(soap, &a->MinimumTime);
	a->MaximumTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const struct ns4__UnacceptableInitialTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
	soap_embedded(soap, &a->MinimumTime, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &a->MaximumTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const struct ns4__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UnacceptableInitialTerminationTimeFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	if (soap_out_time(soap, "ns4:MinimumTime", -1, &a->MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns4:MaximumTime", -1, &a->MaximumTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_in_ns4__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, struct ns4__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	size_t soap_flag_MinimumTime = 1;
	size_t soap_flag_MaximumTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UnacceptableInitialTerminationTimeFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UnacceptableInitialTerminationTimeFaultType, sizeof(struct ns4__UnacceptableInitialTerminationTimeFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UnacceptableInitialTerminationTimeFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns4:MinimumTime", &a->MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime--;
					continue;
				}
			if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:MaximumTime", &a->MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__UnacceptableInitialTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UnacceptableInitialTerminationTimeFaultType, 0, sizeof(struct ns4__UnacceptableInitialTerminationTimeFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0 || soap_flag_MinimumTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const struct ns4__UnacceptableInitialTerminationTimeFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UnacceptableInitialTerminationTimeFaultType);
	if (soap_out_ns4__UnacceptableInitialTerminationTimeFaultType(soap, tag?tag:"ns4:UnacceptableInitialTerminationTimeFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_get_ns4__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct ns4__UnacceptableInitialTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__NotifyMessageNotSupportedFaultType(struct soap *soap, struct ns4__NotifyMessageNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__NotifyMessageNotSupportedFaultType(struct soap *soap, const struct ns4__NotifyMessageNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, const struct ns4__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__NotifyMessageNotSupportedFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_in_ns4__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, struct ns4__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__NotifyMessageNotSupportedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__NotifyMessageNotSupportedFaultType, sizeof(struct ns4__NotifyMessageNotSupportedFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__NotifyMessageNotSupportedFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__NotifyMessageNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__NotifyMessageNotSupportedFaultType, 0, sizeof(struct ns4__NotifyMessageNotSupportedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__NotifyMessageNotSupportedFaultType(struct soap *soap, const struct ns4__NotifyMessageNotSupportedFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__NotifyMessageNotSupportedFaultType);
	if (soap_out_ns4__NotifyMessageNotSupportedFaultType(soap, tag?tag:"ns4:NotifyMessageNotSupportedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_get_ns4__NotifyMessageNotSupportedFaultType(struct soap *soap, struct ns4__NotifyMessageNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UnsupportedPolicyRequestFaultType(struct soap *soap, struct ns4__UnsupportedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
	a->__sizeUnsupportedPolicy = 0;
	a->UnsupportedPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UnsupportedPolicyRequestFaultType(struct soap *soap, const struct ns4__UnsupportedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
	if (a->UnsupportedPolicy)
	{	int i;
		for (i = 0; i < a->__sizeUnsupportedPolicy; i++)
		{
			soap_serialize__QName(soap, a->UnsupportedPolicy + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const struct ns4__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UnsupportedPolicyRequestFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	if (a->UnsupportedPolicy)
	{	int i;
		for (i = 0; i < a->__sizeUnsupportedPolicy; i++)
		{	const char *soap_tmp_UnsupportedPolicy = soap_QName2s(soap, a->UnsupportedPolicy[i]);
			if (soap_out__QName(soap, "ns4:UnsupportedPolicy", -1, (char*const*)&soap_tmp_UnsupportedPolicy, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_in_ns4__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, struct ns4__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	struct soap_blist *soap_blist_UnsupportedPolicy = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UnsupportedPolicyRequestFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UnsupportedPolicyRequestFaultType, sizeof(struct ns4__UnsupportedPolicyRequestFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UnsupportedPolicyRequestFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:UnsupportedPolicy", 1, NULL))
			{	if (a->UnsupportedPolicy == NULL)
				{	if (soap_blist_UnsupportedPolicy == NULL)
						soap_blist_UnsupportedPolicy = soap_new_block(soap);
					a->UnsupportedPolicy = (char **)soap_push_block(soap, soap_blist_UnsupportedPolicy, sizeof(char *));
					if (a->UnsupportedPolicy == NULL)
						return NULL;
					*a->UnsupportedPolicy = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "ns4:UnsupportedPolicy", a->UnsupportedPolicy, ""))
				{	a->__sizeUnsupportedPolicy++;
					a->UnsupportedPolicy = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (a->UnsupportedPolicy)
			soap_pop_block(soap, soap_blist_UnsupportedPolicy);
		if (a->__sizeUnsupportedPolicy)
			a->UnsupportedPolicy = (char **)soap_save_block(soap, soap_blist_UnsupportedPolicy, NULL, 1);
		else
		{	a->UnsupportedPolicy = NULL;
			if (soap_blist_UnsupportedPolicy)
				soap_end_block(soap, soap_blist_UnsupportedPolicy);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__UnsupportedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UnsupportedPolicyRequestFaultType, 0, sizeof(struct ns4__UnsupportedPolicyRequestFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UnsupportedPolicyRequestFaultType(struct soap *soap, const struct ns4__UnsupportedPolicyRequestFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UnsupportedPolicyRequestFaultType);
	if (soap_out_ns4__UnsupportedPolicyRequestFaultType(soap, tag?tag:"ns4:UnsupportedPolicyRequestFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_get_ns4__UnsupportedPolicyRequestFaultType(struct soap *soap, struct ns4__UnsupportedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct ns4__UnrecognizedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
	a->__sizeUnrecognizedPolicy = 0;
	a->UnrecognizedPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UnrecognizedPolicyRequestFaultType(struct soap *soap, const struct ns4__UnrecognizedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
	if (a->UnrecognizedPolicy)
	{	int i;
		for (i = 0; i < a->__sizeUnrecognizedPolicy; i++)
		{
			soap_serialize__QName(soap, a->UnrecognizedPolicy + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const struct ns4__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UnrecognizedPolicyRequestFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	if (a->UnrecognizedPolicy)
	{	int i;
		for (i = 0; i < a->__sizeUnrecognizedPolicy; i++)
		{	const char *soap_tmp_UnrecognizedPolicy = soap_QName2s(soap, a->UnrecognizedPolicy[i]);
			if (soap_out__QName(soap, "ns4:UnrecognizedPolicy", -1, (char*const*)&soap_tmp_UnrecognizedPolicy, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_in_ns4__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, struct ns4__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	struct soap_blist *soap_blist_UnrecognizedPolicy = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UnrecognizedPolicyRequestFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UnrecognizedPolicyRequestFaultType, sizeof(struct ns4__UnrecognizedPolicyRequestFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UnrecognizedPolicyRequestFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:UnrecognizedPolicy", 1, NULL))
			{	if (a->UnrecognizedPolicy == NULL)
				{	if (soap_blist_UnrecognizedPolicy == NULL)
						soap_blist_UnrecognizedPolicy = soap_new_block(soap);
					a->UnrecognizedPolicy = (char **)soap_push_block(soap, soap_blist_UnrecognizedPolicy, sizeof(char *));
					if (a->UnrecognizedPolicy == NULL)
						return NULL;
					*a->UnrecognizedPolicy = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "ns4:UnrecognizedPolicy", a->UnrecognizedPolicy, ""))
				{	a->__sizeUnrecognizedPolicy++;
					a->UnrecognizedPolicy = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (a->UnrecognizedPolicy)
			soap_pop_block(soap, soap_blist_UnrecognizedPolicy);
		if (a->__sizeUnrecognizedPolicy)
			a->UnrecognizedPolicy = (char **)soap_save_block(soap, soap_blist_UnrecognizedPolicy, NULL, 1);
		else
		{	a->UnrecognizedPolicy = NULL;
			if (soap_blist_UnrecognizedPolicy)
				soap_end_block(soap, soap_blist_UnrecognizedPolicy);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__UnrecognizedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UnrecognizedPolicyRequestFaultType, 0, sizeof(struct ns4__UnrecognizedPolicyRequestFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UnrecognizedPolicyRequestFaultType(struct soap *soap, const struct ns4__UnrecognizedPolicyRequestFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UnrecognizedPolicyRequestFaultType);
	if (soap_out_ns4__UnrecognizedPolicyRequestFaultType(soap, tag?tag:"ns4:UnrecognizedPolicyRequestFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_get_ns4__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct ns4__UnrecognizedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__InvalidMessageContentExpressionFaultType(struct soap *soap, struct ns4__InvalidMessageContentExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__InvalidMessageContentExpressionFaultType(struct soap *soap, const struct ns4__InvalidMessageContentExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, const struct ns4__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__InvalidMessageContentExpressionFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_in_ns4__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, struct ns4__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__InvalidMessageContentExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__InvalidMessageContentExpressionFaultType, sizeof(struct ns4__InvalidMessageContentExpressionFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__InvalidMessageContentExpressionFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__InvalidMessageContentExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__InvalidMessageContentExpressionFaultType, 0, sizeof(struct ns4__InvalidMessageContentExpressionFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__InvalidMessageContentExpressionFaultType(struct soap *soap, const struct ns4__InvalidMessageContentExpressionFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__InvalidMessageContentExpressionFaultType);
	if (soap_out_ns4__InvalidMessageContentExpressionFaultType(soap, tag?tag:"ns4:InvalidMessageContentExpressionFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_get_ns4__InvalidMessageContentExpressionFaultType(struct soap *soap, struct ns4__InvalidMessageContentExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct ns4__InvalidProducerPropertiesExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const struct ns4__InvalidProducerPropertiesExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, const struct ns4__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__InvalidProducerPropertiesExpressionFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_in_ns4__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, struct ns4__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__InvalidProducerPropertiesExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__InvalidProducerPropertiesExpressionFaultType, sizeof(struct ns4__InvalidProducerPropertiesExpressionFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__InvalidProducerPropertiesExpressionFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__InvalidProducerPropertiesExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__InvalidProducerPropertiesExpressionFaultType, 0, sizeof(struct ns4__InvalidProducerPropertiesExpressionFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const struct ns4__InvalidProducerPropertiesExpressionFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__InvalidProducerPropertiesExpressionFaultType);
	if (soap_out_ns4__InvalidProducerPropertiesExpressionFaultType(soap, tag?tag:"ns4:InvalidProducerPropertiesExpressionFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_get_ns4__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct ns4__InvalidProducerPropertiesExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct ns4__MultipleTopicsSpecifiedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__MultipleTopicsSpecifiedFaultType(struct soap *soap, const struct ns4__MultipleTopicsSpecifiedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, const struct ns4__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__MultipleTopicsSpecifiedFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_in_ns4__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, struct ns4__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__MultipleTopicsSpecifiedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__MultipleTopicsSpecifiedFaultType, sizeof(struct ns4__MultipleTopicsSpecifiedFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__MultipleTopicsSpecifiedFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__MultipleTopicsSpecifiedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__MultipleTopicsSpecifiedFaultType, 0, sizeof(struct ns4__MultipleTopicsSpecifiedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__MultipleTopicsSpecifiedFaultType(struct soap *soap, const struct ns4__MultipleTopicsSpecifiedFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__MultipleTopicsSpecifiedFaultType);
	if (soap_out_ns4__MultipleTopicsSpecifiedFaultType(soap, tag?tag:"ns4:MultipleTopicsSpecifiedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_get_ns4__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct ns4__MultipleTopicsSpecifiedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__TopicNotSupportedFaultType(struct soap *soap, struct ns4__TopicNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__TopicNotSupportedFaultType(struct soap *soap, const struct ns4__TopicNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, const struct ns4__TopicNotSupportedFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__TopicNotSupportedFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__TopicNotSupportedFaultType * SOAP_FMAC4 soap_in_ns4__TopicNotSupportedFaultType(struct soap *soap, const char *tag, struct ns4__TopicNotSupportedFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__TopicNotSupportedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__TopicNotSupportedFaultType, sizeof(struct ns4__TopicNotSupportedFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__TopicNotSupportedFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__TopicNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__TopicNotSupportedFaultType, 0, sizeof(struct ns4__TopicNotSupportedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__TopicNotSupportedFaultType(struct soap *soap, const struct ns4__TopicNotSupportedFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__TopicNotSupportedFaultType);
	if (soap_out_ns4__TopicNotSupportedFaultType(soap, tag?tag:"ns4:TopicNotSupportedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__TopicNotSupportedFaultType * SOAP_FMAC4 soap_get_ns4__TopicNotSupportedFaultType(struct soap *soap, struct ns4__TopicNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__InvalidTopicExpressionFaultType(struct soap *soap, struct ns4__InvalidTopicExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__InvalidTopicExpressionFaultType(struct soap *soap, const struct ns4__InvalidTopicExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, const struct ns4__InvalidTopicExpressionFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__InvalidTopicExpressionFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_ns4__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, struct ns4__InvalidTopicExpressionFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__InvalidTopicExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__InvalidTopicExpressionFaultType, sizeof(struct ns4__InvalidTopicExpressionFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__InvalidTopicExpressionFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__InvalidTopicExpressionFaultType, 0, sizeof(struct ns4__InvalidTopicExpressionFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__InvalidTopicExpressionFaultType(struct soap *soap, const struct ns4__InvalidTopicExpressionFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__InvalidTopicExpressionFaultType);
	if (soap_out_ns4__InvalidTopicExpressionFaultType(soap, tag?tag:"ns4:InvalidTopicExpressionFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_ns4__InvalidTopicExpressionFaultType(struct soap *soap, struct ns4__InvalidTopicExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct ns4__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct ns4__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const struct ns4__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__TopicExpressionDialectUnknownFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_ns4__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, struct ns4__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__TopicExpressionDialectUnknownFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__TopicExpressionDialectUnknownFaultType, sizeof(struct ns4__TopicExpressionDialectUnknownFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__TopicExpressionDialectUnknownFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__TopicExpressionDialectUnknownFaultType, 0, sizeof(struct ns4__TopicExpressionDialectUnknownFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct ns4__TopicExpressionDialectUnknownFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__TopicExpressionDialectUnknownFaultType);
	if (soap_out_ns4__TopicExpressionDialectUnknownFaultType(soap, tag?tag:"ns4:TopicExpressionDialectUnknownFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_ns4__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct ns4__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__InvalidFilterFaultType(struct soap *soap, struct ns4__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
	a->__sizeUnknownFilter = 0;
	a->UnknownFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__InvalidFilterFaultType(struct soap *soap, const struct ns4__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < a->__sizeUnknownFilter; i++)
		{
			soap_serialize__QName(soap, a->UnknownFilter + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const struct ns4__InvalidFilterFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__InvalidFilterFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < a->__sizeUnknownFilter; i++)
		{	const char *soap_tmp_UnknownFilter = soap_QName2s(soap, a->UnknownFilter[i]);
			if (soap_out__QName(soap, "ns4:UnknownFilter", -1, (char*const*)&soap_tmp_UnknownFilter, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__InvalidFilterFaultType * SOAP_FMAC4 soap_in_ns4__InvalidFilterFaultType(struct soap *soap, const char *tag, struct ns4__InvalidFilterFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	struct soap_blist *soap_blist_UnknownFilter = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__InvalidFilterFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__InvalidFilterFaultType, sizeof(struct ns4__InvalidFilterFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__InvalidFilterFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:UnknownFilter", 1, NULL))
			{	if (a->UnknownFilter == NULL)
				{	if (soap_blist_UnknownFilter == NULL)
						soap_blist_UnknownFilter = soap_new_block(soap);
					a->UnknownFilter = (char **)soap_push_block(soap, soap_blist_UnknownFilter, sizeof(char *));
					if (a->UnknownFilter == NULL)
						return NULL;
					*a->UnknownFilter = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "ns4:UnknownFilter", a->UnknownFilter, ""))
				{	a->__sizeUnknownFilter++;
					a->UnknownFilter = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (a->UnknownFilter)
			soap_pop_block(soap, soap_blist_UnknownFilter);
		if (a->__sizeUnknownFilter)
			a->UnknownFilter = (char **)soap_save_block(soap, soap_blist_UnknownFilter, NULL, 1);
		else
		{	a->UnknownFilter = NULL;
			if (soap_blist_UnknownFilter)
				soap_end_block(soap, soap_blist_UnknownFilter);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__InvalidFilterFaultType, 0, sizeof(struct ns4__InvalidFilterFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0 || a->__sizeUnknownFilter < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__InvalidFilterFaultType(struct soap *soap, const struct ns4__InvalidFilterFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__InvalidFilterFaultType);
	if (soap_out_ns4__InvalidFilterFaultType(soap, tag?tag:"ns4:InvalidFilterFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__InvalidFilterFaultType * SOAP_FMAC4 soap_get_ns4__InvalidFilterFaultType(struct soap *soap, struct ns4__InvalidFilterFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SubscribeCreationFailedFaultType(struct soap *soap, struct ns4__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->ns6__Timestamp);
	a->ns6__Originator = NULL;
	a->ns6__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->ns6__Description = NULL;
	a->ns6__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SubscribeCreationFailedFaultType(struct soap *soap, const struct ns4__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ns6__Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns6__Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ns6__ErrorCode);
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->ns6__Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->ns6__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const struct ns4__SubscribeCreationFailedFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SubscribeCreationFailedFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->ns6__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->ns6__Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ns6__ErrorCode, ""))
		return soap->error;
	if (a->ns6__Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->ns6__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->ns6__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_ns4__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, struct ns4__SubscribeCreationFailedFaultType *a, const char *type)
{
	size_t soap_flag_ns6__Timestamp = 1;
	size_t soap_flag_ns6__Originator = 1;
	size_t soap_flag_ns6__ErrorCode = 1;
	struct soap_blist *soap_blist_ns6__Description = NULL;
	size_t soap_flag_ns6__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SubscribeCreationFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SubscribeCreationFailedFaultType, sizeof(struct ns4__SubscribeCreationFailedFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SubscribeCreationFailedFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->ns6__Timestamp, "xsd:dateTime"))
				{	soap_flag_ns6__Timestamp--;
					continue;
				}
			if (soap_flag_ns6__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->ns6__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_ns6__Originator--;
					continue;
				}
			if (soap_flag_ns6__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ns6__ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ns6__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->ns6__Description == NULL)
				{	if (soap_blist_ns6__Description == NULL)
						soap_blist_ns6__Description = soap_new_block(soap);
					a->ns6__Description = (char **)soap_push_block(soap, soap_blist_ns6__Description, sizeof(char *));
					if (a->ns6__Description == NULL)
						return NULL;
					*a->ns6__Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->ns6__Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->ns6__Description = NULL;
					continue;
				}
			}
			if (soap_flag_ns6__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->ns6__FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_ns6__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns6__Description)
			soap_pop_block(soap, soap_blist_ns6__Description);
		if (a->__sizeDescription)
			a->ns6__Description = (char **)soap_save_block(soap, soap_blist_ns6__Description, NULL, 1);
		else
		{	a->ns6__Description = NULL;
			if (soap_blist_ns6__Description)
				soap_end_block(soap, soap_blist_ns6__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SubscribeCreationFailedFaultType, 0, sizeof(struct ns4__SubscribeCreationFailedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SubscribeCreationFailedFaultType(struct soap *soap, const struct ns4__SubscribeCreationFailedFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__SubscribeCreationFailedFaultType);
	if (soap_out_ns4__SubscribeCreationFailedFaultType(soap, tag?tag:"ns4:SubscribeCreationFailedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_ns4__SubscribeCreationFailedFaultType(struct soap *soap, struct ns4__SubscribeCreationFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__reservationResourceType_sequence(struct soap *soap, struct __ns1__reservationResourceType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->localDetails = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__reservationResourceType_sequence(struct soap *soap, const struct __ns1__reservationResourceType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__localDetails(soap, &a->localDetails);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__reservationResourceType_sequence(struct soap *soap, const char *tag, int id, const struct __ns1__reservationResourceType_sequence *a, const char *type)
{
	if (soap_out_PointerTons1__localDetails(soap, "ns1:localDetails", -1, &a->localDetails, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reservationResourceType_sequence * SOAP_FMAC4 soap_in___ns1__reservationResourceType_sequence(struct soap *soap, const char *tag, struct __ns1__reservationResourceType_sequence *a, const char *type)
{
	size_t soap_flag_localDetails = 1;
	short soap_flag;
	a = (struct __ns1__reservationResourceType_sequence *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__reservationResourceType_sequence, sizeof(struct __ns1__reservationResourceType_sequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__reservationResourceType_sequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_localDetails && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__localDetails(soap, "ns1:localDetails", &a->localDetails, "ns1:localDetails"))
				{	soap_flag_localDetails--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__reservationResourceType_sequence(struct soap *soap, const struct __ns1__reservationResourceType_sequence *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__reservationResourceType_sequence(soap, tag?tag:"-ns1:reservationResourceType-sequence", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reservationResourceType_sequence * SOAP_FMAC4 soap_get___ns1__reservationResourceType_sequence(struct soap *soap, struct __ns1__reservationResourceType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__reservationResourceType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__reservationResourceType(struct soap *soap, struct ns1__reservationResourceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->globalReservationId);
	soap_default_LONG64(soap, &a->startTime);
	soap_default_LONG64(soap, &a->endTime);
	soap_default_int(soap, &a->bandwidth);
	soap_default_string(soap, &a->description);
	a->pathInfo = NULL;
	a->__size_reservationResourceType_sequence = 0;
	a->__reservationResourceType_sequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__reservationResourceType(struct soap *soap, const struct ns1__reservationResourceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->globalReservationId);
	soap_embedded(soap, &a->bandwidth, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->description);
	soap_serialize_PointerTons1__pathInfo(soap, &a->pathInfo);
	if (a->__reservationResourceType_sequence)
	{	int i;
		for (i = 0; i < a->__size_reservationResourceType_sequence; i++)
		{
			soap_serialize___ns1__reservationResourceType_sequence(soap, a->__reservationResourceType_sequence + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__reservationResourceType(struct soap *soap, const char *tag, int id, const struct ns1__reservationResourceType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__reservationResourceType), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:endTime", -1, &a->endTime, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:bandwidth", -1, &a->bandwidth, ""))
		return soap->error;
	if (a->description)
	{	if (soap_out_string(soap, "ns1:description", -1, &a->description, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:description"))
		return soap->error;
	if (a->pathInfo)
	{	if (soap_out_PointerTons1__pathInfo(soap, "ns1:pathInfo", -1, &a->pathInfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:pathInfo"))
		return soap->error;
	if (a->__reservationResourceType_sequence)
	{	int i;
		for (i = 0; i < a->__size_reservationResourceType_sequence; i++)
			if (soap_out___ns1__reservationResourceType_sequence(soap, "-reservationResourceType-sequence", -1, a->__reservationResourceType_sequence + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__reservationResourceType * SOAP_FMAC4 soap_in_ns1__reservationResourceType(struct soap *soap, const char *tag, struct ns1__reservationResourceType *a, const char *type)
{
	size_t soap_flag_globalReservationId = 1;
	size_t soap_flag_startTime = 1;
	size_t soap_flag_endTime = 1;
	size_t soap_flag_bandwidth = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_pathInfo = 1;
	struct soap_blist *soap_blist___reservationResourceType_sequence = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__reservationResourceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__reservationResourceType, sizeof(struct ns1__reservationResourceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__reservationResourceType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string"))
				{	soap_flag_globalReservationId--;
					continue;
				}
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:startTime", &a->startTime, "xsd:long"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:endTime", &a->endTime, "xsd:long"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap_flag_bandwidth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:bandwidth", &a->bandwidth, "xsd:int"))
				{	soap_flag_bandwidth--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_pathInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__pathInfo(soap, "ns1:pathInfo", &a->pathInfo, "ns1:pathInfo"))
				{	soap_flag_pathInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__reservationResourceType_sequence == NULL)
				{	if (soap_blist___reservationResourceType_sequence == NULL)
						soap_blist___reservationResourceType_sequence = soap_new_block(soap);
					a->__reservationResourceType_sequence = (struct __ns1__reservationResourceType_sequence *)soap_push_block(soap, soap_blist___reservationResourceType_sequence, sizeof(struct __ns1__reservationResourceType_sequence));
					if (a->__reservationResourceType_sequence == NULL)
						return NULL;
					soap_default___ns1__reservationResourceType_sequence(soap, a->__reservationResourceType_sequence);
				}
				if (soap_in___ns1__reservationResourceType_sequence(soap, "-reservationResourceType-sequence", a->__reservationResourceType_sequence, "-ns1:reservationResourceType-sequence"))
				{	a->__size_reservationResourceType_sequence++;
					a->__reservationResourceType_sequence = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__reservationResourceType_sequence)
			soap_pop_block(soap, soap_blist___reservationResourceType_sequence);
		if (a->__size_reservationResourceType_sequence)
			a->__reservationResourceType_sequence = (struct __ns1__reservationResourceType_sequence *)soap_save_block(soap, soap_blist___reservationResourceType_sequence, NULL, 1);
		else
		{	a->__reservationResourceType_sequence = NULL;
			if (soap_blist___reservationResourceType_sequence)
				soap_end_block(soap, soap_blist___reservationResourceType_sequence);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__reservationResourceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__reservationResourceType, 0, sizeof(struct ns1__reservationResourceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0 || soap_flag_endTime > 0 || soap_flag_bandwidth > 0 || soap_flag_description > 0 || soap_flag_pathInfo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__reservationResourceType(struct soap *soap, const struct ns1__reservationResourceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__reservationResourceType);
	if (soap_out_ns1__reservationResourceType(soap, tag?tag:"ns1:reservationResourceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__reservationResourceType * SOAP_FMAC4 soap_get_ns1__reservationResourceType(struct soap *soap, struct ns1__reservationResourceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__reservationResourceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__FaultCauseType(struct soap *soap, struct ns6__FaultCauseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->dialect);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__FaultCauseType(struct soap *soap, const struct ns6__FaultCauseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__FaultCauseType(struct soap *soap, const char *tag, int id, const struct ns6__FaultCauseType *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", a->dialect, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns6__FaultCauseType * SOAP_FMAC4 soap_in_ns6__FaultCauseType(struct soap *soap, const char *tag, struct ns6__FaultCauseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct ns6__FaultCauseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__FaultCauseType, sizeof(struct ns6__FaultCauseType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_ns6__FaultCauseType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "dialect", 0), &a->dialect, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "ns6:FaultCauseType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__FaultCauseType(struct soap *soap, const struct ns6__FaultCauseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__FaultCauseType);
	if (soap_out_ns6__FaultCauseType(soap, tag?tag:"ns6:FaultCauseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__FaultCauseType * SOAP_FMAC4 soap_get_ns6__FaultCauseType(struct soap *soap, struct ns6__FaultCauseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__FaultCauseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ErrorCodeType(struct soap *soap, struct ns6__ErrorCodeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->dialect);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__ErrorCodeType(struct soap *soap, const struct ns6__ErrorCodeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ErrorCodeType(struct soap *soap, const char *tag, int id, const struct ns6__ErrorCodeType *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", a->dialect, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns6__ErrorCodeType * SOAP_FMAC4 soap_in_ns6__ErrorCodeType(struct soap *soap, const char *tag, struct ns6__ErrorCodeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct ns6__ErrorCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ErrorCodeType, sizeof(struct ns6__ErrorCodeType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_ns6__ErrorCodeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "dialect", 1), &a->dialect, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "ns6:ErrorCodeType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ErrorCodeType(struct soap *soap, const struct ns6__ErrorCodeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ErrorCodeType);
	if (soap_out_ns6__ErrorCodeType(soap, tag?tag:"ns6:ErrorCodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__ErrorCodeType * SOAP_FMAC4 soap_get_ns6__ErrorCodeType(struct soap *soap, struct ns6__ErrorCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ErrorCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__BaseFaultType(struct soap *soap, struct ns6__BaseFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->Timestamp);
	a->Originator = NULL;
	a->ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->Description = NULL;
	a->FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__BaseFaultType(struct soap *soap, const struct ns6__BaseFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->Originator);
	soap_serialize_PointerTons6__ErrorCodeType(soap, &a->ErrorCode);
	if (a->Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_serialize_string(soap, a->Description + i);
		}
	}
	soap_serialize_PointerTons6__FaultCauseType(soap, &a->FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__BaseFaultType(struct soap *soap, const char *tag, int id, const struct ns6__BaseFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__BaseFaultType), type))
		return soap->error;
	if (soap_out_time(soap, "ns6:Timestamp", -1, &a->Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", -1, &a->Originator, ""))
		return soap->error;
	if (soap_out_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", -1, &a->ErrorCode, ""))
		return soap->error;
	if (a->Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out_string(soap, "ns6:Description", -1, a->Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", -1, &a->FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__BaseFaultType * SOAP_FMAC4 soap_in_ns6__BaseFaultType(struct soap *soap, const char *tag, struct ns6__BaseFaultType *a, const char *type)
{
	size_t soap_flag_Timestamp = 1;
	size_t soap_flag_Originator = 1;
	size_t soap_flag_ErrorCode = 1;
	struct soap_blist *soap_blist_Description = NULL;
	size_t soap_flag_FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__BaseFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__BaseFaultType, sizeof(struct ns6__BaseFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__BaseFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns6:Timestamp", &a->Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp--;
					continue;
				}
			if (soap_flag_Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns6:Originator", &a->Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator--;
					continue;
				}
			if (soap_flag_ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ErrorCodeType(soap, "ns6:ErrorCode", &a->ErrorCode, "ns6:ErrorCodeType"))
				{	soap_flag_ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Description", 1, NULL))
			{	if (a->Description == NULL)
				{	if (soap_blist_Description == NULL)
						soap_blist_Description = soap_new_block(soap);
					a->Description = (char **)soap_push_block(soap, soap_blist_Description, sizeof(char *));
					if (a->Description == NULL)
						return NULL;
					*a->Description = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Description", a->Description, "xsd:string"))
				{	a->__sizeDescription++;
					a->Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__FaultCauseType(soap, "ns6:FaultCause", &a->FaultCause, "ns6:FaultCauseType"))
				{	soap_flag_FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Description)
			soap_pop_block(soap, soap_blist_Description);
		if (a->__sizeDescription)
			a->Description = (char **)soap_save_block(soap, soap_blist_Description, NULL, 1);
		else
		{	a->Description = NULL;
			if (soap_blist_Description)
				soap_end_block(soap, soap_blist_Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__BaseFaultType, 0, sizeof(struct ns6__BaseFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__BaseFaultType(struct soap *soap, const struct ns6__BaseFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__BaseFaultType);
	if (soap_out_ns6__BaseFaultType(soap, tag?tag:"ns6:BaseFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__BaseFaultType * SOAP_FMAC4 soap_get_ns6__BaseFaultType(struct soap *soap, struct ns6__BaseFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__ResumeSubscriptionResponse(struct soap *soap, struct _ns4__ResumeSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SubscriptionReference = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__ResumeSubscriptionResponse(struct soap *soap, const struct _ns4__ResumeSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _ns4__ResumeSubscriptionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__ResumeSubscriptionResponse), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__ResumeSubscriptionResponse * SOAP_FMAC4 soap_in__ns4__ResumeSubscriptionResponse(struct soap *soap, const char *tag, struct _ns4__ResumeSubscriptionResponse *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__ResumeSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__ResumeSubscriptionResponse, sizeof(struct _ns4__ResumeSubscriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__ResumeSubscriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__ResumeSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__ResumeSubscriptionResponse, 0, sizeof(struct _ns4__ResumeSubscriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__ResumeSubscriptionResponse(struct soap *soap, const struct _ns4__ResumeSubscriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__ResumeSubscriptionResponse);
	if (soap_out__ns4__ResumeSubscriptionResponse(soap, tag?tag:"ns4:ResumeSubscriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__ResumeSubscriptionResponse * SOAP_FMAC4 soap_get__ns4__ResumeSubscriptionResponse(struct soap *soap, struct _ns4__ResumeSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__ResumeSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__ResumeSubscription(struct soap *soap, struct _ns4__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__ResumeSubscription(struct soap *soap, const struct _ns4__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__ResumeSubscription(struct soap *soap, const char *tag, int id, const struct _ns4__ResumeSubscription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__ResumeSubscription), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__ResumeSubscription * SOAP_FMAC4 soap_in__ns4__ResumeSubscription(struct soap *soap, const char *tag, struct _ns4__ResumeSubscription *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__ResumeSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__ResumeSubscription, sizeof(struct _ns4__ResumeSubscription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__ResumeSubscription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__ResumeSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__ResumeSubscription, 0, sizeof(struct _ns4__ResumeSubscription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__ResumeSubscription(struct soap *soap, const struct _ns4__ResumeSubscription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__ResumeSubscription);
	if (soap_out__ns4__ResumeSubscription(soap, tag?tag:"ns4:ResumeSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__ResumeSubscription * SOAP_FMAC4 soap_get__ns4__ResumeSubscription(struct soap *soap, struct _ns4__ResumeSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__PauseSubscriptionResponse(struct soap *soap, struct _ns4__PauseSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SubscriptionReference = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__PauseSubscriptionResponse(struct soap *soap, const struct _ns4__PauseSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _ns4__PauseSubscriptionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__PauseSubscriptionResponse), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__PauseSubscriptionResponse * SOAP_FMAC4 soap_in__ns4__PauseSubscriptionResponse(struct soap *soap, const char *tag, struct _ns4__PauseSubscriptionResponse *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__PauseSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__PauseSubscriptionResponse, sizeof(struct _ns4__PauseSubscriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__PauseSubscriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__PauseSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__PauseSubscriptionResponse, 0, sizeof(struct _ns4__PauseSubscriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__PauseSubscriptionResponse(struct soap *soap, const struct _ns4__PauseSubscriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__PauseSubscriptionResponse);
	if (soap_out__ns4__PauseSubscriptionResponse(soap, tag?tag:"ns4:PauseSubscriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__PauseSubscriptionResponse * SOAP_FMAC4 soap_get__ns4__PauseSubscriptionResponse(struct soap *soap, struct _ns4__PauseSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__PauseSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__PauseSubscription(struct soap *soap, struct _ns4__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__PauseSubscription(struct soap *soap, const struct _ns4__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__PauseSubscription(struct soap *soap, const char *tag, int id, const struct _ns4__PauseSubscription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__PauseSubscription), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__PauseSubscription * SOAP_FMAC4 soap_in__ns4__PauseSubscription(struct soap *soap, const char *tag, struct _ns4__PauseSubscription *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__PauseSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__PauseSubscription, sizeof(struct _ns4__PauseSubscription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__PauseSubscription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__PauseSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__PauseSubscription, 0, sizeof(struct _ns4__PauseSubscription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__PauseSubscription(struct soap *soap, const struct _ns4__PauseSubscription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__PauseSubscription);
	if (soap_out__ns4__PauseSubscription(soap, tag?tag:"ns4:PauseSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__PauseSubscription * SOAP_FMAC4 soap_get__ns4__PauseSubscription(struct soap *soap, struct _ns4__PauseSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__UnsubscribeResponse(struct soap *soap, struct _ns4__UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SubscriptionReference = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__UnsubscribeResponse(struct soap *soap, const struct _ns4__UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__UnsubscribeResponse(struct soap *soap, const char *tag, int id, const struct _ns4__UnsubscribeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__UnsubscribeResponse), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__UnsubscribeResponse * SOAP_FMAC4 soap_in__ns4__UnsubscribeResponse(struct soap *soap, const char *tag, struct _ns4__UnsubscribeResponse *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__UnsubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__UnsubscribeResponse, sizeof(struct _ns4__UnsubscribeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__UnsubscribeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__UnsubscribeResponse, 0, sizeof(struct _ns4__UnsubscribeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__UnsubscribeResponse(struct soap *soap, const struct _ns4__UnsubscribeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__UnsubscribeResponse);
	if (soap_out__ns4__UnsubscribeResponse(soap, tag?tag:"ns4:UnsubscribeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__UnsubscribeResponse * SOAP_FMAC4 soap_get__ns4__UnsubscribeResponse(struct soap *soap, struct _ns4__UnsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__Unsubscribe(struct soap *soap, struct _ns4__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__Unsubscribe(struct soap *soap, const struct _ns4__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__Unsubscribe(struct soap *soap, const char *tag, int id, const struct _ns4__Unsubscribe *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__Unsubscribe), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__Unsubscribe * SOAP_FMAC4 soap_in__ns4__Unsubscribe(struct soap *soap, const char *tag, struct _ns4__Unsubscribe *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__Unsubscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__Unsubscribe, sizeof(struct _ns4__Unsubscribe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__Unsubscribe(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__Unsubscribe, 0, sizeof(struct _ns4__Unsubscribe), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__Unsubscribe(struct soap *soap, const struct _ns4__Unsubscribe *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__Unsubscribe);
	if (soap_out__ns4__Unsubscribe(soap, tag?tag:"ns4:Unsubscribe", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__Unsubscribe * SOAP_FMAC4 soap_get__ns4__Unsubscribe(struct soap *soap, struct _ns4__Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__RenewResponse(struct soap *soap, struct _ns4__RenewResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->TerminationTime);
	a->CurrentTime = NULL;
	a->SubscriptionReference = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__RenewResponse(struct soap *soap, const struct _ns4__RenewResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->TerminationTime, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &a->CurrentTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__RenewResponse(struct soap *soap, const char *tag, int id, const struct _ns4__RenewResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__RenewResponse), type))
		return soap->error;
	if (soap_out_time(soap, "ns4:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns4:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__RenewResponse * SOAP_FMAC4 soap_in__ns4__RenewResponse(struct soap *soap, const char *tag, struct _ns4__RenewResponse *a, const char *type)
{
	size_t soap_flag_TerminationTime = 1;
	size_t soap_flag_CurrentTime = 1;
	size_t soap_flag_SubscriptionReference = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__RenewResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__RenewResponse, sizeof(struct _ns4__RenewResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__RenewResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns4:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__RenewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__RenewResponse, 0, sizeof(struct _ns4__RenewResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__RenewResponse(struct soap *soap, const struct _ns4__RenewResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__RenewResponse);
	if (soap_out__ns4__RenewResponse(soap, tag?tag:"ns4:RenewResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__RenewResponse * SOAP_FMAC4 soap_get__ns4__RenewResponse(struct soap *soap, struct _ns4__RenewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__RenewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__Renew(struct soap *soap, struct _ns4__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->TerminationTime);
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__Renew(struct soap *soap, const struct _ns4__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->TerminationTime);
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__Renew(struct soap *soap, const char *tag, int id, const struct _ns4__Renew *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__Renew), type))
		return soap->error;
	if (a->TerminationTime)
	{	if (soap_out_string(soap, "ns4:TerminationTime", -1, &a->TerminationTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns4:TerminationTime"))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__Renew * SOAP_FMAC4 soap_in__ns4__Renew(struct soap *soap, const char *tag, struct _ns4__Renew *a, const char *type)
{
	size_t soap_flag_TerminationTime = 1;
	size_t soap_flag_SubscriptionReference = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__Renew *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__Renew, sizeof(struct _ns4__Renew), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__Renew(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TerminationTime", &a->TerminationTime, "xsd:string"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__Renew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__Renew, 0, sizeof(struct _ns4__Renew), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0 || soap_flag_SubscriptionReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__Renew(struct soap *soap, const struct _ns4__Renew *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__Renew);
	if (soap_out__ns4__Renew(soap, tag?tag:"ns4:Renew", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__Renew * SOAP_FMAC4 soap_get__ns4__Renew(struct soap *soap, struct _ns4__Renew *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__CreatePullPointResponse(struct soap *soap, struct _ns4__CreatePullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->PullPoint);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__CreatePullPointResponse(struct soap *soap, const struct _ns4__CreatePullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->PullPoint, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->PullPoint);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__CreatePullPointResponse(struct soap *soap, const char *tag, int id, const struct _ns4__CreatePullPointResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__CreatePullPointResponse), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "ns4:PullPoint", -1, &a->PullPoint, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__CreatePullPointResponse * SOAP_FMAC4 soap_in__ns4__CreatePullPointResponse(struct soap *soap, const char *tag, struct _ns4__CreatePullPointResponse *a, const char *type)
{
	size_t soap_flag_PullPoint = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__CreatePullPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__CreatePullPointResponse, sizeof(struct _ns4__CreatePullPointResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__CreatePullPointResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PullPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "ns4:PullPoint", &a->PullPoint, "wsa5:EndpointReferenceType"))
				{	soap_flag_PullPoint--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__CreatePullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__CreatePullPointResponse, 0, sizeof(struct _ns4__CreatePullPointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PullPoint > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__CreatePullPointResponse(struct soap *soap, const struct _ns4__CreatePullPointResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__CreatePullPointResponse);
	if (soap_out__ns4__CreatePullPointResponse(soap, tag?tag:"ns4:CreatePullPointResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__CreatePullPointResponse * SOAP_FMAC4 soap_get__ns4__CreatePullPointResponse(struct soap *soap, struct _ns4__CreatePullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__CreatePullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__CreatePullPoint(struct soap *soap, struct _ns4__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__CreatePullPoint(struct soap *soap, const struct _ns4__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__CreatePullPoint(struct soap *soap, const char *tag, int id, const struct _ns4__CreatePullPoint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__CreatePullPoint), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__CreatePullPoint * SOAP_FMAC4 soap_in__ns4__CreatePullPoint(struct soap *soap, const char *tag, struct _ns4__CreatePullPoint *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__CreatePullPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__CreatePullPoint, sizeof(struct _ns4__CreatePullPoint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__CreatePullPoint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__CreatePullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__CreatePullPoint, 0, sizeof(struct _ns4__CreatePullPoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__CreatePullPoint(struct soap *soap, const struct _ns4__CreatePullPoint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__CreatePullPoint);
	if (soap_out__ns4__CreatePullPoint(soap, tag?tag:"ns4:CreatePullPoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__CreatePullPoint * SOAP_FMAC4 soap_get__ns4__CreatePullPoint(struct soap *soap, struct _ns4__CreatePullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__DestroyPullPointResponse(struct soap *soap, struct _ns4__DestroyPullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__DestroyPullPointResponse(struct soap *soap, const struct _ns4__DestroyPullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, const struct _ns4__DestroyPullPointResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__DestroyPullPointResponse), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__DestroyPullPointResponse * SOAP_FMAC4 soap_in__ns4__DestroyPullPointResponse(struct soap *soap, const char *tag, struct _ns4__DestroyPullPointResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__DestroyPullPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__DestroyPullPointResponse, sizeof(struct _ns4__DestroyPullPointResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__DestroyPullPointResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__DestroyPullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__DestroyPullPointResponse, 0, sizeof(struct _ns4__DestroyPullPointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__DestroyPullPointResponse(struct soap *soap, const struct _ns4__DestroyPullPointResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__DestroyPullPointResponse);
	if (soap_out__ns4__DestroyPullPointResponse(soap, tag?tag:"ns4:DestroyPullPointResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__DestroyPullPointResponse * SOAP_FMAC4 soap_get__ns4__DestroyPullPointResponse(struct soap *soap, struct _ns4__DestroyPullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__DestroyPullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__DestroyPullPoint(struct soap *soap, struct _ns4__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__DestroyPullPoint(struct soap *soap, const struct _ns4__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__DestroyPullPoint(struct soap *soap, const char *tag, int id, const struct _ns4__DestroyPullPoint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__DestroyPullPoint), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__DestroyPullPoint * SOAP_FMAC4 soap_in__ns4__DestroyPullPoint(struct soap *soap, const char *tag, struct _ns4__DestroyPullPoint *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__DestroyPullPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__DestroyPullPoint, sizeof(struct _ns4__DestroyPullPoint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__DestroyPullPoint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__DestroyPullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__DestroyPullPoint, 0, sizeof(struct _ns4__DestroyPullPoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__DestroyPullPoint(struct soap *soap, const struct _ns4__DestroyPullPoint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__DestroyPullPoint);
	if (soap_out__ns4__DestroyPullPoint(soap, tag?tag:"ns4:DestroyPullPoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__DestroyPullPoint * SOAP_FMAC4 soap_get__ns4__DestroyPullPoint(struct soap *soap, struct _ns4__DestroyPullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__GetMessagesResponse(struct soap *soap, struct _ns4__GetMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNotificationMessage = 0;
	a->NotificationMessage = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__GetMessagesResponse(struct soap *soap, const struct _ns4__GetMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NotificationMessage)
	{	int i;
		for (i = 0; i < a->__sizeNotificationMessage; i++)
		{
			soap_serialize_PointerTons4__NotificationMessageHolderType(soap, a->NotificationMessage + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetMessagesResponse(struct soap *soap, const char *tag, int id, const struct _ns4__GetMessagesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__GetMessagesResponse), type))
		return soap->error;
	if (a->NotificationMessage)
	{	int i;
		for (i = 0; i < a->__sizeNotificationMessage; i++)
			if (soap_out_PointerTons4__NotificationMessageHolderType(soap, "ns4:NotificationMessage", -1, a->NotificationMessage + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__GetMessagesResponse * SOAP_FMAC4 soap_in__ns4__GetMessagesResponse(struct soap *soap, const char *tag, struct _ns4__GetMessagesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NotificationMessage = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__GetMessagesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetMessagesResponse, sizeof(struct _ns4__GetMessagesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__GetMessagesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:NotificationMessage", 1, NULL))
			{	if (a->NotificationMessage == NULL)
				{	if (soap_blist_NotificationMessage == NULL)
						soap_blist_NotificationMessage = soap_new_block(soap);
					a->NotificationMessage = (struct ns4__NotificationMessageHolderType **)soap_push_block(soap, soap_blist_NotificationMessage, sizeof(struct ns4__NotificationMessageHolderType *));
					if (a->NotificationMessage == NULL)
						return NULL;
					*a->NotificationMessage = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons4__NotificationMessageHolderType(soap, "ns4:NotificationMessage", a->NotificationMessage, "ns4:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->NotificationMessage = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NotificationMessage)
			soap_pop_block(soap, soap_blist_NotificationMessage);
		if (a->__sizeNotificationMessage)
			a->NotificationMessage = (struct ns4__NotificationMessageHolderType **)soap_save_block(soap, soap_blist_NotificationMessage, NULL, 1);
		else
		{	a->NotificationMessage = NULL;
			if (soap_blist_NotificationMessage)
				soap_end_block(soap, soap_blist_NotificationMessage);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__GetMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetMessagesResponse, 0, sizeof(struct _ns4__GetMessagesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__GetMessagesResponse(struct soap *soap, const struct _ns4__GetMessagesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__GetMessagesResponse);
	if (soap_out__ns4__GetMessagesResponse(soap, tag?tag:"ns4:GetMessagesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__GetMessagesResponse * SOAP_FMAC4 soap_get__ns4__GetMessagesResponse(struct soap *soap, struct _ns4__GetMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__GetMessages(struct soap *soap, struct _ns4__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MaximumNumber = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__GetMessages(struct soap *soap, const struct _ns4__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTounsignedInt(soap, &a->MaximumNumber);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetMessages(struct soap *soap, const char *tag, int id, const struct _ns4__GetMessages *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__GetMessages), type))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "ns4:MaximumNumber", -1, &a->MaximumNumber, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__GetMessages * SOAP_FMAC4 soap_in__ns4__GetMessages(struct soap *soap, const char *tag, struct _ns4__GetMessages *a, const char *type)
{
	size_t soap_flag_MaximumNumber = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__GetMessages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetMessages, sizeof(struct _ns4__GetMessages), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__GetMessages(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "ns4:MaximumNumber", &a->MaximumNumber, "xsd:unsignedInt"))
				{	soap_flag_MaximumNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__GetMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetMessages, 0, sizeof(struct _ns4__GetMessages), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__GetMessages(struct soap *soap, const struct _ns4__GetMessages *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__GetMessages);
	if (soap_out__ns4__GetMessages(soap, tag?tag:"ns4:GetMessages", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__GetMessages * SOAP_FMAC4 soap_get__ns4__GetMessages(struct soap *soap, struct _ns4__GetMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__GetCurrentMessageResponse(struct soap *soap, struct _ns4__GetCurrentMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__GetCurrentMessageResponse(struct soap *soap, const struct _ns4__GetCurrentMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, const struct _ns4__GetCurrentMessageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__GetCurrentMessageResponse), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__GetCurrentMessageResponse * SOAP_FMAC4 soap_in__ns4__GetCurrentMessageResponse(struct soap *soap, const char *tag, struct _ns4__GetCurrentMessageResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__GetCurrentMessageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetCurrentMessageResponse, sizeof(struct _ns4__GetCurrentMessageResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__GetCurrentMessageResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__GetCurrentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetCurrentMessageResponse, 0, sizeof(struct _ns4__GetCurrentMessageResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__GetCurrentMessageResponse(struct soap *soap, const struct _ns4__GetCurrentMessageResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__GetCurrentMessageResponse);
	if (soap_out__ns4__GetCurrentMessageResponse(soap, tag?tag:"ns4:GetCurrentMessageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__GetCurrentMessageResponse * SOAP_FMAC4 soap_get__ns4__GetCurrentMessageResponse(struct soap *soap, struct _ns4__GetCurrentMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetCurrentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__GetCurrentMessage(struct soap *soap, struct _ns4__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__GetCurrentMessage(struct soap *soap, const struct _ns4__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TopicExpressionType(soap, &a->Topic);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetCurrentMessage(struct soap *soap, const char *tag, int id, const struct _ns4__GetCurrentMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__GetCurrentMessage), type))
		return soap->error;
	if (a->Topic)
	{	if (soap_out_PointerTons4__TopicExpressionType(soap, "ns4:Topic", -1, &a->Topic, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns4:Topic"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__GetCurrentMessage * SOAP_FMAC4 soap_in__ns4__GetCurrentMessage(struct soap *soap, const char *tag, struct _ns4__GetCurrentMessage *a, const char *type)
{
	size_t soap_flag_Topic = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__GetCurrentMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetCurrentMessage, sizeof(struct _ns4__GetCurrentMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__GetCurrentMessage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TopicExpressionType(soap, "ns4:Topic", &a->Topic, "ns4:TopicExpressionType"))
				{	soap_flag_Topic--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__GetCurrentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetCurrentMessage, 0, sizeof(struct _ns4__GetCurrentMessage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Topic > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__GetCurrentMessage(struct soap *soap, const struct _ns4__GetCurrentMessage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__GetCurrentMessage);
	if (soap_out__ns4__GetCurrentMessage(soap, tag?tag:"ns4:GetCurrentMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__GetCurrentMessage * SOAP_FMAC4 soap_get__ns4__GetCurrentMessage(struct soap *soap, struct _ns4__GetCurrentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__SubscribeResponse(struct soap *soap, struct _ns4__SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	a->CurrentTime = NULL;
	a->TerminationTime = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__SubscribeResponse(struct soap *soap, const struct _ns4__SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_serialize_PointerTotime(soap, &a->CurrentTime);
	soap_serialize_PointerTotime(soap, &a->TerminationTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__SubscribeResponse(struct soap *soap, const char *tag, int id, const struct _ns4__SubscribeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__SubscribeResponse), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns4:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns4:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__SubscribeResponse * SOAP_FMAC4 soap_in__ns4__SubscribeResponse(struct soap *soap, const char *tag, struct _ns4__SubscribeResponse *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_CurrentTime = 1;
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__SubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__SubscribeResponse, sizeof(struct _ns4__SubscribeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__SubscribeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__SubscribeResponse, 0, sizeof(struct _ns4__SubscribeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__SubscribeResponse(struct soap *soap, const struct _ns4__SubscribeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__SubscribeResponse);
	if (soap_out__ns4__SubscribeResponse(soap, tag?tag:"ns4:SubscribeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__SubscribeResponse * SOAP_FMAC4 soap_get__ns4__SubscribeResponse(struct soap *soap, struct _ns4__SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__Subscribe_SubscriptionPolicy(struct soap *soap, struct _ns4__Subscribe_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__Subscribe_SubscriptionPolicy(struct soap *soap, const struct _ns4__Subscribe_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _ns4__Subscribe_SubscriptionPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__Subscribe_SubscriptionPolicy), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_in__ns4__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _ns4__Subscribe_SubscriptionPolicy *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__Subscribe_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__Subscribe_SubscriptionPolicy, sizeof(struct _ns4__Subscribe_SubscriptionPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__Subscribe_SubscriptionPolicy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__Subscribe_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__Subscribe_SubscriptionPolicy, 0, sizeof(struct _ns4__Subscribe_SubscriptionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__Subscribe_SubscriptionPolicy(struct soap *soap, const struct _ns4__Subscribe_SubscriptionPolicy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__Subscribe_SubscriptionPolicy);
	if (soap_out__ns4__Subscribe_SubscriptionPolicy(soap, tag?tag:"ns4:Subscribe-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_get__ns4__Subscribe_SubscriptionPolicy(struct soap *soap, struct _ns4__Subscribe_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__Subscribe(struct soap *soap, struct _ns4__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	a->Filter = NULL;
	soap_default_string(soap, &a->InitialTerminationTime);
	a->SubscriptionPolicy = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__Subscribe(struct soap *soap, const struct _ns4__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	soap_serialize_PointerTons4__FilterType(soap, &a->Filter);
	soap_serialize_string(soap, &a->InitialTerminationTime);
	soap_serialize_PointerTo_ns4__Subscribe_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__Subscribe(struct soap *soap, const char *tag, int id, const struct _ns4__Subscribe *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__Subscribe), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "ns4:ConsumerReference", -1, &a->ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTons4__FilterType(soap, "ns4:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:InitialTerminationTime", -1, &a->InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_ns4__Subscribe_SubscriptionPolicy(soap, "ns4:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__Subscribe * SOAP_FMAC4 soap_in__ns4__Subscribe(struct soap *soap, const char *tag, struct _ns4__Subscribe *a, const char *type)
{
	size_t soap_flag_ConsumerReference = 1;
	size_t soap_flag_Filter = 1;
	size_t soap_flag_InitialTerminationTime = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__Subscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__Subscribe, sizeof(struct _ns4__Subscribe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__Subscribe(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "ns4:ConsumerReference", &a->ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference--;
					continue;
				}
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FilterType(soap, "ns4:Filter", &a->Filter, "ns4:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			if (soap_flag_InitialTerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:InitialTerminationTime", &a->InitialTerminationTime, "xsd:string"))
				{	soap_flag_InitialTerminationTime--;
					continue;
				}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__Subscribe_SubscriptionPolicy(soap, "ns4:SubscriptionPolicy", &a->SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__Subscribe, 0, sizeof(struct _ns4__Subscribe), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__Subscribe(struct soap *soap, const struct _ns4__Subscribe *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__Subscribe);
	if (soap_out__ns4__Subscribe(soap, tag?tag:"ns4:Subscribe", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__Subscribe * SOAP_FMAC4 soap_get__ns4__Subscribe(struct soap *soap, struct _ns4__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__UseRaw(struct soap *soap, struct _ns4__UseRaw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__UseRaw(struct soap *soap, const struct _ns4__UseRaw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__UseRaw(struct soap *soap, const char *tag, int id, const struct _ns4__UseRaw *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__UseRaw), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__UseRaw * SOAP_FMAC4 soap_in__ns4__UseRaw(struct soap *soap, const char *tag, struct _ns4__UseRaw *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__UseRaw *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__UseRaw, sizeof(struct _ns4__UseRaw), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__UseRaw(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__UseRaw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__UseRaw, 0, sizeof(struct _ns4__UseRaw), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__UseRaw(struct soap *soap, const struct _ns4__UseRaw *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__UseRaw);
	if (soap_out__ns4__UseRaw(soap, tag?tag:"ns4:UseRaw", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__UseRaw * SOAP_FMAC4 soap_get__ns4__UseRaw(struct soap *soap, struct _ns4__UseRaw *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__UseRaw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__Notify(struct soap *soap, struct _ns4__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNotificationMessage = 0;
	a->NotificationMessage = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__Notify(struct soap *soap, const struct _ns4__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NotificationMessage)
	{	int i;
		for (i = 0; i < a->__sizeNotificationMessage; i++)
		{
			soap_serialize_PointerTons4__NotificationMessageHolderType(soap, a->NotificationMessage + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__Notify(struct soap *soap, const char *tag, int id, const struct _ns4__Notify *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__Notify), type))
		return soap->error;
	if (a->NotificationMessage)
	{	int i;
		for (i = 0; i < a->__sizeNotificationMessage; i++)
			if (soap_out_PointerTons4__NotificationMessageHolderType(soap, "ns4:NotificationMessage", -1, a->NotificationMessage + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__Notify * SOAP_FMAC4 soap_in__ns4__Notify(struct soap *soap, const char *tag, struct _ns4__Notify *a, const char *type)
{
	struct soap_blist *soap_blist_NotificationMessage = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__Notify *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__Notify, sizeof(struct _ns4__Notify), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__Notify(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:NotificationMessage", 1, NULL))
			{	if (a->NotificationMessage == NULL)
				{	if (soap_blist_NotificationMessage == NULL)
						soap_blist_NotificationMessage = soap_new_block(soap);
					a->NotificationMessage = (struct ns4__NotificationMessageHolderType **)soap_push_block(soap, soap_blist_NotificationMessage, sizeof(struct ns4__NotificationMessageHolderType *));
					if (a->NotificationMessage == NULL)
						return NULL;
					*a->NotificationMessage = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons4__NotificationMessageHolderType(soap, "ns4:NotificationMessage", a->NotificationMessage, "ns4:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->NotificationMessage = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NotificationMessage)
			soap_pop_block(soap, soap_blist_NotificationMessage);
		if (a->__sizeNotificationMessage)
			a->NotificationMessage = (struct ns4__NotificationMessageHolderType **)soap_save_block(soap, soap_blist_NotificationMessage, NULL, 1);
		else
		{	a->NotificationMessage = NULL;
			if (soap_blist_NotificationMessage)
				soap_end_block(soap, soap_blist_NotificationMessage);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__Notify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__Notify, 0, sizeof(struct _ns4__Notify), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNotificationMessage < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__Notify(struct soap *soap, const struct _ns4__Notify *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__Notify);
	if (soap_out__ns4__Notify(soap, tag?tag:"ns4:Notify", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__Notify * SOAP_FMAC4 soap_get__ns4__Notify(struct soap *soap, struct _ns4__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__SubscriptionManagerRP(struct soap *soap, struct _ns4__SubscriptionManagerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	a->Filter = NULL;
	a->SubscriptionPolicy = NULL;
	a->CreationTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__SubscriptionManagerRP(struct soap *soap, const struct _ns4__SubscriptionManagerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	soap_serialize_PointerTons4__FilterType(soap, &a->Filter);
	soap_serialize_PointerTons4__SubscriptionPolicyType(soap, &a->SubscriptionPolicy);
	soap_serialize_PointerTotime(soap, &a->CreationTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__SubscriptionManagerRP(struct soap *soap, const char *tag, int id, const struct _ns4__SubscriptionManagerRP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__SubscriptionManagerRP), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "ns4:ConsumerReference", -1, &a->ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTons4__FilterType(soap, "ns4:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_PointerTons4__SubscriptionPolicyType(soap, "ns4:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns4:CreationTime", -1, &a->CreationTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__SubscriptionManagerRP * SOAP_FMAC4 soap_in__ns4__SubscriptionManagerRP(struct soap *soap, const char *tag, struct _ns4__SubscriptionManagerRP *a, const char *type)
{
	size_t soap_flag_ConsumerReference = 1;
	size_t soap_flag_Filter = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	size_t soap_flag_CreationTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__SubscriptionManagerRP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__SubscriptionManagerRP, sizeof(struct _ns4__SubscriptionManagerRP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__SubscriptionManagerRP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "ns4:ConsumerReference", &a->ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference--;
					continue;
				}
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FilterType(soap, "ns4:Filter", &a->Filter, "ns4:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SubscriptionPolicyType(soap, "ns4:SubscriptionPolicy", &a->SubscriptionPolicy, "ns4:SubscriptionPolicyType"))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			if (soap_flag_CreationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns4:CreationTime", &a->CreationTime, "xsd:dateTime"))
				{	soap_flag_CreationTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__SubscriptionManagerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__SubscriptionManagerRP, 0, sizeof(struct _ns4__SubscriptionManagerRP), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__SubscriptionManagerRP(struct soap *soap, const struct _ns4__SubscriptionManagerRP *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns4__SubscriptionManagerRP);
	if (soap_out__ns4__SubscriptionManagerRP(soap, tag?tag:"ns4:SubscriptionManagerRP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__SubscriptionManagerRP * SOAP_FMAC4 soap_get__ns4__SubscriptionManagerRP(struct soap *soap, struct _ns4__SubscriptionManagerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__SubscriptionManagerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__MessageType(struct soap *soap, struct ns4__MessageType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__MessageType(struct soap *soap, const struct ns4__MessageType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__MessageType(struct soap *soap, const char *tag, int id, const struct ns4__MessageType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__MessageType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__MessageType * SOAP_FMAC4 soap_in_ns4__MessageType(struct soap *soap, const char *tag, struct ns4__MessageType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__MessageType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__MessageType, sizeof(struct ns4__MessageType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__MessageType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__MessageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__MessageType, 0, sizeof(struct ns4__MessageType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__MessageType(struct soap *soap, const struct ns4__MessageType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__MessageType);
	if (soap_out_ns4__MessageType(soap, tag?tag:"ns4:MessageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__MessageType * SOAP_FMAC4 soap_get_ns4__MessageType(struct soap *soap, struct ns4__MessageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__MessageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__NotificationMessageHolderType(struct soap *soap, struct ns4__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SubscriptionReference = NULL;
	a->Topic = NULL;
	a->ProducerReference = NULL;
	a->Message = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__NotificationMessageHolderType(struct soap *soap, const struct ns4__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_serialize_PointerTons4__TopicExpressionType(soap, &a->Topic);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ProducerReference);
	soap_serialize_PointerTons4__MessageType(soap, &a->Message);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const struct ns4__NotificationMessageHolderType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__NotificationMessageHolderType), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTons4__TopicExpressionType(soap, "ns4:Topic", -1, &a->Topic, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns4:ProducerReference", -1, &a->ProducerReference, ""))
		return soap->error;
	if (a->Message)
	{	if (soap_out_PointerTons4__MessageType(soap, "ns4:Message", -1, &a->Message, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns4:Message"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__NotificationMessageHolderType * SOAP_FMAC4 soap_in_ns4__NotificationMessageHolderType(struct soap *soap, const char *tag, struct ns4__NotificationMessageHolderType *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_Topic = 1;
	size_t soap_flag_ProducerReference = 1;
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__NotificationMessageHolderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__NotificationMessageHolderType, sizeof(struct ns4__NotificationMessageHolderType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__NotificationMessageHolderType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns4:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TopicExpressionType(soap, "ns4:Topic", &a->Topic, "ns4:TopicExpressionType"))
				{	soap_flag_Topic--;
					continue;
				}
			if (soap_flag_ProducerReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns4:ProducerReference", &a->ProducerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ProducerReference--;
					continue;
				}
			if (soap_flag_Message && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__MessageType(soap, "ns4:Message", &a->Message, "ns4:MessageType"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__NotificationMessageHolderType, 0, sizeof(struct ns4__NotificationMessageHolderType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__NotificationMessageHolderType(struct soap *soap, const struct ns4__NotificationMessageHolderType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__NotificationMessageHolderType);
	if (soap_out_ns4__NotificationMessageHolderType(soap, tag?tag:"ns4:NotificationMessageHolderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__NotificationMessageHolderType * SOAP_FMAC4 soap_get_ns4__NotificationMessageHolderType(struct soap *soap, struct ns4__NotificationMessageHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SubscriptionPolicyType(struct soap *soap, struct ns4__SubscriptionPolicyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SubscriptionPolicyType(struct soap *soap, const struct ns4__SubscriptionPolicyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, const struct ns4__SubscriptionPolicyType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SubscriptionPolicyType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SubscriptionPolicyType * SOAP_FMAC4 soap_in_ns4__SubscriptionPolicyType(struct soap *soap, const char *tag, struct ns4__SubscriptionPolicyType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SubscriptionPolicyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SubscriptionPolicyType, sizeof(struct ns4__SubscriptionPolicyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SubscriptionPolicyType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__SubscriptionPolicyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SubscriptionPolicyType, 0, sizeof(struct ns4__SubscriptionPolicyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SubscriptionPolicyType(struct soap *soap, const struct ns4__SubscriptionPolicyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__SubscriptionPolicyType);
	if (soap_out_ns4__SubscriptionPolicyType(soap, tag?tag:"ns4:SubscriptionPolicyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SubscriptionPolicyType * SOAP_FMAC4 soap_get_ns4__SubscriptionPolicyType(struct soap *soap, struct ns4__SubscriptionPolicyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__QueryExpressionType(struct soap *soap, struct ns4__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Dialect);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__QueryExpressionType(struct soap *soap, const struct ns4__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__QueryExpressionType(struct soap *soap, const char *tag, int id, const struct ns4__QueryExpressionType *a, const char *type)
{
	if (a->Dialect)
		soap_set_attr(soap, "Dialect", a->Dialect, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns4__QueryExpressionType * SOAP_FMAC4 soap_in_ns4__QueryExpressionType(struct soap *soap, const char *tag, struct ns4__QueryExpressionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct ns4__QueryExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__QueryExpressionType, sizeof(struct ns4__QueryExpressionType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_ns4__QueryExpressionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Dialect", 1), &a->Dialect, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "ns4:QueryExpressionType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__QueryExpressionType(struct soap *soap, const struct ns4__QueryExpressionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__QueryExpressionType);
	if (soap_out_ns4__QueryExpressionType(soap, tag?tag:"ns4:QueryExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__QueryExpressionType * SOAP_FMAC4 soap_get_ns4__QueryExpressionType(struct soap *soap, struct ns4__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__TopicExpressionType(struct soap *soap, struct ns4__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__TopicExpressionType(struct soap *soap, const struct ns4__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TopicExpressionType(struct soap *soap, const char *tag, int id, const struct ns4__TopicExpressionType *a, const char *type)
{
	if (a->Dialect)
		soap_set_attr(soap, "Dialect", a->Dialect, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__TopicExpressionType), type))
		return soap->error;
	if (soap_out_string(soap, "-item", -1, &a->__item, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__TopicExpressionType * SOAP_FMAC4 soap_in_ns4__TopicExpressionType(struct soap *soap, const char *tag, struct ns4__TopicExpressionType *a, const char *type)
{
	size_t soap_flag___item = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__TopicExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__TopicExpressionType, sizeof(struct ns4__TopicExpressionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__TopicExpressionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Dialect", 1), &a->Dialect, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___item && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "-item", &a->__item, "xsd:string"))
				{	soap_flag___item--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__TopicExpressionType, 0, sizeof(struct ns4__TopicExpressionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__TopicExpressionType(struct soap *soap, const struct ns4__TopicExpressionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__TopicExpressionType);
	if (soap_out_ns4__TopicExpressionType(soap, tag?tag:"ns4:TopicExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__TopicExpressionType * SOAP_FMAC4 soap_get_ns4__TopicExpressionType(struct soap *soap, struct ns4__TopicExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FilterType(struct soap *soap, struct ns4__FilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTopicExpression = 0;
	a->TopicExpression = NULL;
	a->__sizeProducerProperties = 0;
	a->ProducerProperties = NULL;
	a->__sizeMessageContent = 0;
	a->MessageContent = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FilterType(struct soap *soap, const struct ns4__FilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->TopicExpression)
	{	int i;
		for (i = 0; i < a->__sizeTopicExpression; i++)
		{
			soap_serialize_PointerTons4__TopicExpressionType(soap, a->TopicExpression + i);
		}
	}
	if (a->ProducerProperties)
	{	int i;
		for (i = 0; i < a->__sizeProducerProperties; i++)
		{
			soap_serialize_PointerTons4__QueryExpressionType(soap, a->ProducerProperties + i);
		}
	}
	if (a->MessageContent)
	{	int i;
		for (i = 0; i < a->__sizeMessageContent; i++)
		{
			soap_serialize_PointerTons4__QueryExpressionType(soap, a->MessageContent + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FilterType(struct soap *soap, const char *tag, int id, const struct ns4__FilterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FilterType), type))
		return soap->error;
	if (a->TopicExpression)
	{	int i;
		for (i = 0; i < a->__sizeTopicExpression; i++)
			if (soap_out_PointerTons4__TopicExpressionType(soap, "ns4:TopicExpression", -1, a->TopicExpression + i, ""))
				return soap->error;
	}
	if (a->ProducerProperties)
	{	int i;
		for (i = 0; i < a->__sizeProducerProperties; i++)
			if (soap_out_PointerTons4__QueryExpressionType(soap, "ns4:ProducerProperties", -1, a->ProducerProperties + i, ""))
				return soap->error;
	}
	if (a->MessageContent)
	{	int i;
		for (i = 0; i < a->__sizeMessageContent; i++)
			if (soap_out_PointerTons4__QueryExpressionType(soap, "ns4:MessageContent", -1, a->MessageContent + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FilterType * SOAP_FMAC4 soap_in_ns4__FilterType(struct soap *soap, const char *tag, struct ns4__FilterType *a, const char *type)
{
	struct soap_blist *soap_blist_TopicExpression = NULL;
	struct soap_blist *soap_blist_ProducerProperties = NULL;
	struct soap_blist *soap_blist_MessageContent = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FilterType, sizeof(struct ns4__FilterType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FilterType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:TopicExpression", 1, NULL))
			{	if (a->TopicExpression == NULL)
				{	if (soap_blist_TopicExpression == NULL)
						soap_blist_TopicExpression = soap_new_block(soap);
					a->TopicExpression = (struct ns4__TopicExpressionType **)soap_push_block(soap, soap_blist_TopicExpression, sizeof(struct ns4__TopicExpressionType *));
					if (a->TopicExpression == NULL)
						return NULL;
					*a->TopicExpression = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons4__TopicExpressionType(soap, "ns4:TopicExpression", a->TopicExpression, "ns4:TopicExpressionType"))
				{	a->__sizeTopicExpression++;
					a->TopicExpression = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:ProducerProperties", 1, NULL))
			{	if (a->ProducerProperties == NULL)
				{	if (soap_blist_ProducerProperties == NULL)
						soap_blist_ProducerProperties = soap_new_block(soap);
					a->ProducerProperties = (struct ns4__QueryExpressionType **)soap_push_block(soap, soap_blist_ProducerProperties, sizeof(struct ns4__QueryExpressionType *));
					if (a->ProducerProperties == NULL)
						return NULL;
					*a->ProducerProperties = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons4__QueryExpressionType(soap, "ns4:ProducerProperties", a->ProducerProperties, "ns4:QueryExpressionType"))
				{	a->__sizeProducerProperties++;
					a->ProducerProperties = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:MessageContent", 1, NULL))
			{	if (a->MessageContent == NULL)
				{	if (soap_blist_MessageContent == NULL)
						soap_blist_MessageContent = soap_new_block(soap);
					a->MessageContent = (struct ns4__QueryExpressionType **)soap_push_block(soap, soap_blist_MessageContent, sizeof(struct ns4__QueryExpressionType *));
					if (a->MessageContent == NULL)
						return NULL;
					*a->MessageContent = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons4__QueryExpressionType(soap, "ns4:MessageContent", a->MessageContent, "ns4:QueryExpressionType"))
				{	a->__sizeMessageContent++;
					a->MessageContent = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TopicExpression)
			soap_pop_block(soap, soap_blist_TopicExpression);
		if (a->__sizeTopicExpression)
			a->TopicExpression = (struct ns4__TopicExpressionType **)soap_save_block(soap, soap_blist_TopicExpression, NULL, 1);
		else
		{	a->TopicExpression = NULL;
			if (soap_blist_TopicExpression)
				soap_end_block(soap, soap_blist_TopicExpression);
		}
		if (a->ProducerProperties)
			soap_pop_block(soap, soap_blist_ProducerProperties);
		if (a->__sizeProducerProperties)
			a->ProducerProperties = (struct ns4__QueryExpressionType **)soap_save_block(soap, soap_blist_ProducerProperties, NULL, 1);
		else
		{	a->ProducerProperties = NULL;
			if (soap_blist_ProducerProperties)
				soap_end_block(soap, soap_blist_ProducerProperties);
		}
		if (a->MessageContent)
			soap_pop_block(soap, soap_blist_MessageContent);
		if (a->__sizeMessageContent)
			a->MessageContent = (struct ns4__QueryExpressionType **)soap_save_block(soap, soap_blist_MessageContent, NULL, 1);
		else
		{	a->MessageContent = NULL;
			if (soap_blist_MessageContent)
				soap_end_block(soap, soap_blist_MessageContent);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FilterType, 0, sizeof(struct ns4__FilterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FilterType(struct soap *soap, const struct ns4__FilterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__FilterType);
	if (soap_out_ns4__FilterType(soap, tag?tag:"ns4:FilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FilterType * SOAP_FMAC4 soap_get_ns4__FilterType(struct soap *soap, struct ns4__FilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->capability);
	a->interfaceMTU = NULL;
	soap_default_string(soap, &a->vlanRangeAvailability);
	soap_default_string(soap, &a->suggestedVLANRange);
	a->vlanTranslation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, const struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->capability);
	soap_serialize_PointerToint(soap, &a->interfaceMTU);
	soap_serialize_string(soap, &a->vlanRangeAvailability);
	soap_serialize_string(soap, &a->suggestedVLANRange);
	soap_serialize_PointerToxsd__boolean_(soap, &a->vlanTranslation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns3:capability", -1, &a->capability, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns3:interfaceMTU", -1, &a->interfaceMTU, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:vlanRangeAvailability", -1, &a->vlanRangeAvailability, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:suggestedVLANRange", -1, &a->suggestedVLANRange, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "ns3:vlanTranslation", -1, &a->vlanTranslation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo * SOAP_FMAC4 soap_in_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, const char *tag, struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *a, const char *type)
{
	size_t soap_flag_capability = 1;
	size_t soap_flag_interfaceMTU = 1;
	size_t soap_flag_vlanRangeAvailability = 1;
	size_t soap_flag_suggestedVLANRange = 1;
	size_t soap_flag_vlanTranslation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo, sizeof(struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_capability && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:capability", &a->capability, "xsd:string"))
				{	soap_flag_capability--;
					continue;
				}
			if (soap_flag_interfaceMTU && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns3:interfaceMTU", &a->interfaceMTU, "xsd:int"))
				{	soap_flag_interfaceMTU--;
					continue;
				}
			if (soap_flag_vlanRangeAvailability && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:vlanRangeAvailability", &a->vlanRangeAvailability, "xsd:string"))
				{	soap_flag_vlanRangeAvailability--;
					continue;
				}
			if (soap_flag_suggestedVLANRange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:suggestedVLANRange", &a->suggestedVLANRange, "xsd:string"))
				{	soap_flag_suggestedVLANRange--;
					continue;
				}
			if (soap_flag_vlanTranslation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "ns3:vlanTranslation", &a->vlanTranslation, "xsd:boolean"))
				{	soap_flag_vlanTranslation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo, 0, sizeof(struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, const struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo);
	if (soap_out_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag?tag:"ns3:CtrlPlaneSwitchingCapabilitySpecificInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo * SOAP_FMAC4 soap_get_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__Duration(struct soap *soap, struct ns3__Duration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__Duration(struct soap *soap, const struct ns3__Duration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Duration(struct soap *soap, const char *tag, int id, const struct ns3__Duration *a, const char *type)
{
	if (a->type)
		soap_set_attr(soap, "type", a->type, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns3__Duration * SOAP_FMAC4 soap_in_ns3__Duration(struct soap *soap, const char *tag, struct ns3__Duration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct ns3__Duration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__Duration, sizeof(struct ns3__Duration), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_ns3__Duration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "type", 1), &a->type, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "ns3:Duration"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__Duration(struct soap *soap, const struct ns3__Duration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__Duration);
	if (soap_out_ns3__Duration(soap, tag?tag:"ns3:Duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__Duration * SOAP_FMAC4 soap_get_ns3__Duration(struct soap *soap, struct ns3__Duration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__Duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__TimeContent(struct soap *soap, struct ns3__TimeContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__TimeContent(struct soap *soap, const struct ns3__TimeContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TimeContent(struct soap *soap, const char *tag, int id, const struct ns3__TimeContent *a, const char *type)
{
	if (a->type)
		soap_set_attr(soap, "type", a->type, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns3__TimeContent * SOAP_FMAC4 soap_in_ns3__TimeContent(struct soap *soap, const char *tag, struct ns3__TimeContent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct ns3__TimeContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TimeContent, sizeof(struct ns3__TimeContent), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_ns3__TimeContent(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "type", 1), &a->type, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "ns3:TimeContent"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__TimeContent(struct soap *soap, const struct ns3__TimeContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__TimeContent);
	if (soap_out_ns3__TimeContent(soap, tag?tag:"ns3:TimeContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__TimeContent * SOAP_FMAC4 soap_get_ns3__TimeContent(struct soap *soap, struct ns3__TimeContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TimeContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlaneNextHopContent(struct soap *soap, struct ns3__CtrlPlaneNextHopContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	a->weight = NULL;
	a->optional = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlaneNextHopContent(struct soap *soap, const struct ns3__CtrlPlaneNextHopContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlaneNextHopContent(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlaneNextHopContent *a, const char *type)
{
	if (a->weight)
		soap_set_attr(soap, "weight", soap_int2s(soap, *a->weight), 1);
	if (a->optional)
		soap_set_attr(soap, "optional", soap_xsd__boolean_2s(soap, *a->optional), 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns3__CtrlPlaneNextHopContent * SOAP_FMAC4 soap_in_ns3__CtrlPlaneNextHopContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneNextHopContent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct ns3__CtrlPlaneNextHopContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlaneNextHopContent, sizeof(struct ns3__CtrlPlaneNextHopContent), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_ns3__CtrlPlaneNextHopContent(soap, a);
	{	const char *t = soap_attr_value(soap, "weight", 0);
		if (t)
		{
			if (!(a->weight = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->weight))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "optional", 0);
		if (t)
		{
			if (!(a->optional = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->optional))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_string(soap, tag, &a->__item, "ns3:CtrlPlaneNextHopContent"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlaneNextHopContent(struct soap *soap, const struct ns3__CtrlPlaneNextHopContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlaneNextHopContent);
	if (soap_out_ns3__CtrlPlaneNextHopContent(soap, tag?tag:"ns3:CtrlPlaneNextHopContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneNextHopContent * SOAP_FMAC4 soap_get_ns3__CtrlPlaneNextHopContent(struct soap *soap, struct ns3__CtrlPlaneNextHopContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlaneNextHopContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlaneHopContent(struct soap *soap, struct ns3__CtrlPlaneHopContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->domainIdRef);
	soap_default_string(soap, &a->nodeIdRef);
	soap_default_string(soap, &a->portIdRef);
	soap_default_string(soap, &a->linkIdRef);
	a->domain = NULL;
	a->node = NULL;
	a->port = NULL;
	a->link = NULL;
	a->__sizenextHop = 0;
	a->nextHop = NULL;
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlaneHopContent(struct soap *soap, const struct ns3__CtrlPlaneHopContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->domainIdRef);
	soap_serialize_string(soap, &a->nodeIdRef);
	soap_serialize_string(soap, &a->portIdRef);
	soap_serialize_string(soap, &a->linkIdRef);
	soap_serialize_PointerTons3__CtrlPlaneDomainContent(soap, &a->domain);
	soap_serialize_PointerTons3__CtrlPlaneNodeContent(soap, &a->node);
	soap_serialize_PointerTons3__CtrlPlanePortContent(soap, &a->port);
	soap_serialize_PointerTons3__CtrlPlaneLinkContent(soap, &a->link);
	if (a->nextHop)
	{	int i;
		for (i = 0; i < a->__sizenextHop; i++)
		{
			soap_serialize_PointerTons3__CtrlPlaneNextHopContent(soap, a->nextHop + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlaneHopContent(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlaneHopContent *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CtrlPlaneHopContent), type))
		return soap->error;
	if (soap_out_string(soap, "ns3:domainIdRef", -1, &a->domainIdRef, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:nodeIdRef", -1, &a->nodeIdRef, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:portIdRef", -1, &a->portIdRef, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:linkIdRef", -1, &a->linkIdRef, ""))
		return soap->error;
	if (soap_out_PointerTons3__CtrlPlaneDomainContent(soap, "ns3:domain", -1, &a->domain, ""))
		return soap->error;
	if (soap_out_PointerTons3__CtrlPlaneNodeContent(soap, "ns3:node", -1, &a->node, ""))
		return soap->error;
	if (soap_out_PointerTons3__CtrlPlanePortContent(soap, "ns3:port", -1, &a->port, ""))
		return soap->error;
	if (soap_out_PointerTons3__CtrlPlaneLinkContent(soap, "ns3:link", -1, &a->link, ""))
		return soap->error;
	if (a->nextHop)
	{	int i;
		for (i = 0; i < a->__sizenextHop; i++)
			if (soap_out_PointerTons3__CtrlPlaneNextHopContent(soap, "ns3:nextHop", -1, a->nextHop + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__CtrlPlaneHopContent * SOAP_FMAC4 soap_in_ns3__CtrlPlaneHopContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneHopContent *a, const char *type)
{
	size_t soap_flag_domainIdRef = 1;
	size_t soap_flag_nodeIdRef = 1;
	size_t soap_flag_portIdRef = 1;
	size_t soap_flag_linkIdRef = 1;
	size_t soap_flag_domain = 1;
	size_t soap_flag_node = 1;
	size_t soap_flag_port = 1;
	size_t soap_flag_link = 1;
	struct soap_blist *soap_blist_nextHop = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__CtrlPlaneHopContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlaneHopContent, sizeof(struct ns3__CtrlPlaneHopContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__CtrlPlaneHopContent(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_domainIdRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:domainIdRef", &a->domainIdRef, "xsd:string"))
				{	soap_flag_domainIdRef--;
					continue;
				}
			if (soap_flag_nodeIdRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:nodeIdRef", &a->nodeIdRef, "xsd:string"))
				{	soap_flag_nodeIdRef--;
					continue;
				}
			if (soap_flag_portIdRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:portIdRef", &a->portIdRef, "xsd:string"))
				{	soap_flag_portIdRef--;
					continue;
				}
			if (soap_flag_linkIdRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:linkIdRef", &a->linkIdRef, "xsd:string"))
				{	soap_flag_linkIdRef--;
					continue;
				}
			if (soap_flag_domain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__CtrlPlaneDomainContent(soap, "ns3:domain", &a->domain, "ns3:CtrlPlaneDomainContent"))
				{	soap_flag_domain--;
					continue;
				}
			if (soap_flag_node && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__CtrlPlaneNodeContent(soap, "ns3:node", &a->node, "ns3:CtrlPlaneNodeContent"))
				{	soap_flag_node--;
					continue;
				}
			if (soap_flag_port && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__CtrlPlanePortContent(soap, "ns3:port", &a->port, "ns3:CtrlPlanePortContent"))
				{	soap_flag_port--;
					continue;
				}
			if (soap_flag_link && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__CtrlPlaneLinkContent(soap, "ns3:link", &a->link, "ns3:CtrlPlaneLinkContent"))
				{	soap_flag_link--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:nextHop", 1, NULL))
			{	if (a->nextHop == NULL)
				{	if (soap_blist_nextHop == NULL)
						soap_blist_nextHop = soap_new_block(soap);
					a->nextHop = (struct ns3__CtrlPlaneNextHopContent **)soap_push_block(soap, soap_blist_nextHop, sizeof(struct ns3__CtrlPlaneNextHopContent *));
					if (a->nextHop == NULL)
						return NULL;
					*a->nextHop = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons3__CtrlPlaneNextHopContent(soap, "ns3:nextHop", a->nextHop, "ns3:CtrlPlaneNextHopContent"))
				{	a->__sizenextHop++;
					a->nextHop = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->nextHop)
			soap_pop_block(soap, soap_blist_nextHop);
		if (a->__sizenextHop)
			a->nextHop = (struct ns3__CtrlPlaneNextHopContent **)soap_save_block(soap, soap_blist_nextHop, NULL, 1);
		else
		{	a->nextHop = NULL;
			if (soap_blist_nextHop)
				soap_end_block(soap, soap_blist_nextHop);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneHopContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CtrlPlaneHopContent, 0, sizeof(struct ns3__CtrlPlaneHopContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlaneHopContent(struct soap *soap, const struct ns3__CtrlPlaneHopContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlaneHopContent);
	if (soap_out_ns3__CtrlPlaneHopContent(soap, tag?tag:"ns3:CtrlPlaneHopContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneHopContent * SOAP_FMAC4 soap_get_ns3__CtrlPlaneHopContent(struct soap *soap, struct ns3__CtrlPlaneHopContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlaneHopContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlaneSwcapContent(struct soap *soap, struct ns3__CtrlPlaneSwcapContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->switchingcapType);
	soap_default_string(soap, &a->encodingType);
	a->switchingCapabilitySpecificInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlaneSwcapContent(struct soap *soap, const struct ns3__CtrlPlaneSwcapContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->switchingcapType);
	soap_serialize_string(soap, &a->encodingType);
	soap_serialize_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, &a->switchingCapabilitySpecificInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlaneSwcapContent(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlaneSwcapContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CtrlPlaneSwcapContent), type))
		return soap->error;
	if (a->switchingcapType)
	{	if (soap_out_string(soap, "ns3:switchingcapType", -1, &a->switchingcapType, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns3:switchingcapType"))
		return soap->error;
	if (a->encodingType)
	{	if (soap_out_string(soap, "ns3:encodingType", -1, &a->encodingType, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns3:encodingType"))
		return soap->error;
	if (a->switchingCapabilitySpecificInfo)
	{	if (soap_out_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, "ns3:switchingCapabilitySpecificInfo", -1, &a->switchingCapabilitySpecificInfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns3:switchingCapabilitySpecificInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__CtrlPlaneSwcapContent * SOAP_FMAC4 soap_in_ns3__CtrlPlaneSwcapContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneSwcapContent *a, const char *type)
{
	size_t soap_flag_switchingcapType = 1;
	size_t soap_flag_encodingType = 1;
	size_t soap_flag_switchingCapabilitySpecificInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__CtrlPlaneSwcapContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlaneSwcapContent, sizeof(struct ns3__CtrlPlaneSwcapContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__CtrlPlaneSwcapContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_switchingcapType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:switchingcapType", &a->switchingcapType, "xsd:string"))
				{	soap_flag_switchingcapType--;
					continue;
				}
			if (soap_flag_encodingType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:encodingType", &a->encodingType, "xsd:string"))
				{	soap_flag_encodingType--;
					continue;
				}
			if (soap_flag_switchingCapabilitySpecificInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, "ns3:switchingCapabilitySpecificInfo", &a->switchingCapabilitySpecificInfo, "ns3:CtrlPlaneSwitchingCapabilitySpecificInfo"))
				{	soap_flag_switchingCapabilitySpecificInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneSwcapContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CtrlPlaneSwcapContent, 0, sizeof(struct ns3__CtrlPlaneSwcapContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_switchingcapType > 0 || soap_flag_encodingType > 0 || soap_flag_switchingCapabilitySpecificInfo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlaneSwcapContent(struct soap *soap, const struct ns3__CtrlPlaneSwcapContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlaneSwcapContent);
	if (soap_out_ns3__CtrlPlaneSwcapContent(soap, tag?tag:"ns3:CtrlPlaneSwcapContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneSwcapContent * SOAP_FMAC4 soap_get_ns3__CtrlPlaneSwcapContent(struct soap *soap, struct ns3__CtrlPlaneSwcapContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlaneSwcapContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns3__CtrlPlaneAdministrativeGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->group);
	soap_default_string(soap, &a->groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlaneAdministrativeGroup(struct soap *soap, const struct ns3__CtrlPlaneAdministrativeGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->group, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->groupID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlaneAdministrativeGroup(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlaneAdministrativeGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CtrlPlaneAdministrativeGroup), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:group", -1, &a->group, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:groupID", -1, &a->groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__CtrlPlaneAdministrativeGroup * SOAP_FMAC4 soap_in_ns3__CtrlPlaneAdministrativeGroup(struct soap *soap, const char *tag, struct ns3__CtrlPlaneAdministrativeGroup *a, const char *type)
{
	size_t soap_flag_group = 1;
	size_t soap_flag_groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__CtrlPlaneAdministrativeGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlaneAdministrativeGroup, sizeof(struct ns3__CtrlPlaneAdministrativeGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__CtrlPlaneAdministrativeGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns3:group", &a->group, "xsd:int"))
				{	soap_flag_group--;
					continue;
				}
			if (soap_flag_groupID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:groupID", &a->groupID, "xsd:string"))
				{	soap_flag_groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneAdministrativeGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CtrlPlaneAdministrativeGroup, 0, sizeof(struct ns3__CtrlPlaneAdministrativeGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlaneAdministrativeGroup(struct soap *soap, const struct ns3__CtrlPlaneAdministrativeGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlaneAdministrativeGroup);
	if (soap_out_ns3__CtrlPlaneAdministrativeGroup(soap, tag?tag:"ns3:CtrlPlaneAdministrativeGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneAdministrativeGroup * SOAP_FMAC4 soap_get_ns3__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns3__CtrlPlaneAdministrativeGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlaneAdministrativeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlaneAddressContent(struct soap *soap, struct ns3__CtrlPlaneAddressContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->value);
	soap_default_string(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlaneAddressContent(struct soap *soap, const struct ns3__CtrlPlaneAddressContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlaneAddressContent(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlaneAddressContent *a, const char *type)
{
	if (a->value)
		soap_set_attr(soap, "value", a->value, 1);
	if (a->type)
		soap_set_attr(soap, "type", a->type, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns3__CtrlPlaneAddressContent * SOAP_FMAC4 soap_in_ns3__CtrlPlaneAddressContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneAddressContent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct ns3__CtrlPlaneAddressContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlaneAddressContent, sizeof(struct ns3__CtrlPlaneAddressContent), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_ns3__CtrlPlaneAddressContent(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "value", 0), &a->value, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "type", 0), &a->type, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "ns3:CtrlPlaneAddressContent"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlaneAddressContent(struct soap *soap, const struct ns3__CtrlPlaneAddressContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlaneAddressContent);
	if (soap_out_ns3__CtrlPlaneAddressContent(soap, tag?tag:"ns3:CtrlPlaneAddressContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneAddressContent * SOAP_FMAC4 soap_get_ns3__CtrlPlaneAddressContent(struct soap *soap, struct ns3__CtrlPlaneAddressContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlaneAddressContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlaneLinkContent(struct soap *soap, struct ns3__CtrlPlaneLinkContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->remoteLinkId);
	soap_default_string(soap, &a->trafficEngineeringMetric);
	soap_default_string(soap, &a->capacity);
	soap_default_string(soap, &a->maximumReservableCapacity);
	soap_default_string(soap, &a->minimumReservableCapacity);
	soap_default_string(soap, &a->granularity);
	soap_default_string(soap, &a->unreservedCapacity);
	a->__sizelinkProtectionTypes = 0;
	a->linkProtectionTypes = NULL;
	a->__sizeadministrativeGroups = 0;
	a->administrativeGroups = NULL;
	a->SwitchingCapabilityDescriptors = NULL;
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlaneLinkContent(struct soap *soap, const struct ns3__CtrlPlaneLinkContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->remoteLinkId);
	soap_serialize_string(soap, &a->trafficEngineeringMetric);
	soap_serialize_string(soap, &a->capacity);
	soap_serialize_string(soap, &a->maximumReservableCapacity);
	soap_serialize_string(soap, &a->minimumReservableCapacity);
	soap_serialize_string(soap, &a->granularity);
	soap_serialize_string(soap, &a->unreservedCapacity);
	if (a->linkProtectionTypes)
	{	int i;
		for (i = 0; i < a->__sizelinkProtectionTypes; i++)
		{
			soap_serialize_string(soap, a->linkProtectionTypes + i);
		}
	}
	if (a->administrativeGroups)
	{	int i;
		for (i = 0; i < a->__sizeadministrativeGroups; i++)
		{
			soap_serialize_PointerTons3__CtrlPlaneAdministrativeGroup(soap, a->administrativeGroups + i);
		}
	}
	soap_serialize_PointerTons3__CtrlPlaneSwcapContent(soap, &a->SwitchingCapabilityDescriptors);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlaneLinkContent(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlaneLinkContent *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CtrlPlaneLinkContent), type))
		return soap->error;
	if (soap_out_string(soap, "ns3:remoteLinkId", -1, &a->remoteLinkId, ""))
		return soap->error;
	if (a->trafficEngineeringMetric)
	{	if (soap_out_string(soap, "ns3:trafficEngineeringMetric", -1, &a->trafficEngineeringMetric, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns3:trafficEngineeringMetric"))
		return soap->error;
	if (soap_out_string(soap, "ns3:capacity", -1, &a->capacity, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:maximumReservableCapacity", -1, &a->maximumReservableCapacity, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:minimumReservableCapacity", -1, &a->minimumReservableCapacity, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:granularity", -1, &a->granularity, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:unreservedCapacity", -1, &a->unreservedCapacity, ""))
		return soap->error;
	if (a->linkProtectionTypes)
	{	int i;
		for (i = 0; i < a->__sizelinkProtectionTypes; i++)
			if (soap_out_string(soap, "ns3:linkProtectionTypes", -1, a->linkProtectionTypes + i, ""))
				return soap->error;
	}
	if (a->administrativeGroups)
	{	int i;
		for (i = 0; i < a->__sizeadministrativeGroups; i++)
			if (soap_out_PointerTons3__CtrlPlaneAdministrativeGroup(soap, "ns3:administrativeGroups", -1, a->administrativeGroups + i, ""))
				return soap->error;
	}
	if (a->SwitchingCapabilityDescriptors)
	{	if (soap_out_PointerTons3__CtrlPlaneSwcapContent(soap, "ns3:SwitchingCapabilityDescriptors", -1, &a->SwitchingCapabilityDescriptors, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns3:SwitchingCapabilityDescriptors"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__CtrlPlaneLinkContent * SOAP_FMAC4 soap_in_ns3__CtrlPlaneLinkContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneLinkContent *a, const char *type)
{
	size_t soap_flag_remoteLinkId = 1;
	size_t soap_flag_trafficEngineeringMetric = 1;
	size_t soap_flag_capacity = 1;
	size_t soap_flag_maximumReservableCapacity = 1;
	size_t soap_flag_minimumReservableCapacity = 1;
	size_t soap_flag_granularity = 1;
	size_t soap_flag_unreservedCapacity = 1;
	struct soap_blist *soap_blist_linkProtectionTypes = NULL;
	struct soap_blist *soap_blist_administrativeGroups = NULL;
	size_t soap_flag_SwitchingCapabilityDescriptors = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__CtrlPlaneLinkContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlaneLinkContent, sizeof(struct ns3__CtrlPlaneLinkContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__CtrlPlaneLinkContent(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_remoteLinkId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:remoteLinkId", &a->remoteLinkId, "xsd:string"))
				{	soap_flag_remoteLinkId--;
					continue;
				}
			if (soap_flag_trafficEngineeringMetric && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:trafficEngineeringMetric", &a->trafficEngineeringMetric, "xsd:string"))
				{	soap_flag_trafficEngineeringMetric--;
					continue;
				}
			if (soap_flag_capacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:capacity", &a->capacity, "xsd:string"))
				{	soap_flag_capacity--;
					continue;
				}
			if (soap_flag_maximumReservableCapacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:maximumReservableCapacity", &a->maximumReservableCapacity, "xsd:string"))
				{	soap_flag_maximumReservableCapacity--;
					continue;
				}
			if (soap_flag_minimumReservableCapacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:minimumReservableCapacity", &a->minimumReservableCapacity, "xsd:string"))
				{	soap_flag_minimumReservableCapacity--;
					continue;
				}
			if (soap_flag_granularity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:granularity", &a->granularity, "xsd:string"))
				{	soap_flag_granularity--;
					continue;
				}
			if (soap_flag_unreservedCapacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:unreservedCapacity", &a->unreservedCapacity, "xsd:string"))
				{	soap_flag_unreservedCapacity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:linkProtectionTypes", 1, NULL))
			{	if (a->linkProtectionTypes == NULL)
				{	if (soap_blist_linkProtectionTypes == NULL)
						soap_blist_linkProtectionTypes = soap_new_block(soap);
					a->linkProtectionTypes = (char **)soap_push_block(soap, soap_blist_linkProtectionTypes, sizeof(char *));
					if (a->linkProtectionTypes == NULL)
						return NULL;
					*a->linkProtectionTypes = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns3:linkProtectionTypes", a->linkProtectionTypes, "xsd:string"))
				{	a->__sizelinkProtectionTypes++;
					a->linkProtectionTypes = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:administrativeGroups", 1, NULL))
			{	if (a->administrativeGroups == NULL)
				{	if (soap_blist_administrativeGroups == NULL)
						soap_blist_administrativeGroups = soap_new_block(soap);
					a->administrativeGroups = (struct ns3__CtrlPlaneAdministrativeGroup **)soap_push_block(soap, soap_blist_administrativeGroups, sizeof(struct ns3__CtrlPlaneAdministrativeGroup *));
					if (a->administrativeGroups == NULL)
						return NULL;
					*a->administrativeGroups = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons3__CtrlPlaneAdministrativeGroup(soap, "ns3:administrativeGroups", a->administrativeGroups, "ns3:CtrlPlaneAdministrativeGroup"))
				{	a->__sizeadministrativeGroups++;
					a->administrativeGroups = NULL;
					continue;
				}
			}
			if (soap_flag_SwitchingCapabilityDescriptors && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__CtrlPlaneSwcapContent(soap, "ns3:SwitchingCapabilityDescriptors", &a->SwitchingCapabilityDescriptors, "ns3:CtrlPlaneSwcapContent"))
				{	soap_flag_SwitchingCapabilityDescriptors--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->linkProtectionTypes)
			soap_pop_block(soap, soap_blist_linkProtectionTypes);
		if (a->__sizelinkProtectionTypes)
			a->linkProtectionTypes = (char **)soap_save_block(soap, soap_blist_linkProtectionTypes, NULL, 1);
		else
		{	a->linkProtectionTypes = NULL;
			if (soap_blist_linkProtectionTypes)
				soap_end_block(soap, soap_blist_linkProtectionTypes);
		}
		if (a->administrativeGroups)
			soap_pop_block(soap, soap_blist_administrativeGroups);
		if (a->__sizeadministrativeGroups)
			a->administrativeGroups = (struct ns3__CtrlPlaneAdministrativeGroup **)soap_save_block(soap, soap_blist_administrativeGroups, NULL, 1);
		else
		{	a->administrativeGroups = NULL;
			if (soap_blist_administrativeGroups)
				soap_end_block(soap, soap_blist_administrativeGroups);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneLinkContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CtrlPlaneLinkContent, 0, sizeof(struct ns3__CtrlPlaneLinkContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trafficEngineeringMetric > 0 || soap_flag_SwitchingCapabilityDescriptors > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlaneLinkContent(struct soap *soap, const struct ns3__CtrlPlaneLinkContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlaneLinkContent);
	if (soap_out_ns3__CtrlPlaneLinkContent(soap, tag?tag:"ns3:CtrlPlaneLinkContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneLinkContent * SOAP_FMAC4 soap_get_ns3__CtrlPlaneLinkContent(struct soap *soap, struct ns3__CtrlPlaneLinkContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlaneLinkContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlanePortContent(struct soap *soap, struct ns3__CtrlPlanePortContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lifetime = NULL;
	soap_default_string(soap, &a->capacity);
	soap_default_string(soap, &a->maximumReservableCapacity);
	soap_default_string(soap, &a->minimumReservableCapacity);
	soap_default_string(soap, &a->granularity);
	soap_default_string(soap, &a->unreservedCapacity);
	a->__sizelink = 0;
	a->link = NULL;
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlanePortContent(struct soap *soap, const struct ns3__CtrlPlanePortContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__Lifetime(soap, &a->lifetime);
	soap_serialize_string(soap, &a->capacity);
	soap_serialize_string(soap, &a->maximumReservableCapacity);
	soap_serialize_string(soap, &a->minimumReservableCapacity);
	soap_serialize_string(soap, &a->granularity);
	soap_serialize_string(soap, &a->unreservedCapacity);
	if (a->link)
	{	int i;
		for (i = 0; i < a->__sizelink; i++)
		{
			soap_serialize_PointerTons3__CtrlPlaneLinkContent(soap, a->link + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlanePortContent(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlanePortContent *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CtrlPlanePortContent), type))
		return soap->error;
	if (soap_out_PointerTons3__Lifetime(soap, "ns3:lifetime", -1, &a->lifetime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:capacity", -1, &a->capacity, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:maximumReservableCapacity", -1, &a->maximumReservableCapacity, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:minimumReservableCapacity", -1, &a->minimumReservableCapacity, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:granularity", -1, &a->granularity, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:unreservedCapacity", -1, &a->unreservedCapacity, ""))
		return soap->error;
	if (a->link)
	{	int i;
		for (i = 0; i < a->__sizelink; i++)
			if (soap_out_PointerTons3__CtrlPlaneLinkContent(soap, "ns3:link", -1, a->link + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__CtrlPlanePortContent * SOAP_FMAC4 soap_in_ns3__CtrlPlanePortContent(struct soap *soap, const char *tag, struct ns3__CtrlPlanePortContent *a, const char *type)
{
	size_t soap_flag_lifetime = 1;
	size_t soap_flag_capacity = 1;
	size_t soap_flag_maximumReservableCapacity = 1;
	size_t soap_flag_minimumReservableCapacity = 1;
	size_t soap_flag_granularity = 1;
	size_t soap_flag_unreservedCapacity = 1;
	struct soap_blist *soap_blist_link = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__CtrlPlanePortContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlanePortContent, sizeof(struct ns3__CtrlPlanePortContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__CtrlPlanePortContent(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__Lifetime(soap, "ns3:lifetime", &a->lifetime, "ns3:Lifetime"))
				{	soap_flag_lifetime--;
					continue;
				}
			if (soap_flag_capacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:capacity", &a->capacity, "xsd:string"))
				{	soap_flag_capacity--;
					continue;
				}
			if (soap_flag_maximumReservableCapacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:maximumReservableCapacity", &a->maximumReservableCapacity, "xsd:string"))
				{	soap_flag_maximumReservableCapacity--;
					continue;
				}
			if (soap_flag_minimumReservableCapacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:minimumReservableCapacity", &a->minimumReservableCapacity, "xsd:string"))
				{	soap_flag_minimumReservableCapacity--;
					continue;
				}
			if (soap_flag_granularity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:granularity", &a->granularity, "xsd:string"))
				{	soap_flag_granularity--;
					continue;
				}
			if (soap_flag_unreservedCapacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:unreservedCapacity", &a->unreservedCapacity, "xsd:string"))
				{	soap_flag_unreservedCapacity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:link", 1, NULL))
			{	if (a->link == NULL)
				{	if (soap_blist_link == NULL)
						soap_blist_link = soap_new_block(soap);
					a->link = (struct ns3__CtrlPlaneLinkContent **)soap_push_block(soap, soap_blist_link, sizeof(struct ns3__CtrlPlaneLinkContent *));
					if (a->link == NULL)
						return NULL;
					*a->link = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons3__CtrlPlaneLinkContent(soap, "ns3:link", a->link, "ns3:CtrlPlaneLinkContent"))
				{	a->__sizelink++;
					a->link = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->link)
			soap_pop_block(soap, soap_blist_link);
		if (a->__sizelink)
			a->link = (struct ns3__CtrlPlaneLinkContent **)soap_save_block(soap, soap_blist_link, NULL, 1);
		else
		{	a->link = NULL;
			if (soap_blist_link)
				soap_end_block(soap, soap_blist_link);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlanePortContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CtrlPlanePortContent, 0, sizeof(struct ns3__CtrlPlanePortContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlanePortContent(struct soap *soap, const struct ns3__CtrlPlanePortContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlanePortContent);
	if (soap_out_ns3__CtrlPlanePortContent(soap, tag?tag:"ns3:CtrlPlanePortContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlanePortContent * SOAP_FMAC4 soap_get_ns3__CtrlPlanePortContent(struct soap *soap, struct ns3__CtrlPlanePortContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlanePortContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlaneNodeContent(struct soap *soap, struct ns3__CtrlPlaneNodeContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lifetime = NULL;
	a->address = NULL;
	a->__sizeport = 0;
	a->port = NULL;
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlaneNodeContent(struct soap *soap, const struct ns3__CtrlPlaneNodeContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__Lifetime(soap, &a->lifetime);
	soap_serialize_PointerTons3__CtrlPlaneAddressContent(soap, &a->address);
	if (a->port)
	{	int i;
		for (i = 0; i < a->__sizeport; i++)
		{
			soap_serialize_PointerTons3__CtrlPlanePortContent(soap, a->port + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlaneNodeContent(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlaneNodeContent *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CtrlPlaneNodeContent), type))
		return soap->error;
	if (soap_out_PointerTons3__Lifetime(soap, "ns3:lifetime", -1, &a->lifetime, ""))
		return soap->error;
	if (soap_out_PointerTons3__CtrlPlaneAddressContent(soap, "ns3:address", -1, &a->address, ""))
		return soap->error;
	if (a->port)
	{	int i;
		for (i = 0; i < a->__sizeport; i++)
			if (soap_out_PointerTons3__CtrlPlanePortContent(soap, "ns3:port", -1, a->port + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__CtrlPlaneNodeContent * SOAP_FMAC4 soap_in_ns3__CtrlPlaneNodeContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneNodeContent *a, const char *type)
{
	size_t soap_flag_lifetime = 1;
	size_t soap_flag_address = 1;
	struct soap_blist *soap_blist_port = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__CtrlPlaneNodeContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlaneNodeContent, sizeof(struct ns3__CtrlPlaneNodeContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__CtrlPlaneNodeContent(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__Lifetime(soap, "ns3:lifetime", &a->lifetime, "ns3:Lifetime"))
				{	soap_flag_lifetime--;
					continue;
				}
			if (soap_flag_address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__CtrlPlaneAddressContent(soap, "ns3:address", &a->address, "ns3:CtrlPlaneAddressContent"))
				{	soap_flag_address--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:port", 1, NULL))
			{	if (a->port == NULL)
				{	if (soap_blist_port == NULL)
						soap_blist_port = soap_new_block(soap);
					a->port = (struct ns3__CtrlPlanePortContent **)soap_push_block(soap, soap_blist_port, sizeof(struct ns3__CtrlPlanePortContent *));
					if (a->port == NULL)
						return NULL;
					*a->port = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons3__CtrlPlanePortContent(soap, "ns3:port", a->port, "ns3:CtrlPlanePortContent"))
				{	a->__sizeport++;
					a->port = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->port)
			soap_pop_block(soap, soap_blist_port);
		if (a->__sizeport)
			a->port = (struct ns3__CtrlPlanePortContent **)soap_save_block(soap, soap_blist_port, NULL, 1);
		else
		{	a->port = NULL;
			if (soap_blist_port)
				soap_end_block(soap, soap_blist_port);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneNodeContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CtrlPlaneNodeContent, 0, sizeof(struct ns3__CtrlPlaneNodeContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlaneNodeContent(struct soap *soap, const struct ns3__CtrlPlaneNodeContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlaneNodeContent);
	if (soap_out_ns3__CtrlPlaneNodeContent(soap, tag?tag:"ns3:CtrlPlaneNodeContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneNodeContent * SOAP_FMAC4 soap_get_ns3__CtrlPlaneNodeContent(struct soap *soap, struct ns3__CtrlPlaneNodeContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlaneNodeContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__Lifetime(struct soap *soap, struct ns3__Lifetime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->start = NULL;
	a->end = NULL;
	a->duration = NULL;
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->direction);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__Lifetime(struct soap *soap, const struct ns3__Lifetime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__TimeContent(soap, &a->start);
	soap_serialize_PointerTons3__TimeContent(soap, &a->end);
	soap_serialize_PointerTons3__Duration(soap, &a->duration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Lifetime(struct soap *soap, const char *tag, int id, const struct ns3__Lifetime *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id, 1);
	if (a->direction)
		soap_set_attr(soap, "direction", a->direction, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__Lifetime), type))
		return soap->error;
	if (soap_out_PointerTons3__TimeContent(soap, "ns3:start", -1, &a->start, ""))
		return soap->error;
	if (soap_out_PointerTons3__TimeContent(soap, "ns3:end", -1, &a->end, ""))
		return soap->error;
	if (soap_out_PointerTons3__Duration(soap, "ns3:duration", -1, &a->duration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__Lifetime * SOAP_FMAC4 soap_in_ns3__Lifetime(struct soap *soap, const char *tag, struct ns3__Lifetime *a, const char *type)
{
	size_t soap_flag_start = 1;
	size_t soap_flag_end = 1;
	size_t soap_flag_duration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__Lifetime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__Lifetime, sizeof(struct ns3__Lifetime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__Lifetime(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "direction", 0), &a->direction, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimeContent(soap, "ns3:start", &a->start, "ns3:TimeContent"))
				{	soap_flag_start--;
					continue;
				}
			if (soap_flag_end && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimeContent(soap, "ns3:end", &a->end, "ns3:TimeContent"))
				{	soap_flag_end--;
					continue;
				}
			if (soap_flag_duration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__Duration(soap, "ns3:duration", &a->duration, "ns3:Duration"))
				{	soap_flag_duration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__Lifetime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__Lifetime, 0, sizeof(struct ns3__Lifetime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__Lifetime(struct soap *soap, const struct ns3__Lifetime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__Lifetime);
	if (soap_out_ns3__Lifetime(soap, tag?tag:"ns3:Lifetime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__Lifetime * SOAP_FMAC4 soap_get_ns3__Lifetime(struct soap *soap, struct ns3__Lifetime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__Lifetime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns3__CtrlPlaneDomainSignatureContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->domainId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlaneDomainSignatureContent(struct soap *soap, const struct ns3__CtrlPlaneDomainSignatureContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlaneDomainSignatureContent(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlaneDomainSignatureContent *a, const char *type)
{
	if (a->domainId)
		soap_set_attr(soap, "domainId", a->domainId, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CtrlPlaneDomainSignatureContent), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__CtrlPlaneDomainSignatureContent * SOAP_FMAC4 soap_in_ns3__CtrlPlaneDomainSignatureContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneDomainSignatureContent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__CtrlPlaneDomainSignatureContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlaneDomainSignatureContent, sizeof(struct ns3__CtrlPlaneDomainSignatureContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__CtrlPlaneDomainSignatureContent(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "domainId", 1), &a->domainId, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneDomainSignatureContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CtrlPlaneDomainSignatureContent, 0, sizeof(struct ns3__CtrlPlaneDomainSignatureContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlaneDomainSignatureContent(struct soap *soap, const struct ns3__CtrlPlaneDomainSignatureContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlaneDomainSignatureContent);
	if (soap_out_ns3__CtrlPlaneDomainSignatureContent(soap, tag?tag:"ns3:CtrlPlaneDomainSignatureContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneDomainSignatureContent * SOAP_FMAC4 soap_get_ns3__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns3__CtrlPlaneDomainSignatureContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlaneDomainSignatureContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlaneDomainContent(struct soap *soap, struct ns3__CtrlPlaneDomainContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lifetime = NULL;
	a->__sizenode = 0;
	a->node = NULL;
	a->__sizeport = 0;
	a->port = NULL;
	a->__sizelink = 0;
	a->link = NULL;
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlaneDomainContent(struct soap *soap, const struct ns3__CtrlPlaneDomainContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__Lifetime(soap, &a->lifetime);
	if (a->node)
	{	int i;
		for (i = 0; i < a->__sizenode; i++)
		{
			soap_serialize_PointerTons3__CtrlPlaneNodeContent(soap, a->node + i);
		}
	}
	if (a->port)
	{	int i;
		for (i = 0; i < a->__sizeport; i++)
		{
			soap_serialize_PointerTons3__CtrlPlanePortContent(soap, a->port + i);
		}
	}
	if (a->link)
	{	int i;
		for (i = 0; i < a->__sizelink; i++)
		{
			soap_serialize_PointerTons3__CtrlPlaneLinkContent(soap, a->link + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlaneDomainContent(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlaneDomainContent *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CtrlPlaneDomainContent), type))
		return soap->error;
	if (soap_out_PointerTons3__Lifetime(soap, "ns3:lifetime", -1, &a->lifetime, ""))
		return soap->error;
	if (a->node)
	{	int i;
		for (i = 0; i < a->__sizenode; i++)
			if (soap_out_PointerTons3__CtrlPlaneNodeContent(soap, "ns3:node", -1, a->node + i, ""))
				return soap->error;
	}
	if (a->port)
	{	int i;
		for (i = 0; i < a->__sizeport; i++)
			if (soap_out_PointerTons3__CtrlPlanePortContent(soap, "ns3:port", -1, a->port + i, ""))
				return soap->error;
	}
	if (a->link)
	{	int i;
		for (i = 0; i < a->__sizelink; i++)
			if (soap_out_PointerTons3__CtrlPlaneLinkContent(soap, "ns3:link", -1, a->link + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__CtrlPlaneDomainContent * SOAP_FMAC4 soap_in_ns3__CtrlPlaneDomainContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneDomainContent *a, const char *type)
{
	size_t soap_flag_lifetime = 1;
	struct soap_blist *soap_blist_node = NULL;
	struct soap_blist *soap_blist_port = NULL;
	struct soap_blist *soap_blist_link = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__CtrlPlaneDomainContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlaneDomainContent, sizeof(struct ns3__CtrlPlaneDomainContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__CtrlPlaneDomainContent(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__Lifetime(soap, "ns3:lifetime", &a->lifetime, "ns3:Lifetime"))
				{	soap_flag_lifetime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:node", 1, NULL))
			{	if (a->node == NULL)
				{	if (soap_blist_node == NULL)
						soap_blist_node = soap_new_block(soap);
					a->node = (struct ns3__CtrlPlaneNodeContent **)soap_push_block(soap, soap_blist_node, sizeof(struct ns3__CtrlPlaneNodeContent *));
					if (a->node == NULL)
						return NULL;
					*a->node = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons3__CtrlPlaneNodeContent(soap, "ns3:node", a->node, "ns3:CtrlPlaneNodeContent"))
				{	a->__sizenode++;
					a->node = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:port", 1, NULL))
			{	if (a->port == NULL)
				{	if (soap_blist_port == NULL)
						soap_blist_port = soap_new_block(soap);
					a->port = (struct ns3__CtrlPlanePortContent **)soap_push_block(soap, soap_blist_port, sizeof(struct ns3__CtrlPlanePortContent *));
					if (a->port == NULL)
						return NULL;
					*a->port = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons3__CtrlPlanePortContent(soap, "ns3:port", a->port, "ns3:CtrlPlanePortContent"))
				{	a->__sizeport++;
					a->port = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:link", 1, NULL))
			{	if (a->link == NULL)
				{	if (soap_blist_link == NULL)
						soap_blist_link = soap_new_block(soap);
					a->link = (struct ns3__CtrlPlaneLinkContent **)soap_push_block(soap, soap_blist_link, sizeof(struct ns3__CtrlPlaneLinkContent *));
					if (a->link == NULL)
						return NULL;
					*a->link = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons3__CtrlPlaneLinkContent(soap, "ns3:link", a->link, "ns3:CtrlPlaneLinkContent"))
				{	a->__sizelink++;
					a->link = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->node)
			soap_pop_block(soap, soap_blist_node);
		if (a->__sizenode)
			a->node = (struct ns3__CtrlPlaneNodeContent **)soap_save_block(soap, soap_blist_node, NULL, 1);
		else
		{	a->node = NULL;
			if (soap_blist_node)
				soap_end_block(soap, soap_blist_node);
		}
		if (a->port)
			soap_pop_block(soap, soap_blist_port);
		if (a->__sizeport)
			a->port = (struct ns3__CtrlPlanePortContent **)soap_save_block(soap, soap_blist_port, NULL, 1);
		else
		{	a->port = NULL;
			if (soap_blist_port)
				soap_end_block(soap, soap_blist_port);
		}
		if (a->link)
			soap_pop_block(soap, soap_blist_link);
		if (a->__sizelink)
			a->link = (struct ns3__CtrlPlaneLinkContent **)soap_save_block(soap, soap_blist_link, NULL, 1);
		else
		{	a->link = NULL;
			if (soap_blist_link)
				soap_end_block(soap, soap_blist_link);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneDomainContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CtrlPlaneDomainContent, 0, sizeof(struct ns3__CtrlPlaneDomainContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlaneDomainContent(struct soap *soap, const struct ns3__CtrlPlaneDomainContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlaneDomainContent);
	if (soap_out_ns3__CtrlPlaneDomainContent(soap, tag?tag:"ns3:CtrlPlaneDomainContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneDomainContent * SOAP_FMAC4 soap_get_ns3__CtrlPlaneDomainContent(struct soap *soap, struct ns3__CtrlPlaneDomainContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlaneDomainContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__SignalFault(struct soap *soap, struct _ns1__SignalFault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->msg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__SignalFault(struct soap *soap, const struct _ns1__SignalFault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->msg);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SignalFault(struct soap *soap, const char *tag, int id, const struct _ns1__SignalFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SignalFault), type))
		return soap->error;
	if (a->msg)
	{	if (soap_out_string(soap, "ns1:msg", -1, &a->msg, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:msg"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__SignalFault * SOAP_FMAC4 soap_in__ns1__SignalFault(struct soap *soap, const char *tag, struct _ns1__SignalFault *a, const char *type)
{
	size_t soap_flag_msg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__SignalFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SignalFault, sizeof(struct _ns1__SignalFault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__SignalFault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_msg && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:msg", &a->msg, "xsd:string"))
				{	soap_flag_msg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__SignalFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SignalFault, 0, sizeof(struct _ns1__SignalFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_msg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__SignalFault(struct soap *soap, const struct _ns1__SignalFault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__SignalFault);
	if (soap_out__ns1__SignalFault(soap, tag?tag:"ns1:SignalFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__SignalFault * SOAP_FMAC4 soap_get__ns1__SignalFault(struct soap *soap, struct _ns1__SignalFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SignalFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__TopologyFault(struct soap *soap, struct _ns1__TopologyFault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->msg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__TopologyFault(struct soap *soap, const struct _ns1__TopologyFault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->msg);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TopologyFault(struct soap *soap, const char *tag, int id, const struct _ns1__TopologyFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TopologyFault), type))
		return soap->error;
	if (a->msg)
	{	if (soap_out_string(soap, "ns1:msg", -1, &a->msg, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:msg"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__TopologyFault * SOAP_FMAC4 soap_in__ns1__TopologyFault(struct soap *soap, const char *tag, struct _ns1__TopologyFault *a, const char *type)
{
	size_t soap_flag_msg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__TopologyFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TopologyFault, sizeof(struct _ns1__TopologyFault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__TopologyFault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_msg && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:msg", &a->msg, "xsd:string"))
				{	soap_flag_msg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__TopologyFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TopologyFault, 0, sizeof(struct _ns1__TopologyFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_msg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__TopologyFault(struct soap *soap, const struct _ns1__TopologyFault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__TopologyFault);
	if (soap_out__ns1__TopologyFault(soap, tag?tag:"ns1:TopologyFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__TopologyFault * SOAP_FMAC4 soap_get__ns1__TopologyFault(struct soap *soap, struct _ns1__TopologyFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TopologyFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__BSSFault(struct soap *soap, struct _ns1__BSSFault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->msg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__BSSFault(struct soap *soap, const struct _ns1__BSSFault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->msg);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BSSFault(struct soap *soap, const char *tag, int id, const struct _ns1__BSSFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BSSFault), type))
		return soap->error;
	if (a->msg)
	{	if (soap_out_string(soap, "ns1:msg", -1, &a->msg, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:msg"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__BSSFault * SOAP_FMAC4 soap_in__ns1__BSSFault(struct soap *soap, const char *tag, struct _ns1__BSSFault *a, const char *type)
{
	size_t soap_flag_msg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__BSSFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BSSFault, sizeof(struct _ns1__BSSFault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__BSSFault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_msg && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:msg", &a->msg, "xsd:string"))
				{	soap_flag_msg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__BSSFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BSSFault, 0, sizeof(struct _ns1__BSSFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_msg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__BSSFault(struct soap *soap, const struct _ns1__BSSFault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__BSSFault);
	if (soap_out__ns1__BSSFault(soap, tag?tag:"ns1:BSSFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__BSSFault * SOAP_FMAC4 soap_get__ns1__BSSFault(struct soap *soap, struct _ns1__BSSFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BSSFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__AAAFault(struct soap *soap, struct _ns1__AAAFault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->msg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__AAAFault(struct soap *soap, const struct _ns1__AAAFault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->msg);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AAAFault(struct soap *soap, const char *tag, int id, const struct _ns1__AAAFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AAAFault), type))
		return soap->error;
	if (a->msg)
	{	if (soap_out_string(soap, "ns1:msg", -1, &a->msg, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:msg"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__AAAFault * SOAP_FMAC4 soap_in__ns1__AAAFault(struct soap *soap, const char *tag, struct _ns1__AAAFault *a, const char *type)
{
	size_t soap_flag_msg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__AAAFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AAAFault, sizeof(struct _ns1__AAAFault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__AAAFault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_msg && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:msg", &a->msg, "xsd:string"))
				{	soap_flag_msg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__AAAFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AAAFault, 0, sizeof(struct _ns1__AAAFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_msg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__AAAFault(struct soap *soap, const struct _ns1__AAAFault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__AAAFault);
	if (soap_out__ns1__AAAFault(soap, tag?tag:"ns1:AAAFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__AAAFault * SOAP_FMAC4 soap_get__ns1__AAAFault(struct soap *soap, struct _ns1__AAAFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AAAFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__forward(struct soap *soap, struct _ns1__forward *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->payload = NULL;
	soap_default_string(soap, &a->payloadSender);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__forward(struct soap *soap, const struct _ns1__forward *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__forwardPayload(soap, &a->payload);
	soap_serialize_string(soap, &a->payloadSender);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__forward(struct soap *soap, const char *tag, int id, const struct _ns1__forward *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__forward), type))
		return soap->error;
	if (a->payload)
	{	if (soap_out_PointerTons1__forwardPayload(soap, "ns1:payload", -1, &a->payload, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:payload"))
		return soap->error;
	if (a->payloadSender)
	{	if (soap_out_string(soap, "ns1:payloadSender", -1, &a->payloadSender, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:payloadSender"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__forward * SOAP_FMAC4 soap_in__ns1__forward(struct soap *soap, const char *tag, struct _ns1__forward *a, const char *type)
{
	size_t soap_flag_payload = 1;
	size_t soap_flag_payloadSender = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__forward *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__forward, sizeof(struct _ns1__forward), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__forward(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_payload && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__forwardPayload(soap, "ns1:payload", &a->payload, "ns1:forwardPayload"))
				{	soap_flag_payload--;
					continue;
				}
			if (soap_flag_payloadSender && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:payloadSender", &a->payloadSender, "xsd:string"))
				{	soap_flag_payloadSender--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__forward *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__forward, 0, sizeof(struct _ns1__forward), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_payload > 0 || soap_flag_payloadSender > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__forward(struct soap *soap, const struct _ns1__forward *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__forward);
	if (soap_out__ns1__forward(soap, tag?tag:"ns1:forward", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__forward * SOAP_FMAC4 soap_get__ns1__forward(struct soap *soap, struct _ns1__forward *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__forward(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__localDetails(struct soap *soap, struct ns1__localDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__localDetails(struct soap *soap, const struct ns1__localDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__localDetails(struct soap *soap, const char *tag, int id, const struct ns1__localDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__localDetails), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__localDetails * SOAP_FMAC4 soap_in_ns1__localDetails(struct soap *soap, const char *tag, struct ns1__localDetails *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__localDetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__localDetails, sizeof(struct ns1__localDetails), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__localDetails(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__localDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__localDetails, 0, sizeof(struct ns1__localDetails), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__localDetails(struct soap *soap, const struct ns1__localDetails *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__localDetails);
	if (soap_out_ns1__localDetails(soap, tag?tag:"ns1:localDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__localDetails * SOAP_FMAC4 soap_get_ns1__localDetails(struct soap *soap, struct ns1__localDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__localDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__msgDetails(struct soap *soap, struct ns1__msgDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->contentType);
	a->forward = NULL;
	a->createReservation = NULL;
	a->modifyReservation = NULL;
	a->cancelReservation = NULL;
	a->queryReservation = NULL;
	a->listReservations = NULL;
	a->createPath = NULL;
	a->refreshPath = NULL;
	a->teardownPath = NULL;
	a->forwardResponse = NULL;
	a->createReservationResponse = NULL;
	a->modifyReservationResponse = NULL;
	soap_default_string(soap, &a->cancelReservationResponse);
	a->queryReservationResponse = NULL;
	a->listReservationsResponse = NULL;
	a->createPathResponse = NULL;
	a->refreshPathResponse = NULL;
	a->teardownPathResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__msgDetails(struct soap *soap, const struct ns1__msgDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->contentType);
	soap_serialize_PointerTons1__forwardPayload(soap, &a->forward);
	soap_serialize_PointerTons1__resCreateContent(soap, &a->createReservation);
	soap_serialize_PointerTons1__modifyResContent(soap, &a->modifyReservation);
	soap_serialize_PointerTons1__globalReservationId(soap, &a->cancelReservation);
	soap_serialize_PointerTons1__globalReservationId(soap, &a->queryReservation);
	soap_serialize_PointerTons1__listRequest(soap, &a->listReservations);
	soap_serialize_PointerTons1__createPathContent(soap, &a->createPath);
	soap_serialize_PointerTons1__refreshPathContent(soap, &a->refreshPath);
	soap_serialize_PointerTons1__teardownPathContent(soap, &a->teardownPath);
	soap_serialize_PointerTons1__forwardReply(soap, &a->forwardResponse);
	soap_serialize_PointerTons1__createReply(soap, &a->createReservationResponse);
	soap_serialize_PointerTons1__modifyResReply(soap, &a->modifyReservationResponse);
	soap_serialize_string(soap, &a->cancelReservationResponse);
	soap_serialize_PointerTons1__resDetails(soap, &a->queryReservationResponse);
	soap_serialize_PointerTons1__listReply(soap, &a->listReservationsResponse);
	soap_serialize_PointerTons1__createPathResponseContent(soap, &a->createPathResponse);
	soap_serialize_PointerTons1__refreshPathResponseContent(soap, &a->refreshPathResponse);
	soap_serialize_PointerTons1__teardownPathResponseContent(soap, &a->teardownPathResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__msgDetails(struct soap *soap, const char *tag, int id, const struct ns1__msgDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__msgDetails), type))
		return soap->error;
	if (a->contentType)
	{	if (soap_out_string(soap, "ns1:contentType", -1, &a->contentType, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:contentType"))
		return soap->error;
	if (soap_out_PointerTons1__forwardPayload(soap, "ns1:forward", -1, &a->forward, ""))
		return soap->error;
	if (soap_out_PointerTons1__resCreateContent(soap, "ns1:createReservation", -1, &a->createReservation, ""))
		return soap->error;
	if (soap_out_PointerTons1__modifyResContent(soap, "ns1:modifyReservation", -1, &a->modifyReservation, ""))
		return soap->error;
	if (soap_out_PointerTons1__globalReservationId(soap, "ns1:cancelReservation", -1, &a->cancelReservation, ""))
		return soap->error;
	if (soap_out_PointerTons1__globalReservationId(soap, "ns1:queryReservation", -1, &a->queryReservation, ""))
		return soap->error;
	if (soap_out_PointerTons1__listRequest(soap, "ns1:listReservations", -1, &a->listReservations, ""))
		return soap->error;
	if (soap_out_PointerTons1__createPathContent(soap, "ns1:createPath", -1, &a->createPath, ""))
		return soap->error;
	if (soap_out_PointerTons1__refreshPathContent(soap, "ns1:refreshPath", -1, &a->refreshPath, ""))
		return soap->error;
	if (soap_out_PointerTons1__teardownPathContent(soap, "ns1:teardownPath", -1, &a->teardownPath, ""))
		return soap->error;
	if (soap_out_PointerTons1__forwardReply(soap, "ns1:forwardResponse", -1, &a->forwardResponse, ""))
		return soap->error;
	if (soap_out_PointerTons1__createReply(soap, "ns1:createReservationResponse", -1, &a->createReservationResponse, ""))
		return soap->error;
	if (soap_out_PointerTons1__modifyResReply(soap, "ns1:modifyReservationResponse", -1, &a->modifyReservationResponse, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cancelReservationResponse", -1, &a->cancelReservationResponse, ""))
		return soap->error;
	if (soap_out_PointerTons1__resDetails(soap, "ns1:queryReservationResponse", -1, &a->queryReservationResponse, ""))
		return soap->error;
	if (soap_out_PointerTons1__listReply(soap, "ns1:listReservationsResponse", -1, &a->listReservationsResponse, ""))
		return soap->error;
	if (soap_out_PointerTons1__createPathResponseContent(soap, "ns1:createPathResponse", -1, &a->createPathResponse, ""))
		return soap->error;
	if (soap_out_PointerTons1__refreshPathResponseContent(soap, "ns1:refreshPathResponse", -1, &a->refreshPathResponse, ""))
		return soap->error;
	if (soap_out_PointerTons1__teardownPathResponseContent(soap, "ns1:teardownPathResponse", -1, &a->teardownPathResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__msgDetails * SOAP_FMAC4 soap_in_ns1__msgDetails(struct soap *soap, const char *tag, struct ns1__msgDetails *a, const char *type)
{
	size_t soap_flag_contentType = 1;
	size_t soap_flag_forward = 1;
	size_t soap_flag_createReservation = 1;
	size_t soap_flag_modifyReservation = 1;
	size_t soap_flag_cancelReservation = 1;
	size_t soap_flag_queryReservation = 1;
	size_t soap_flag_listReservations = 1;
	size_t soap_flag_createPath = 1;
	size_t soap_flag_refreshPath = 1;
	size_t soap_flag_teardownPath = 1;
	size_t soap_flag_forwardResponse = 1;
	size_t soap_flag_createReservationResponse = 1;
	size_t soap_flag_modifyReservationResponse = 1;
	size_t soap_flag_cancelReservationResponse = 1;
	size_t soap_flag_queryReservationResponse = 1;
	size_t soap_flag_listReservationsResponse = 1;
	size_t soap_flag_createPathResponse = 1;
	size_t soap_flag_refreshPathResponse = 1;
	size_t soap_flag_teardownPathResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__msgDetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__msgDetails, sizeof(struct ns1__msgDetails), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__msgDetails(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_contentType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:contentType", &a->contentType, "xsd:string"))
				{	soap_flag_contentType--;
					continue;
				}
			if (soap_flag_forward && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__forwardPayload(soap, "ns1:forward", &a->forward, "ns1:forwardPayload"))
				{	soap_flag_forward--;
					continue;
				}
			if (soap_flag_createReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__resCreateContent(soap, "ns1:createReservation", &a->createReservation, "ns1:resCreateContent"))
				{	soap_flag_createReservation--;
					continue;
				}
			if (soap_flag_modifyReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyResContent(soap, "ns1:modifyReservation", &a->modifyReservation, "ns1:modifyResContent"))
				{	soap_flag_modifyReservation--;
					continue;
				}
			if (soap_flag_cancelReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__globalReservationId(soap, "ns1:cancelReservation", &a->cancelReservation, "ns1:globalReservationId"))
				{	soap_flag_cancelReservation--;
					continue;
				}
			if (soap_flag_queryReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__globalReservationId(soap, "ns1:queryReservation", &a->queryReservation, "ns1:globalReservationId"))
				{	soap_flag_queryReservation--;
					continue;
				}
			if (soap_flag_listReservations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listRequest(soap, "ns1:listReservations", &a->listReservations, "ns1:listRequest"))
				{	soap_flag_listReservations--;
					continue;
				}
			if (soap_flag_createPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createPathContent(soap, "ns1:createPath", &a->createPath, "ns1:createPathContent"))
				{	soap_flag_createPath--;
					continue;
				}
			if (soap_flag_refreshPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__refreshPathContent(soap, "ns1:refreshPath", &a->refreshPath, "ns1:refreshPathContent"))
				{	soap_flag_refreshPath--;
					continue;
				}
			if (soap_flag_teardownPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__teardownPathContent(soap, "ns1:teardownPath", &a->teardownPath, "ns1:teardownPathContent"))
				{	soap_flag_teardownPath--;
					continue;
				}
			if (soap_flag_forwardResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__forwardReply(soap, "ns1:forwardResponse", &a->forwardResponse, "ns1:forwardReply"))
				{	soap_flag_forwardResponse--;
					continue;
				}
			if (soap_flag_createReservationResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createReply(soap, "ns1:createReservationResponse", &a->createReservationResponse, "ns1:createReply"))
				{	soap_flag_createReservationResponse--;
					continue;
				}
			if (soap_flag_modifyReservationResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyResReply(soap, "ns1:modifyReservationResponse", &a->modifyReservationResponse, "ns1:modifyResReply"))
				{	soap_flag_modifyReservationResponse--;
					continue;
				}
			if (soap_flag_cancelReservationResponse && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cancelReservationResponse", &a->cancelReservationResponse, "xsd:string"))
				{	soap_flag_cancelReservationResponse--;
					continue;
				}
			if (soap_flag_queryReservationResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__resDetails(soap, "ns1:queryReservationResponse", &a->queryReservationResponse, "ns1:resDetails"))
				{	soap_flag_queryReservationResponse--;
					continue;
				}
			if (soap_flag_listReservationsResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listReply(soap, "ns1:listReservationsResponse", &a->listReservationsResponse, "ns1:listReply"))
				{	soap_flag_listReservationsResponse--;
					continue;
				}
			if (soap_flag_createPathResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createPathResponseContent(soap, "ns1:createPathResponse", &a->createPathResponse, "ns1:createPathResponseContent"))
				{	soap_flag_createPathResponse--;
					continue;
				}
			if (soap_flag_refreshPathResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__refreshPathResponseContent(soap, "ns1:refreshPathResponse", &a->refreshPathResponse, "ns1:refreshPathResponseContent"))
				{	soap_flag_refreshPathResponse--;
					continue;
				}
			if (soap_flag_teardownPathResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__teardownPathResponseContent(soap, "ns1:teardownPathResponse", &a->teardownPathResponse, "ns1:teardownPathResponseContent"))
				{	soap_flag_teardownPathResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__msgDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__msgDetails, 0, sizeof(struct ns1__msgDetails), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_contentType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__msgDetails(struct soap *soap, const struct ns1__msgDetails *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__msgDetails);
	if (soap_out_ns1__msgDetails(soap, tag?tag:"ns1:msgDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__msgDetails * SOAP_FMAC4 soap_get_ns1__msgDetails(struct soap *soap, struct ns1__msgDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__msgDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__eventContent(struct soap *soap, struct ns1__eventContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->type);
	soap_default_LONG64(soap, &a->timestamp);
	soap_default_string(soap, &a->userLogin);
	soap_default_string(soap, &a->errorSource);
	soap_default_string(soap, &a->errorCode);
	soap_default_string(soap, &a->errorMessage);
	a->resDetails = NULL;
	a->msgDetails = NULL;
	a->localDetails = NULL;
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__eventContent(struct soap *soap, const struct ns1__eventContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->type);
	soap_serialize_string(soap, &a->userLogin);
	soap_serialize_string(soap, &a->errorSource);
	soap_serialize_string(soap, &a->errorCode);
	soap_serialize_string(soap, &a->errorMessage);
	soap_serialize_PointerTons1__resDetails(soap, &a->resDetails);
	soap_serialize_PointerTons1__msgDetails(soap, &a->msgDetails);
	soap_serialize_PointerTons1__localDetails(soap, &a->localDetails);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__eventContent(struct soap *soap, const char *tag, int id, const struct ns1__eventContent *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__eventContent), type))
		return soap->error;
	if (a->type)
	{	if (soap_out_string(soap, "ns1:type", -1, &a->type, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:type"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:timestamp", -1, &a->timestamp, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:userLogin", -1, &a->userLogin, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:errorSource", -1, &a->errorSource, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:errorCode", -1, &a->errorCode, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:errorMessage", -1, &a->errorMessage, ""))
		return soap->error;
	if (soap_out_PointerTons1__resDetails(soap, "ns1:resDetails", -1, &a->resDetails, ""))
		return soap->error;
	if (soap_out_PointerTons1__msgDetails(soap, "ns1:msgDetails", -1, &a->msgDetails, ""))
		return soap->error;
	if (soap_out_PointerTons1__localDetails(soap, "ns1:localDetails", -1, &a->localDetails, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__eventContent * SOAP_FMAC4 soap_in_ns1__eventContent(struct soap *soap, const char *tag, struct ns1__eventContent *a, const char *type)
{
	size_t soap_flag_type = 1;
	size_t soap_flag_timestamp = 1;
	size_t soap_flag_userLogin = 1;
	size_t soap_flag_errorSource = 1;
	size_t soap_flag_errorCode = 1;
	size_t soap_flag_errorMessage = 1;
	size_t soap_flag_resDetails = 1;
	size_t soap_flag_msgDetails = 1;
	size_t soap_flag_localDetails = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__eventContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__eventContent, sizeof(struct ns1__eventContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__eventContent(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:type", &a->type, "xsd:string"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:timestamp", &a->timestamp, "xsd:long"))
				{	soap_flag_timestamp--;
					continue;
				}
			if (soap_flag_userLogin && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userLogin", &a->userLogin, "xsd:string"))
				{	soap_flag_userLogin--;
					continue;
				}
			if (soap_flag_errorSource && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:errorSource", &a->errorSource, "xsd:string"))
				{	soap_flag_errorSource--;
					continue;
				}
			if (soap_flag_errorCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:errorCode", &a->errorCode, "xsd:string"))
				{	soap_flag_errorCode--;
					continue;
				}
			if (soap_flag_errorMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:errorMessage", &a->errorMessage, "xsd:string"))
				{	soap_flag_errorMessage--;
					continue;
				}
			if (soap_flag_resDetails && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__resDetails(soap, "ns1:resDetails", &a->resDetails, "ns1:resDetails"))
				{	soap_flag_resDetails--;
					continue;
				}
			if (soap_flag_msgDetails && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__msgDetails(soap, "ns1:msgDetails", &a->msgDetails, "ns1:msgDetails"))
				{	soap_flag_msgDetails--;
					continue;
				}
			if (soap_flag_localDetails && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__localDetails(soap, "ns1:localDetails", &a->localDetails, "ns1:localDetails"))
				{	soap_flag_localDetails--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__eventContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__eventContent, 0, sizeof(struct ns1__eventContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0 || soap_flag_timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__eventContent(struct soap *soap, const struct ns1__eventContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__eventContent);
	if (soap_out_ns1__eventContent(soap, tag?tag:"ns1:eventContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__eventContent * SOAP_FMAC4 soap_get_ns1__eventContent(struct soap *soap, struct ns1__eventContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__eventContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mplsInfo(struct soap *soap, struct ns1__mplsInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->burstLimit);
	soap_default_string(soap, &a->lspClass);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mplsInfo(struct soap *soap, const struct ns1__mplsInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->burstLimit, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->lspClass);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mplsInfo(struct soap *soap, const char *tag, int id, const struct ns1__mplsInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mplsInfo), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:burstLimit", -1, &a->burstLimit, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:lspClass", -1, &a->lspClass, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mplsInfo * SOAP_FMAC4 soap_in_ns1__mplsInfo(struct soap *soap, const char *tag, struct ns1__mplsInfo *a, const char *type)
{
	size_t soap_flag_burstLimit = 1;
	size_t soap_flag_lspClass = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mplsInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mplsInfo, sizeof(struct ns1__mplsInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mplsInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_burstLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:burstLimit", &a->burstLimit, "xsd:int"))
				{	soap_flag_burstLimit--;
					continue;
				}
			if (soap_flag_lspClass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:lspClass", &a->lspClass, "xsd:string"))
				{	soap_flag_lspClass--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mplsInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mplsInfo, 0, sizeof(struct ns1__mplsInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_burstLimit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mplsInfo(struct soap *soap, const struct ns1__mplsInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mplsInfo);
	if (soap_out_ns1__mplsInfo(soap, tag?tag:"ns1:mplsInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mplsInfo * SOAP_FMAC4 soap_get_ns1__mplsInfo(struct soap *soap, struct ns1__mplsInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mplsInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__layer3Info(struct soap *soap, struct ns1__layer3Info *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->srcHost);
	soap_default_string(soap, &a->destHost);
	soap_default_string(soap, &a->protocol);
	a->srcIpPort = NULL;
	a->destIpPort = NULL;
	soap_default_string(soap, &a->dscp);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__layer3Info(struct soap *soap, const struct ns1__layer3Info *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->srcHost);
	soap_serialize_string(soap, &a->destHost);
	soap_serialize_string(soap, &a->protocol);
	soap_serialize_PointerToint(soap, &a->srcIpPort);
	soap_serialize_PointerToint(soap, &a->destIpPort);
	soap_serialize_string(soap, &a->dscp);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__layer3Info(struct soap *soap, const char *tag, int id, const struct ns1__layer3Info *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__layer3Info), type))
		return soap->error;
	if (a->srcHost)
	{	if (soap_out_string(soap, "ns1:srcHost", -1, &a->srcHost, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:srcHost"))
		return soap->error;
	if (a->destHost)
	{	if (soap_out_string(soap, "ns1:destHost", -1, &a->destHost, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:destHost"))
		return soap->error;
	if (soap_out_string(soap, "ns1:protocol", -1, &a->protocol, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:srcIpPort", -1, &a->srcIpPort, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:destIpPort", -1, &a->destIpPort, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dscp", -1, &a->dscp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__layer3Info * SOAP_FMAC4 soap_in_ns1__layer3Info(struct soap *soap, const char *tag, struct ns1__layer3Info *a, const char *type)
{
	size_t soap_flag_srcHost = 1;
	size_t soap_flag_destHost = 1;
	size_t soap_flag_protocol = 1;
	size_t soap_flag_srcIpPort = 1;
	size_t soap_flag_destIpPort = 1;
	size_t soap_flag_dscp = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__layer3Info *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__layer3Info, sizeof(struct ns1__layer3Info), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__layer3Info(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srcHost && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:srcHost", &a->srcHost, "xsd:string"))
				{	soap_flag_srcHost--;
					continue;
				}
			if (soap_flag_destHost && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:destHost", &a->destHost, "xsd:string"))
				{	soap_flag_destHost--;
					continue;
				}
			if (soap_flag_protocol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:protocol", &a->protocol, "xsd:string"))
				{	soap_flag_protocol--;
					continue;
				}
			if (soap_flag_srcIpPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:srcIpPort", &a->srcIpPort, "xsd:int"))
				{	soap_flag_srcIpPort--;
					continue;
				}
			if (soap_flag_destIpPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:destIpPort", &a->destIpPort, "xsd:int"))
				{	soap_flag_destIpPort--;
					continue;
				}
			if (soap_flag_dscp && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:dscp", &a->dscp, "xsd:string"))
				{	soap_flag_dscp--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__layer3Info *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__layer3Info, 0, sizeof(struct ns1__layer3Info), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_srcHost > 0 || soap_flag_destHost > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__layer3Info(struct soap *soap, const struct ns1__layer3Info *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__layer3Info);
	if (soap_out_ns1__layer3Info(soap, tag?tag:"ns1:layer3Info", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__layer3Info * SOAP_FMAC4 soap_get_ns1__layer3Info(struct soap *soap, struct ns1__layer3Info *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__layer3Info(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__layer2Info(struct soap *soap, struct ns1__layer2Info *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->srcVtag = NULL;
	a->destVtag = NULL;
	soap_default_string(soap, &a->srcEndpoint);
	soap_default_string(soap, &a->destEndpoint);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__layer2Info(struct soap *soap, const struct ns1__layer2Info *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__vlanTag(soap, &a->srcVtag);
	soap_serialize_PointerTons1__vlanTag(soap, &a->destVtag);
	soap_serialize_string(soap, &a->srcEndpoint);
	soap_serialize_string(soap, &a->destEndpoint);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__layer2Info(struct soap *soap, const char *tag, int id, const struct ns1__layer2Info *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__layer2Info), type))
		return soap->error;
	if (soap_out_PointerTons1__vlanTag(soap, "ns1:srcVtag", -1, &a->srcVtag, ""))
		return soap->error;
	if (soap_out_PointerTons1__vlanTag(soap, "ns1:destVtag", -1, &a->destVtag, ""))
		return soap->error;
	if (a->srcEndpoint)
	{	if (soap_out_string(soap, "ns1:srcEndpoint", -1, &a->srcEndpoint, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:srcEndpoint"))
		return soap->error;
	if (a->destEndpoint)
	{	if (soap_out_string(soap, "ns1:destEndpoint", -1, &a->destEndpoint, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:destEndpoint"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__layer2Info * SOAP_FMAC4 soap_in_ns1__layer2Info(struct soap *soap, const char *tag, struct ns1__layer2Info *a, const char *type)
{
	size_t soap_flag_srcVtag = 1;
	size_t soap_flag_destVtag = 1;
	size_t soap_flag_srcEndpoint = 1;
	size_t soap_flag_destEndpoint = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__layer2Info *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__layer2Info, sizeof(struct ns1__layer2Info), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__layer2Info(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srcVtag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__vlanTag(soap, "ns1:srcVtag", &a->srcVtag, "ns1:vlanTag"))
				{	soap_flag_srcVtag--;
					continue;
				}
			if (soap_flag_destVtag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__vlanTag(soap, "ns1:destVtag", &a->destVtag, "ns1:vlanTag"))
				{	soap_flag_destVtag--;
					continue;
				}
			if (soap_flag_srcEndpoint && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:srcEndpoint", &a->srcEndpoint, "xsd:string"))
				{	soap_flag_srcEndpoint--;
					continue;
				}
			if (soap_flag_destEndpoint && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:destEndpoint", &a->destEndpoint, "xsd:string"))
				{	soap_flag_destEndpoint--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__layer2Info *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__layer2Info, 0, sizeof(struct ns1__layer2Info), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_srcEndpoint > 0 || soap_flag_destEndpoint > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__layer2Info(struct soap *soap, const struct ns1__layer2Info *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__layer2Info);
	if (soap_out_ns1__layer2Info(soap, tag?tag:"ns1:layer2Info", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__layer2Info * SOAP_FMAC4 soap_get_ns1__layer2Info(struct soap *soap, struct ns1__layer2Info *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__layer2Info(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlanePathContent(struct soap *soap, struct ns3__CtrlPlanePathContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->lifetime = NULL;
	a->__sizehop = 0;
	a->hop = NULL;
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->direction);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlanePathContent(struct soap *soap, const struct ns3__CtrlPlanePathContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__Lifetime(soap, &a->lifetime);
	if (a->hop)
	{	int i;
		for (i = 0; i < a->__sizehop; i++)
		{
			soap_serialize_PointerTons3__CtrlPlaneHopContent(soap, a->hop + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlanePathContent(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlanePathContent *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id, 1);
	if (a->direction)
		soap_set_attr(soap, "direction", a->direction, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CtrlPlanePathContent), type))
		return soap->error;
	if (soap_out_PointerTons3__Lifetime(soap, "ns3:lifetime", -1, &a->lifetime, ""))
		return soap->error;
	if (a->hop)
	{	int i;
		for (i = 0; i < a->__sizehop; i++)
			if (soap_out_PointerTons3__CtrlPlaneHopContent(soap, "ns3:hop", -1, a->hop + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__CtrlPlanePathContent * SOAP_FMAC4 soap_in_ns3__CtrlPlanePathContent(struct soap *soap, const char *tag, struct ns3__CtrlPlanePathContent *a, const char *type)
{
	size_t soap_flag_lifetime = 1;
	struct soap_blist *soap_blist_hop = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__CtrlPlanePathContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlanePathContent, sizeof(struct ns3__CtrlPlanePathContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__CtrlPlanePathContent(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "direction", 0), &a->direction, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lifetime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__Lifetime(soap, "ns3:lifetime", &a->lifetime, "ns3:Lifetime"))
				{	soap_flag_lifetime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:hop", 1, NULL))
			{	if (a->hop == NULL)
				{	if (soap_blist_hop == NULL)
						soap_blist_hop = soap_new_block(soap);
					a->hop = (struct ns3__CtrlPlaneHopContent **)soap_push_block(soap, soap_blist_hop, sizeof(struct ns3__CtrlPlaneHopContent *));
					if (a->hop == NULL)
						return NULL;
					*a->hop = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons3__CtrlPlaneHopContent(soap, "ns3:hop", a->hop, "ns3:CtrlPlaneHopContent"))
				{	a->__sizehop++;
					a->hop = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->hop)
			soap_pop_block(soap, soap_blist_hop);
		if (a->__sizehop)
			a->hop = (struct ns3__CtrlPlaneHopContent **)soap_save_block(soap, soap_blist_hop, NULL, 1);
		else
		{	a->hop = NULL;
			if (soap_blist_hop)
				soap_end_block(soap, soap_blist_hop);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlanePathContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CtrlPlanePathContent, 0, sizeof(struct ns3__CtrlPlanePathContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlanePathContent(struct soap *soap, const struct ns3__CtrlPlanePathContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlanePathContent);
	if (soap_out_ns3__CtrlPlanePathContent(soap, tag?tag:"ns3:CtrlPlanePathContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlanePathContent * SOAP_FMAC4 soap_get_ns3__CtrlPlanePathContent(struct soap *soap, struct ns3__CtrlPlanePathContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlanePathContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__forwardReply(struct soap *soap, struct ns1__forwardReply *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->contentType);
	a->createReservation = NULL;
	a->modifyReservation = NULL;
	soap_default_string(soap, &a->cancelReservation);
	a->queryReservation = NULL;
	a->listReservations = NULL;
	a->createPath = NULL;
	a->refreshPath = NULL;
	a->teardownPath = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__forwardReply(struct soap *soap, const struct ns1__forwardReply *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->contentType);
	soap_serialize_PointerTons1__createReply(soap, &a->createReservation);
	soap_serialize_PointerTons1__modifyResReply(soap, &a->modifyReservation);
	soap_serialize_string(soap, &a->cancelReservation);
	soap_serialize_PointerTons1__resDetails(soap, &a->queryReservation);
	soap_serialize_PointerTons1__listReply(soap, &a->listReservations);
	soap_serialize_PointerTons1__createPathResponseContent(soap, &a->createPath);
	soap_serialize_PointerTons1__refreshPathResponseContent(soap, &a->refreshPath);
	soap_serialize_PointerTons1__teardownPathResponseContent(soap, &a->teardownPath);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__forwardReply(struct soap *soap, const char *tag, int id, const struct ns1__forwardReply *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__forwardReply), type))
		return soap->error;
	if (a->contentType)
		soap_element_result(soap, "ns1:contentType");
	if (a->contentType)
	{	if (soap_out_string(soap, "ns1:contentType", -1, &a->contentType, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:contentType"))
		return soap->error;
	if (soap_out_PointerTons1__createReply(soap, "ns1:createReservation", -1, &a->createReservation, ""))
		return soap->error;
	if (soap_out_PointerTons1__modifyResReply(soap, "ns1:modifyReservation", -1, &a->modifyReservation, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cancelReservation", -1, &a->cancelReservation, ""))
		return soap->error;
	if (soap_out_PointerTons1__resDetails(soap, "ns1:queryReservation", -1, &a->queryReservation, ""))
		return soap->error;
	if (soap_out_PointerTons1__listReply(soap, "ns1:listReservations", -1, &a->listReservations, ""))
		return soap->error;
	if (soap_out_PointerTons1__createPathResponseContent(soap, "ns1:createPath", -1, &a->createPath, ""))
		return soap->error;
	if (soap_out_PointerTons1__refreshPathResponseContent(soap, "ns1:refreshPath", -1, &a->refreshPath, ""))
		return soap->error;
	if (soap_out_PointerTons1__teardownPathResponseContent(soap, "ns1:teardownPath", -1, &a->teardownPath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__forwardReply * SOAP_FMAC4 soap_in_ns1__forwardReply(struct soap *soap, const char *tag, struct ns1__forwardReply *a, const char *type)
{
	size_t soap_flag_contentType = 1;
	size_t soap_flag_createReservation = 1;
	size_t soap_flag_modifyReservation = 1;
	size_t soap_flag_cancelReservation = 1;
	size_t soap_flag_queryReservation = 1;
	size_t soap_flag_listReservations = 1;
	size_t soap_flag_createPath = 1;
	size_t soap_flag_refreshPath = 1;
	size_t soap_flag_teardownPath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__forwardReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__forwardReply, sizeof(struct ns1__forwardReply), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__forwardReply(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_contentType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:contentType", &a->contentType, "xsd:string"))
				{	soap_flag_contentType--;
					continue;
				}
			if (soap_flag_createReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createReply(soap, "ns1:createReservation", &a->createReservation, "ns1:createReply"))
				{	soap_flag_createReservation--;
					continue;
				}
			if (soap_flag_modifyReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyResReply(soap, "ns1:modifyReservation", &a->modifyReservation, "ns1:modifyResReply"))
				{	soap_flag_modifyReservation--;
					continue;
				}
			if (soap_flag_cancelReservation && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cancelReservation", &a->cancelReservation, "xsd:string"))
				{	soap_flag_cancelReservation--;
					continue;
				}
			if (soap_flag_queryReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__resDetails(soap, "ns1:queryReservation", &a->queryReservation, "ns1:resDetails"))
				{	soap_flag_queryReservation--;
					continue;
				}
			if (soap_flag_listReservations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listReply(soap, "ns1:listReservations", &a->listReservations, "ns1:listReply"))
				{	soap_flag_listReservations--;
					continue;
				}
			if (soap_flag_createPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createPathResponseContent(soap, "ns1:createPath", &a->createPath, "ns1:createPathResponseContent"))
				{	soap_flag_createPath--;
					continue;
				}
			if (soap_flag_refreshPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__refreshPathResponseContent(soap, "ns1:refreshPath", &a->refreshPath, "ns1:refreshPathResponseContent"))
				{	soap_flag_refreshPath--;
					continue;
				}
			if (soap_flag_teardownPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__teardownPathResponseContent(soap, "ns1:teardownPath", &a->teardownPath, "ns1:teardownPathResponseContent"))
				{	soap_flag_teardownPath--;
					continue;
				}
			soap_check_result(soap, "ns1:contentType");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__forwardReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__forwardReply, 0, sizeof(struct ns1__forwardReply), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_contentType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__forwardReply(struct soap *soap, const struct ns1__forwardReply *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__forwardReply);
	if (soap_out_ns1__forwardReply(soap, tag?tag:"ns1:forwardReply", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__forwardReply * SOAP_FMAC4 soap_get_ns1__forwardReply(struct soap *soap, struct ns1__forwardReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__forwardReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__globalReservationId(struct soap *soap, struct ns1__globalReservationId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->gri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__globalReservationId(struct soap *soap, const struct ns1__globalReservationId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->gri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__globalReservationId(struct soap *soap, const char *tag, int id, const struct ns1__globalReservationId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__globalReservationId), type))
		return soap->error;
	if (a->gri)
	{	if (soap_out_string(soap, "ns1:gri", -1, &a->gri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:gri"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__globalReservationId * SOAP_FMAC4 soap_in_ns1__globalReservationId(struct soap *soap, const char *tag, struct ns1__globalReservationId *a, const char *type)
{
	size_t soap_flag_gri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__globalReservationId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__globalReservationId, sizeof(struct ns1__globalReservationId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__globalReservationId(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:gri", &a->gri, "xsd:string"))
				{	soap_flag_gri--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__globalReservationId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__globalReservationId, 0, sizeof(struct ns1__globalReservationId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_gri > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__globalReservationId(struct soap *soap, const struct ns1__globalReservationId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__globalReservationId);
	if (soap_out_ns1__globalReservationId(soap, tag?tag:"ns1:globalReservationId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__globalReservationId * SOAP_FMAC4 soap_get_ns1__globalReservationId(struct soap *soap, struct ns1__globalReservationId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__globalReservationId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__forwardPayload(struct soap *soap, struct ns1__forwardPayload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->contentType);
	a->createReservation = NULL;
	a->modifyReservation = NULL;
	a->cancelReservation = NULL;
	a->queryReservation = NULL;
	a->listReservations = NULL;
	a->createPath = NULL;
	a->refreshPath = NULL;
	a->teardownPath = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__forwardPayload(struct soap *soap, const struct ns1__forwardPayload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->contentType);
	soap_serialize_PointerTons1__resCreateContent(soap, &a->createReservation);
	soap_serialize_PointerTons1__modifyResContent(soap, &a->modifyReservation);
	soap_serialize_PointerTons1__globalReservationId(soap, &a->cancelReservation);
	soap_serialize_PointerTons1__globalReservationId(soap, &a->queryReservation);
	soap_serialize_PointerTons1__listRequest(soap, &a->listReservations);
	soap_serialize_PointerTons1__createPathContent(soap, &a->createPath);
	soap_serialize_PointerTons1__refreshPathContent(soap, &a->refreshPath);
	soap_serialize_PointerTons1__teardownPathContent(soap, &a->teardownPath);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__forwardPayload(struct soap *soap, const char *tag, int id, const struct ns1__forwardPayload *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__forwardPayload), type))
		return soap->error;
	if (a->contentType)
	{	if (soap_out_string(soap, "ns1:contentType", -1, &a->contentType, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:contentType"))
		return soap->error;
	if (soap_out_PointerTons1__resCreateContent(soap, "ns1:createReservation", -1, &a->createReservation, ""))
		return soap->error;
	if (soap_out_PointerTons1__modifyResContent(soap, "ns1:modifyReservation", -1, &a->modifyReservation, ""))
		return soap->error;
	if (soap_out_PointerTons1__globalReservationId(soap, "ns1:cancelReservation", -1, &a->cancelReservation, ""))
		return soap->error;
	if (soap_out_PointerTons1__globalReservationId(soap, "ns1:queryReservation", -1, &a->queryReservation, ""))
		return soap->error;
	if (soap_out_PointerTons1__listRequest(soap, "ns1:listReservations", -1, &a->listReservations, ""))
		return soap->error;
	if (soap_out_PointerTons1__createPathContent(soap, "ns1:createPath", -1, &a->createPath, ""))
		return soap->error;
	if (soap_out_PointerTons1__refreshPathContent(soap, "ns1:refreshPath", -1, &a->refreshPath, ""))
		return soap->error;
	if (soap_out_PointerTons1__teardownPathContent(soap, "ns1:teardownPath", -1, &a->teardownPath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__forwardPayload * SOAP_FMAC4 soap_in_ns1__forwardPayload(struct soap *soap, const char *tag, struct ns1__forwardPayload *a, const char *type)
{
	size_t soap_flag_contentType = 1;
	size_t soap_flag_createReservation = 1;
	size_t soap_flag_modifyReservation = 1;
	size_t soap_flag_cancelReservation = 1;
	size_t soap_flag_queryReservation = 1;
	size_t soap_flag_listReservations = 1;
	size_t soap_flag_createPath = 1;
	size_t soap_flag_refreshPath = 1;
	size_t soap_flag_teardownPath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__forwardPayload *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__forwardPayload, sizeof(struct ns1__forwardPayload), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__forwardPayload(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_contentType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:contentType", &a->contentType, "xsd:string"))
				{	soap_flag_contentType--;
					continue;
				}
			if (soap_flag_createReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__resCreateContent(soap, "ns1:createReservation", &a->createReservation, "ns1:resCreateContent"))
				{	soap_flag_createReservation--;
					continue;
				}
			if (soap_flag_modifyReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__modifyResContent(soap, "ns1:modifyReservation", &a->modifyReservation, "ns1:modifyResContent"))
				{	soap_flag_modifyReservation--;
					continue;
				}
			if (soap_flag_cancelReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__globalReservationId(soap, "ns1:cancelReservation", &a->cancelReservation, "ns1:globalReservationId"))
				{	soap_flag_cancelReservation--;
					continue;
				}
			if (soap_flag_queryReservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__globalReservationId(soap, "ns1:queryReservation", &a->queryReservation, "ns1:globalReservationId"))
				{	soap_flag_queryReservation--;
					continue;
				}
			if (soap_flag_listReservations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listRequest(soap, "ns1:listReservations", &a->listReservations, "ns1:listRequest"))
				{	soap_flag_listReservations--;
					continue;
				}
			if (soap_flag_createPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createPathContent(soap, "ns1:createPath", &a->createPath, "ns1:createPathContent"))
				{	soap_flag_createPath--;
					continue;
				}
			if (soap_flag_refreshPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__refreshPathContent(soap, "ns1:refreshPath", &a->refreshPath, "ns1:refreshPathContent"))
				{	soap_flag_refreshPath--;
					continue;
				}
			if (soap_flag_teardownPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__teardownPathContent(soap, "ns1:teardownPath", &a->teardownPath, "ns1:teardownPathContent"))
				{	soap_flag_teardownPath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__forwardPayload *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__forwardPayload, 0, sizeof(struct ns1__forwardPayload), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_contentType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__forwardPayload(struct soap *soap, const struct ns1__forwardPayload *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__forwardPayload);
	if (soap_out_ns1__forwardPayload(soap, tag?tag:"ns1:forwardPayload", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__forwardPayload * SOAP_FMAC4 soap_get_ns1__forwardPayload(struct soap *soap, struct ns1__forwardPayload *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__forwardPayload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__listReply(struct soap *soap, struct ns1__listReply *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeresDetails = 0;
	a->resDetails = NULL;
	a->totalResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__listReply(struct soap *soap, const struct ns1__listReply *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->resDetails)
	{	int i;
		for (i = 0; i < a->__sizeresDetails; i++)
		{
			soap_serialize_PointerTons1__resDetails(soap, a->resDetails + i);
		}
	}
	soap_serialize_PointerToint(soap, &a->totalResults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listReply(struct soap *soap, const char *tag, int id, const struct ns1__listReply *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listReply), type))
		return soap->error;
	soap_element_result(soap, "-sizeresDetails");
	if (a->resDetails)
	{	int i;
		for (i = 0; i < a->__sizeresDetails; i++)
			if (soap_out_PointerTons1__resDetails(soap, "ns1:resDetails", -1, a->resDetails + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToint(soap, "ns1:totalResults", -1, &a->totalResults, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__listReply * SOAP_FMAC4 soap_in_ns1__listReply(struct soap *soap, const char *tag, struct ns1__listReply *a, const char *type)
{
	struct soap_blist *soap_blist_resDetails = NULL;
	size_t soap_flag_totalResults = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__listReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listReply, sizeof(struct ns1__listReply), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__listReply(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:resDetails", 1, NULL))
			{	if (a->resDetails == NULL)
				{	if (soap_blist_resDetails == NULL)
						soap_blist_resDetails = soap_new_block(soap);
					a->resDetails = (struct ns1__resDetails **)soap_push_block(soap, soap_blist_resDetails, sizeof(struct ns1__resDetails *));
					if (a->resDetails == NULL)
						return NULL;
					*a->resDetails = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__resDetails(soap, "ns1:resDetails", a->resDetails, "ns1:resDetails"))
				{	a->__sizeresDetails++;
					a->resDetails = NULL;
					continue;
				}
			}
			if (soap_flag_totalResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:totalResults", &a->totalResults, "xsd:int"))
				{	soap_flag_totalResults--;
					continue;
				}
			soap_check_result(soap, "-sizeresDetails");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->resDetails)
			soap_pop_block(soap, soap_blist_resDetails);
		if (a->__sizeresDetails)
			a->resDetails = (struct ns1__resDetails **)soap_save_block(soap, soap_blist_resDetails, NULL, 1);
		else
		{	a->resDetails = NULL;
			if (soap_blist_resDetails)
				soap_end_block(soap, soap_blist_resDetails);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__listReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listReply, 0, sizeof(struct ns1__listReply), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__listReply(struct soap *soap, const struct ns1__listReply *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__listReply);
	if (soap_out_ns1__listReply(soap, tag?tag:"ns1:listReply", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__listReply * SOAP_FMAC4 soap_get_ns1__listReply(struct soap *soap, struct ns1__listReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__vlanTag(struct soap *soap, struct ns1__vlanTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	a->tagged = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__vlanTag(struct soap *soap, const struct ns1__vlanTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__vlanTag(struct soap *soap, const char *tag, int id, const struct ns1__vlanTag *a, const char *type)
{
	if (a->tagged)
		soap_set_attr(soap, "tagged", soap_xsd__boolean_2s(soap, *a->tagged), 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns1__vlanTag * SOAP_FMAC4 soap_in_ns1__vlanTag(struct soap *soap, const char *tag, struct ns1__vlanTag *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct ns1__vlanTag *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__vlanTag, sizeof(struct ns1__vlanTag), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_ns1__vlanTag(soap, a);
	{	const char *t = soap_attr_value(soap, "tagged", 0);
		if (t)
		{
			if (!(a->tagged = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->tagged))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_string(soap, tag, &a->__item, "ns1:vlanTag"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__vlanTag(struct soap *soap, const struct ns1__vlanTag *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__vlanTag);
	if (soap_out_ns1__vlanTag(soap, tag?tag:"ns1:vlanTag", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__vlanTag * SOAP_FMAC4 soap_get_ns1__vlanTag(struct soap *soap, struct ns1__vlanTag *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__vlanTag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listRequest_sequence(struct soap *soap, struct __ns1__listRequest_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->startTime);
	soap_default_LONG64(soap, &a->endTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listRequest_sequence(struct soap *soap, const struct __ns1__listRequest_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listRequest_sequence(struct soap *soap, const char *tag, int id, const struct __ns1__listRequest_sequence *a, const char *type)
{
	if (soap_out_LONG64(soap, "ns1:startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:endTime", -1, &a->endTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listRequest_sequence * SOAP_FMAC4 soap_in___ns1__listRequest_sequence(struct soap *soap, const char *tag, struct __ns1__listRequest_sequence *a, const char *type)
{
	size_t soap_flag_startTime = 1;
	size_t soap_flag_endTime = 1;
	short soap_flag;
	a = (struct __ns1__listRequest_sequence *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listRequest_sequence, sizeof(struct __ns1__listRequest_sequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listRequest_sequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:startTime", &a->startTime, "xsd:long"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:endTime", &a->endTime, "xsd:long"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0 || soap_flag_endTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listRequest_sequence(struct soap *soap, const struct __ns1__listRequest_sequence *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listRequest_sequence(soap, tag?tag:"-ns1:listRequest-sequence", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listRequest_sequence * SOAP_FMAC4 soap_get___ns1__listRequest_sequence(struct soap *soap, struct __ns1__listRequest_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listRequest_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__listRequest(struct soap *soap, struct ns1__listRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeresStatus = 0;
	a->resStatus = NULL;
	a->__size_listRequest_sequence = 0;
	a->__listRequest_sequence = NULL;
	soap_default_string(soap, &a->description);
	a->__sizelinkId = 0;
	a->linkId = NULL;
	a->__sizevlanTag = 0;
	a->vlanTag = NULL;
	a->resRequested = NULL;
	a->resOffset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__listRequest(struct soap *soap, const struct ns1__listRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->resStatus)
	{	int i;
		for (i = 0; i < a->__sizeresStatus; i++)
		{
			soap_serialize_string(soap, a->resStatus + i);
		}
	}
	if (a->__listRequest_sequence)
	{	int i;
		for (i = 0; i < a->__size_listRequest_sequence; i++)
		{
			soap_serialize___ns1__listRequest_sequence(soap, a->__listRequest_sequence + i);
		}
	}
	soap_serialize_string(soap, &a->description);
	if (a->linkId)
	{	int i;
		for (i = 0; i < a->__sizelinkId; i++)
		{
			soap_serialize_string(soap, a->linkId + i);
		}
	}
	if (a->vlanTag)
	{	int i;
		for (i = 0; i < a->__sizevlanTag; i++)
		{
			soap_serialize_PointerTons1__vlanTag(soap, a->vlanTag + i);
		}
	}
	soap_serialize_PointerToint(soap, &a->resRequested);
	soap_serialize_PointerToint(soap, &a->resOffset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listRequest(struct soap *soap, const char *tag, int id, const struct ns1__listRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listRequest), type))
		return soap->error;
	if (a->resStatus)
	{	int i;
		for (i = 0; i < a->__sizeresStatus; i++)
			if (soap_out_string(soap, "ns1:resStatus", -1, a->resStatus + i, ""))
				return soap->error;
	}
	if (a->__listRequest_sequence)
	{	int i;
		for (i = 0; i < a->__size_listRequest_sequence; i++)
			if (soap_out___ns1__listRequest_sequence(soap, "-listRequest-sequence", -1, a->__listRequest_sequence + i, ""))
				return soap->error;
	}
	if (soap_out_string(soap, "ns1:description", -1, &a->description, ""))
		return soap->error;
	if (a->linkId)
	{	int i;
		for (i = 0; i < a->__sizelinkId; i++)
			if (soap_out_string(soap, "ns1:linkId", -1, a->linkId + i, ""))
				return soap->error;
	}
	if (a->vlanTag)
	{	int i;
		for (i = 0; i < a->__sizevlanTag; i++)
			if (soap_out_PointerTons1__vlanTag(soap, "ns1:vlanTag", -1, a->vlanTag + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToint(soap, "ns1:resRequested", -1, &a->resRequested, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:resOffset", -1, &a->resOffset, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__listRequest * SOAP_FMAC4 soap_in_ns1__listRequest(struct soap *soap, const char *tag, struct ns1__listRequest *a, const char *type)
{
	struct soap_blist *soap_blist_resStatus = NULL;
	struct soap_blist *soap_blist___listRequest_sequence = NULL;
	size_t soap_flag_description = 1;
	struct soap_blist *soap_blist_linkId = NULL;
	struct soap_blist *soap_blist_vlanTag = NULL;
	size_t soap_flag_resRequested = 1;
	size_t soap_flag_resOffset = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__listRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listRequest, sizeof(struct ns1__listRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__listRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:resStatus", 1, NULL))
			{	if (a->resStatus == NULL)
				{	if (soap_blist_resStatus == NULL)
						soap_blist_resStatus = soap_new_block(soap);
					a->resStatus = (char **)soap_push_block(soap, soap_blist_resStatus, sizeof(char *));
					if (a->resStatus == NULL)
						return NULL;
					*a->resStatus = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns1:resStatus", a->resStatus, "xsd:string"))
				{	a->__sizeresStatus++;
					a->resStatus = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__listRequest_sequence == NULL)
				{	if (soap_blist___listRequest_sequence == NULL)
						soap_blist___listRequest_sequence = soap_new_block(soap);
					a->__listRequest_sequence = (struct __ns1__listRequest_sequence *)soap_push_block(soap, soap_blist___listRequest_sequence, sizeof(struct __ns1__listRequest_sequence));
					if (a->__listRequest_sequence == NULL)
						return NULL;
					soap_default___ns1__listRequest_sequence(soap, a->__listRequest_sequence);
				}
				if (soap_in___ns1__listRequest_sequence(soap, "-listRequest-sequence", a->__listRequest_sequence, "-ns1:listRequest-sequence"))
				{	a->__size_listRequest_sequence++;
					a->__listRequest_sequence = NULL;
					continue;
				}
			}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:linkId", 1, NULL))
			{	if (a->linkId == NULL)
				{	if (soap_blist_linkId == NULL)
						soap_blist_linkId = soap_new_block(soap);
					a->linkId = (char **)soap_push_block(soap, soap_blist_linkId, sizeof(char *));
					if (a->linkId == NULL)
						return NULL;
					*a->linkId = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns1:linkId", a->linkId, "xsd:string"))
				{	a->__sizelinkId++;
					a->linkId = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:vlanTag", 1, NULL))
			{	if (a->vlanTag == NULL)
				{	if (soap_blist_vlanTag == NULL)
						soap_blist_vlanTag = soap_new_block(soap);
					a->vlanTag = (struct ns1__vlanTag **)soap_push_block(soap, soap_blist_vlanTag, sizeof(struct ns1__vlanTag *));
					if (a->vlanTag == NULL)
						return NULL;
					*a->vlanTag = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__vlanTag(soap, "ns1:vlanTag", a->vlanTag, "ns1:vlanTag"))
				{	a->__sizevlanTag++;
					a->vlanTag = NULL;
					continue;
				}
			}
			if (soap_flag_resRequested && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:resRequested", &a->resRequested, "xsd:int"))
				{	soap_flag_resRequested--;
					continue;
				}
			if (soap_flag_resOffset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:resOffset", &a->resOffset, "xsd:int"))
				{	soap_flag_resOffset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->resStatus)
			soap_pop_block(soap, soap_blist_resStatus);
		if (a->__sizeresStatus)
			a->resStatus = (char **)soap_save_block(soap, soap_blist_resStatus, NULL, 1);
		else
		{	a->resStatus = NULL;
			if (soap_blist_resStatus)
				soap_end_block(soap, soap_blist_resStatus);
		}
		if (a->__listRequest_sequence)
			soap_pop_block(soap, soap_blist___listRequest_sequence);
		if (a->__size_listRequest_sequence)
			a->__listRequest_sequence = (struct __ns1__listRequest_sequence *)soap_save_block(soap, soap_blist___listRequest_sequence, NULL, 1);
		else
		{	a->__listRequest_sequence = NULL;
			if (soap_blist___listRequest_sequence)
				soap_end_block(soap, soap_blist___listRequest_sequence);
		}
		if (a->linkId)
			soap_pop_block(soap, soap_blist_linkId);
		if (a->__sizelinkId)
			a->linkId = (char **)soap_save_block(soap, soap_blist_linkId, NULL, 1);
		else
		{	a->linkId = NULL;
			if (soap_blist_linkId)
				soap_end_block(soap, soap_blist_linkId);
		}
		if (a->vlanTag)
			soap_pop_block(soap, soap_blist_vlanTag);
		if (a->__sizevlanTag)
			a->vlanTag = (struct ns1__vlanTag **)soap_save_block(soap, soap_blist_vlanTag, NULL, 1);
		else
		{	a->vlanTag = NULL;
			if (soap_blist_vlanTag)
				soap_end_block(soap, soap_blist_vlanTag);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__listRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listRequest, 0, sizeof(struct ns1__listRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeresStatus > 5))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__listRequest(struct soap *soap, const struct ns1__listRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__listRequest);
	if (soap_out_ns1__listRequest(soap, tag?tag:"ns1:listRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__listRequest * SOAP_FMAC4 soap_get_ns1__listRequest(struct soap *soap, struct ns1__listRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__teardownPathResponseContent(struct soap *soap, struct ns1__teardownPathResponseContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->globalReservationId);
	soap_default_string(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__teardownPathResponseContent(struct soap *soap, const struct ns1__teardownPathResponseContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->globalReservationId);
	soap_serialize_string(soap, &a->status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__teardownPathResponseContent(struct soap *soap, const char *tag, int id, const struct ns1__teardownPathResponseContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__teardownPathResponseContent), type))
		return soap->error;
	if (a->globalReservationId)
		soap_element_result(soap, "ns1:globalReservationId");
	if (a->globalReservationId)
	{	if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:globalReservationId"))
		return soap->error;
	if (a->status)
	{	if (soap_out_string(soap, "ns1:status", -1, &a->status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:status"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__teardownPathResponseContent * SOAP_FMAC4 soap_in_ns1__teardownPathResponseContent(struct soap *soap, const char *tag, struct ns1__teardownPathResponseContent *a, const char *type)
{
	size_t soap_flag_globalReservationId = 1;
	size_t soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__teardownPathResponseContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__teardownPathResponseContent, sizeof(struct ns1__teardownPathResponseContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__teardownPathResponseContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string"))
				{	soap_flag_globalReservationId--;
					continue;
				}
			if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:status", &a->status, "xsd:string"))
				{	soap_flag_status--;
					continue;
				}
			soap_check_result(soap, "ns1:globalReservationId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__teardownPathResponseContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__teardownPathResponseContent, 0, sizeof(struct ns1__teardownPathResponseContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__teardownPathResponseContent(struct soap *soap, const struct ns1__teardownPathResponseContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__teardownPathResponseContent);
	if (soap_out_ns1__teardownPathResponseContent(soap, tag?tag:"ns1:teardownPathResponseContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__teardownPathResponseContent * SOAP_FMAC4 soap_get_ns1__teardownPathResponseContent(struct soap *soap, struct ns1__teardownPathResponseContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__teardownPathResponseContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__teardownPathContent(struct soap *soap, struct ns1__teardownPathContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->token);
	soap_default_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__teardownPathContent(struct soap *soap, const struct ns1__teardownPathContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->token);
	soap_serialize_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__teardownPathContent(struct soap *soap, const char *tag, int id, const struct ns1__teardownPathContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__teardownPathContent), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:token", -1, &a->token, ""))
		return soap->error;
	if (a->globalReservationId)
	{	if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:globalReservationId"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__teardownPathContent * SOAP_FMAC4 soap_in_ns1__teardownPathContent(struct soap *soap, const char *tag, struct ns1__teardownPathContent *a, const char *type)
{
	size_t soap_flag_token = 1;
	size_t soap_flag_globalReservationId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__teardownPathContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__teardownPathContent, sizeof(struct ns1__teardownPathContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__teardownPathContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:token", &a->token, "xsd:string"))
				{	soap_flag_token--;
					continue;
				}
			if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string"))
				{	soap_flag_globalReservationId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__teardownPathContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__teardownPathContent, 0, sizeof(struct ns1__teardownPathContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__teardownPathContent(struct soap *soap, const struct ns1__teardownPathContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__teardownPathContent);
	if (soap_out_ns1__teardownPathContent(soap, tag?tag:"ns1:teardownPathContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__teardownPathContent * SOAP_FMAC4 soap_get_ns1__teardownPathContent(struct soap *soap, struct ns1__teardownPathContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__teardownPathContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__refreshPathResponseContent(struct soap *soap, struct ns1__refreshPathResponseContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->globalReservationId);
	soap_default_string(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__refreshPathResponseContent(struct soap *soap, const struct ns1__refreshPathResponseContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->globalReservationId);
	soap_serialize_string(soap, &a->status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__refreshPathResponseContent(struct soap *soap, const char *tag, int id, const struct ns1__refreshPathResponseContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__refreshPathResponseContent), type))
		return soap->error;
	if (a->globalReservationId)
		soap_element_result(soap, "ns1:globalReservationId");
	if (a->globalReservationId)
	{	if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:globalReservationId"))
		return soap->error;
	if (a->status)
	{	if (soap_out_string(soap, "ns1:status", -1, &a->status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:status"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__refreshPathResponseContent * SOAP_FMAC4 soap_in_ns1__refreshPathResponseContent(struct soap *soap, const char *tag, struct ns1__refreshPathResponseContent *a, const char *type)
{
	size_t soap_flag_globalReservationId = 1;
	size_t soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__refreshPathResponseContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__refreshPathResponseContent, sizeof(struct ns1__refreshPathResponseContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__refreshPathResponseContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string"))
				{	soap_flag_globalReservationId--;
					continue;
				}
			if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:status", &a->status, "xsd:string"))
				{	soap_flag_status--;
					continue;
				}
			soap_check_result(soap, "ns1:globalReservationId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__refreshPathResponseContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__refreshPathResponseContent, 0, sizeof(struct ns1__refreshPathResponseContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__refreshPathResponseContent(struct soap *soap, const struct ns1__refreshPathResponseContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__refreshPathResponseContent);
	if (soap_out_ns1__refreshPathResponseContent(soap, tag?tag:"ns1:refreshPathResponseContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__refreshPathResponseContent * SOAP_FMAC4 soap_get_ns1__refreshPathResponseContent(struct soap *soap, struct ns1__refreshPathResponseContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__refreshPathResponseContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__refreshPathContent(struct soap *soap, struct ns1__refreshPathContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->token);
	soap_default_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__refreshPathContent(struct soap *soap, const struct ns1__refreshPathContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->token);
	soap_serialize_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__refreshPathContent(struct soap *soap, const char *tag, int id, const struct ns1__refreshPathContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__refreshPathContent), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:token", -1, &a->token, ""))
		return soap->error;
	if (a->globalReservationId)
	{	if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:globalReservationId"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__refreshPathContent * SOAP_FMAC4 soap_in_ns1__refreshPathContent(struct soap *soap, const char *tag, struct ns1__refreshPathContent *a, const char *type)
{
	size_t soap_flag_token = 1;
	size_t soap_flag_globalReservationId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__refreshPathContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__refreshPathContent, sizeof(struct ns1__refreshPathContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__refreshPathContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:token", &a->token, "xsd:string"))
				{	soap_flag_token--;
					continue;
				}
			if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string"))
				{	soap_flag_globalReservationId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__refreshPathContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__refreshPathContent, 0, sizeof(struct ns1__refreshPathContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__refreshPathContent(struct soap *soap, const struct ns1__refreshPathContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__refreshPathContent);
	if (soap_out_ns1__refreshPathContent(soap, tag?tag:"ns1:refreshPathContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__refreshPathContent * SOAP_FMAC4 soap_get_ns1__refreshPathContent(struct soap *soap, struct ns1__refreshPathContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__refreshPathContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__createPathResponseContent(struct soap *soap, struct ns1__createPathResponseContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->globalReservationId);
	soap_default_string(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__createPathResponseContent(struct soap *soap, const struct ns1__createPathResponseContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->globalReservationId);
	soap_serialize_string(soap, &a->status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createPathResponseContent(struct soap *soap, const char *tag, int id, const struct ns1__createPathResponseContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createPathResponseContent), type))
		return soap->error;
	if (a->globalReservationId)
		soap_element_result(soap, "ns1:globalReservationId");
	if (a->globalReservationId)
	{	if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:globalReservationId"))
		return soap->error;
	if (a->status)
	{	if (soap_out_string(soap, "ns1:status", -1, &a->status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:status"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__createPathResponseContent * SOAP_FMAC4 soap_in_ns1__createPathResponseContent(struct soap *soap, const char *tag, struct ns1__createPathResponseContent *a, const char *type)
{
	size_t soap_flag_globalReservationId = 1;
	size_t soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__createPathResponseContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createPathResponseContent, sizeof(struct ns1__createPathResponseContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__createPathResponseContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string"))
				{	soap_flag_globalReservationId--;
					continue;
				}
			if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:status", &a->status, "xsd:string"))
				{	soap_flag_status--;
					continue;
				}
			soap_check_result(soap, "ns1:globalReservationId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__createPathResponseContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createPathResponseContent, 0, sizeof(struct ns1__createPathResponseContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__createPathResponseContent(struct soap *soap, const struct ns1__createPathResponseContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__createPathResponseContent);
	if (soap_out_ns1__createPathResponseContent(soap, tag?tag:"ns1:createPathResponseContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createPathResponseContent * SOAP_FMAC4 soap_get_ns1__createPathResponseContent(struct soap *soap, struct ns1__createPathResponseContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createPathResponseContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__createPathContent(struct soap *soap, struct ns1__createPathContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->token);
	soap_default_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__createPathContent(struct soap *soap, const struct ns1__createPathContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->token);
	soap_serialize_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createPathContent(struct soap *soap, const char *tag, int id, const struct ns1__createPathContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createPathContent), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:token", -1, &a->token, ""))
		return soap->error;
	if (a->globalReservationId)
	{	if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:globalReservationId"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__createPathContent * SOAP_FMAC4 soap_in_ns1__createPathContent(struct soap *soap, const char *tag, struct ns1__createPathContent *a, const char *type)
{
	size_t soap_flag_token = 1;
	size_t soap_flag_globalReservationId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__createPathContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createPathContent, sizeof(struct ns1__createPathContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__createPathContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:token", &a->token, "xsd:string"))
				{	soap_flag_token--;
					continue;
				}
			if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string"))
				{	soap_flag_globalReservationId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__createPathContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createPathContent, 0, sizeof(struct ns1__createPathContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__createPathContent(struct soap *soap, const struct ns1__createPathContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__createPathContent);
	if (soap_out_ns1__createPathContent(soap, tag?tag:"ns1:createPathContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createPathContent * SOAP_FMAC4 soap_get_ns1__createPathContent(struct soap *soap, struct ns1__createPathContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createPathContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__CtrlPlaneTopologyContent(struct soap *soap, struct ns3__CtrlPlaneTopologyContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->idcId);
	a->__sizepath = 0;
	a->path = NULL;
	a->__sizedomain = 0;
	a->domain = NULL;
	a->__sizedomainSignature = 0;
	a->domainSignature = NULL;
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__CtrlPlaneTopologyContent(struct soap *soap, const struct ns3__CtrlPlaneTopologyContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->idcId);
	if (a->path)
	{	int i;
		for (i = 0; i < a->__sizepath; i++)
		{
			soap_serialize_PointerTons3__CtrlPlanePathContent(soap, a->path + i);
		}
	}
	if (a->domain)
	{	int i;
		for (i = 0; i < a->__sizedomain; i++)
		{
			soap_serialize_PointerTons3__CtrlPlaneDomainContent(soap, a->domain + i);
		}
	}
	if (a->domainSignature)
	{	int i;
		for (i = 0; i < a->__sizedomainSignature; i++)
		{
			soap_serialize_PointerTons3__CtrlPlaneDomainSignatureContent(soap, a->domainSignature + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CtrlPlaneTopologyContent(struct soap *soap, const char *tag, int id, const struct ns3__CtrlPlaneTopologyContent *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CtrlPlaneTopologyContent), type))
		return soap->error;
	if (a->idcId)
	{	if (soap_out_string(soap, "ns3:idcId", -1, &a->idcId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns3:idcId"))
		return soap->error;
	if (a->path)
	{	int i;
		for (i = 0; i < a->__sizepath; i++)
			if (soap_out_PointerTons3__CtrlPlanePathContent(soap, "ns3:path", -1, a->path + i, ""))
				return soap->error;
	}
	if (a->domain)
	{	int i;
		for (i = 0; i < a->__sizedomain; i++)
			if (soap_out_PointerTons3__CtrlPlaneDomainContent(soap, "ns3:domain", -1, a->domain + i, ""))
				return soap->error;
	}
	if (a->domainSignature)
	{	int i;
		for (i = 0; i < a->__sizedomainSignature; i++)
			if (soap_out_PointerTons3__CtrlPlaneDomainSignatureContent(soap, "ns3:domainSignature", -1, a->domainSignature + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__CtrlPlaneTopologyContent * SOAP_FMAC4 soap_in_ns3__CtrlPlaneTopologyContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneTopologyContent *a, const char *type)
{
	size_t soap_flag_idcId = 1;
	struct soap_blist *soap_blist_path = NULL;
	struct soap_blist *soap_blist_domain = NULL;
	struct soap_blist *soap_blist_domainSignature = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__CtrlPlaneTopologyContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CtrlPlaneTopologyContent, sizeof(struct ns3__CtrlPlaneTopologyContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__CtrlPlaneTopologyContent(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idcId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:idcId", &a->idcId, "xsd:string"))
				{	soap_flag_idcId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:path", 1, NULL))
			{	if (a->path == NULL)
				{	if (soap_blist_path == NULL)
						soap_blist_path = soap_new_block(soap);
					a->path = (struct ns3__CtrlPlanePathContent **)soap_push_block(soap, soap_blist_path, sizeof(struct ns3__CtrlPlanePathContent *));
					if (a->path == NULL)
						return NULL;
					*a->path = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons3__CtrlPlanePathContent(soap, "ns3:path", a->path, "ns3:CtrlPlanePathContent"))
				{	a->__sizepath++;
					a->path = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:domain", 1, NULL))
			{	if (a->domain == NULL)
				{	if (soap_blist_domain == NULL)
						soap_blist_domain = soap_new_block(soap);
					a->domain = (struct ns3__CtrlPlaneDomainContent **)soap_push_block(soap, soap_blist_domain, sizeof(struct ns3__CtrlPlaneDomainContent *));
					if (a->domain == NULL)
						return NULL;
					*a->domain = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons3__CtrlPlaneDomainContent(soap, "ns3:domain", a->domain, "ns3:CtrlPlaneDomainContent"))
				{	a->__sizedomain++;
					a->domain = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:domainSignature", 1, NULL))
			{	if (a->domainSignature == NULL)
				{	if (soap_blist_domainSignature == NULL)
						soap_blist_domainSignature = soap_new_block(soap);
					a->domainSignature = (struct ns3__CtrlPlaneDomainSignatureContent **)soap_push_block(soap, soap_blist_domainSignature, sizeof(struct ns3__CtrlPlaneDomainSignatureContent *));
					if (a->domainSignature == NULL)
						return NULL;
					*a->domainSignature = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons3__CtrlPlaneDomainSignatureContent(soap, "ns3:domainSignature", a->domainSignature, "ns3:CtrlPlaneDomainSignatureContent"))
				{	a->__sizedomainSignature++;
					a->domainSignature = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->path)
			soap_pop_block(soap, soap_blist_path);
		if (a->__sizepath)
			a->path = (struct ns3__CtrlPlanePathContent **)soap_save_block(soap, soap_blist_path, NULL, 1);
		else
		{	a->path = NULL;
			if (soap_blist_path)
				soap_end_block(soap, soap_blist_path);
		}
		if (a->domain)
			soap_pop_block(soap, soap_blist_domain);
		if (a->__sizedomain)
			a->domain = (struct ns3__CtrlPlaneDomainContent **)soap_save_block(soap, soap_blist_domain, NULL, 1);
		else
		{	a->domain = NULL;
			if (soap_blist_domain)
				soap_end_block(soap, soap_blist_domain);
		}
		if (a->domainSignature)
			soap_pop_block(soap, soap_blist_domainSignature);
		if (a->__sizedomainSignature)
			a->domainSignature = (struct ns3__CtrlPlaneDomainSignatureContent **)soap_save_block(soap, soap_blist_domainSignature, NULL, 1);
		else
		{	a->domainSignature = NULL;
			if (soap_blist_domainSignature)
				soap_end_block(soap, soap_blist_domainSignature);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneTopologyContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CtrlPlaneTopologyContent, 0, sizeof(struct ns3__CtrlPlaneTopologyContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idcId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CtrlPlaneTopologyContent(struct soap *soap, const struct ns3__CtrlPlaneTopologyContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CtrlPlaneTopologyContent);
	if (soap_out_ns3__CtrlPlaneTopologyContent(soap, tag?tag:"ns3:CtrlPlaneTopologyContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneTopologyContent * SOAP_FMAC4 soap_get_ns3__CtrlPlaneTopologyContent(struct soap *soap, struct ns3__CtrlPlaneTopologyContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CtrlPlaneTopologyContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTopologyResponseContent(struct soap *soap, struct ns1__getTopologyResponseContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__topology = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTopologyResponseContent(struct soap *soap, const struct ns1__getTopologyResponseContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__CtrlPlaneTopologyContent(soap, &a->ns3__topology);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTopologyResponseContent(struct soap *soap, const char *tag, int id, const struct ns1__getTopologyResponseContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTopologyResponseContent), type))
		return soap->error;
	if (a->ns3__topology)
		soap_element_result(soap, "ns3:topology");
	if (a->ns3__topology)
	{	if (soap_out_PointerTons3__CtrlPlaneTopologyContent(soap, "ns3:topology", -1, &a->ns3__topology, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns3:topology"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTopologyResponseContent * SOAP_FMAC4 soap_in_ns1__getTopologyResponseContent(struct soap *soap, const char *tag, struct ns1__getTopologyResponseContent *a, const char *type)
{
	size_t soap_flag_ns3__topology = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTopologyResponseContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTopologyResponseContent, sizeof(struct ns1__getTopologyResponseContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTopologyResponseContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__topology && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__CtrlPlaneTopologyContent(soap, "ns3:topology", &a->ns3__topology, "ns3:CtrlPlaneTopologyContent"))
				{	soap_flag_ns3__topology--;
					continue;
				}
			soap_check_result(soap, "ns3:topology");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTopologyResponseContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTopologyResponseContent, 0, sizeof(struct ns1__getTopologyResponseContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__topology > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTopologyResponseContent(struct soap *soap, const struct ns1__getTopologyResponseContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTopologyResponseContent);
	if (soap_out_ns1__getTopologyResponseContent(soap, tag?tag:"ns1:getTopologyResponseContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTopologyResponseContent * SOAP_FMAC4 soap_get_ns1__getTopologyResponseContent(struct soap *soap, struct ns1__getTopologyResponseContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTopologyResponseContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTopologyContent(struct soap *soap, struct ns1__getTopologyContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->topologyType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTopologyContent(struct soap *soap, const struct ns1__getTopologyContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->topologyType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTopologyContent(struct soap *soap, const char *tag, int id, const struct ns1__getTopologyContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTopologyContent), type))
		return soap->error;
	if (a->topologyType)
	{	if (soap_out_string(soap, "ns1:topologyType", -1, &a->topologyType, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:topologyType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTopologyContent * SOAP_FMAC4 soap_in_ns1__getTopologyContent(struct soap *soap, const char *tag, struct ns1__getTopologyContent *a, const char *type)
{
	size_t soap_flag_topologyType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTopologyContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTopologyContent, sizeof(struct ns1__getTopologyContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTopologyContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:topologyType", &a->topologyType, "xsd:string"))
				{	soap_flag_topologyType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTopologyContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTopologyContent, 0, sizeof(struct ns1__getTopologyContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTopologyContent(struct soap *soap, const struct ns1__getTopologyContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTopologyContent);
	if (soap_out_ns1__getTopologyContent(soap, tag?tag:"ns1:getTopologyContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTopologyContent * SOAP_FMAC4 soap_get_ns1__getTopologyContent(struct soap *soap, struct ns1__getTopologyContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTopologyContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__resDetails(struct soap *soap, struct ns1__resDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->globalReservationId);
	soap_default_string(soap, &a->login);
	soap_default_string(soap, &a->status);
	soap_default_LONG64(soap, &a->startTime);
	soap_default_LONG64(soap, &a->endTime);
	soap_default_LONG64(soap, &a->createTime);
	soap_default_int(soap, &a->bandwidth);
	soap_default_string(soap, &a->description);
	a->pathInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__resDetails(struct soap *soap, const struct ns1__resDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->globalReservationId);
	soap_serialize_string(soap, &a->login);
	soap_serialize_string(soap, &a->status);
	soap_embedded(soap, &a->bandwidth, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->description);
	soap_serialize_PointerTons1__pathInfo(soap, &a->pathInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__resDetails(struct soap *soap, const char *tag, int id, const struct ns1__resDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__resDetails), type))
		return soap->error;
	if (a->globalReservationId)
		soap_element_result(soap, "ns1:globalReservationId");
	if (a->globalReservationId)
	{	if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:globalReservationId"))
		return soap->error;
	if (a->login)
	{	if (soap_out_string(soap, "ns1:login", -1, &a->login, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:login"))
		return soap->error;
	if (a->status)
	{	if (soap_out_string(soap, "ns1:status", -1, &a->status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:status"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:endTime", -1, &a->endTime, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:createTime", -1, &a->createTime, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:bandwidth", -1, &a->bandwidth, ""))
		return soap->error;
	if (a->description)
	{	if (soap_out_string(soap, "ns1:description", -1, &a->description, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:description"))
		return soap->error;
	if (a->pathInfo)
	{	if (soap_out_PointerTons1__pathInfo(soap, "ns1:pathInfo", -1, &a->pathInfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:pathInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__resDetails * SOAP_FMAC4 soap_in_ns1__resDetails(struct soap *soap, const char *tag, struct ns1__resDetails *a, const char *type)
{
	size_t soap_flag_globalReservationId = 1;
	size_t soap_flag_login = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_startTime = 1;
	size_t soap_flag_endTime = 1;
	size_t soap_flag_createTime = 1;
	size_t soap_flag_bandwidth = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_pathInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__resDetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__resDetails, sizeof(struct ns1__resDetails), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__resDetails(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string"))
				{	soap_flag_globalReservationId--;
					continue;
				}
			if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:login", &a->login, "xsd:string"))
				{	soap_flag_login--;
					continue;
				}
			if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:status", &a->status, "xsd:string"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:startTime", &a->startTime, "xsd:long"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:endTime", &a->endTime, "xsd:long"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap_flag_createTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:createTime", &a->createTime, "xsd:long"))
				{	soap_flag_createTime--;
					continue;
				}
			if (soap_flag_bandwidth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:bandwidth", &a->bandwidth, "xsd:int"))
				{	soap_flag_bandwidth--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_pathInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__pathInfo(soap, "ns1:pathInfo", &a->pathInfo, "ns1:pathInfo"))
				{	soap_flag_pathInfo--;
					continue;
				}
			soap_check_result(soap, "ns1:globalReservationId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__resDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__resDetails, 0, sizeof(struct ns1__resDetails), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0 || soap_flag_login > 0 || soap_flag_status > 0 || soap_flag_startTime > 0 || soap_flag_endTime > 0 || soap_flag_createTime > 0 || soap_flag_bandwidth > 0 || soap_flag_description > 0 || soap_flag_pathInfo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__resDetails(struct soap *soap, const struct ns1__resDetails *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__resDetails);
	if (soap_out_ns1__resDetails(soap, tag?tag:"ns1:resDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__resDetails * SOAP_FMAC4 soap_get_ns1__resDetails(struct soap *soap, struct ns1__resDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__resDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__modifyResReply(struct soap *soap, struct ns1__modifyResReply *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->reservation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__modifyResReply(struct soap *soap, const struct ns1__modifyResReply *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__resDetails(soap, &a->reservation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyResReply(struct soap *soap, const char *tag, int id, const struct ns1__modifyResReply *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifyResReply), type))
		return soap->error;
	if (a->reservation)
		soap_element_result(soap, "ns1:reservation");
	if (a->reservation)
	{	if (soap_out_PointerTons1__resDetails(soap, "ns1:reservation", -1, &a->reservation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:reservation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__modifyResReply * SOAP_FMAC4 soap_in_ns1__modifyResReply(struct soap *soap, const char *tag, struct ns1__modifyResReply *a, const char *type)
{
	size_t soap_flag_reservation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__modifyResReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyResReply, sizeof(struct ns1__modifyResReply), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__modifyResReply(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reservation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__resDetails(soap, "ns1:reservation", &a->reservation, "ns1:resDetails"))
				{	soap_flag_reservation--;
					continue;
				}
			soap_check_result(soap, "ns1:reservation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__modifyResReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifyResReply, 0, sizeof(struct ns1__modifyResReply), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reservation > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__modifyResReply(struct soap *soap, const struct ns1__modifyResReply *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__modifyResReply);
	if (soap_out_ns1__modifyResReply(soap, tag?tag:"ns1:modifyResReply", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modifyResReply * SOAP_FMAC4 soap_get_ns1__modifyResReply(struct soap *soap, struct ns1__modifyResReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyResReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__modifyResContent(struct soap *soap, struct ns1__modifyResContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->globalReservationId);
	soap_default_LONG64(soap, &a->startTime);
	soap_default_LONG64(soap, &a->endTime);
	soap_default_int(soap, &a->bandwidth);
	soap_default_string(soap, &a->description);
	a->pathInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__modifyResContent(struct soap *soap, const struct ns1__modifyResContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->globalReservationId);
	soap_embedded(soap, &a->bandwidth, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->description);
	soap_serialize_PointerTons1__pathInfo(soap, &a->pathInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyResContent(struct soap *soap, const char *tag, int id, const struct ns1__modifyResContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifyResContent), type))
		return soap->error;
	if (a->globalReservationId)
	{	if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:globalReservationId"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:endTime", -1, &a->endTime, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:bandwidth", -1, &a->bandwidth, ""))
		return soap->error;
	if (a->description)
	{	if (soap_out_string(soap, "ns1:description", -1, &a->description, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:description"))
		return soap->error;
	if (soap_out_PointerTons1__pathInfo(soap, "ns1:pathInfo", -1, &a->pathInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__modifyResContent * SOAP_FMAC4 soap_in_ns1__modifyResContent(struct soap *soap, const char *tag, struct ns1__modifyResContent *a, const char *type)
{
	size_t soap_flag_globalReservationId = 1;
	size_t soap_flag_startTime = 1;
	size_t soap_flag_endTime = 1;
	size_t soap_flag_bandwidth = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_pathInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__modifyResContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyResContent, sizeof(struct ns1__modifyResContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__modifyResContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string"))
				{	soap_flag_globalReservationId--;
					continue;
				}
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:startTime", &a->startTime, "xsd:long"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:endTime", &a->endTime, "xsd:long"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap_flag_bandwidth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:bandwidth", &a->bandwidth, "xsd:int"))
				{	soap_flag_bandwidth--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_pathInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__pathInfo(soap, "ns1:pathInfo", &a->pathInfo, "ns1:pathInfo"))
				{	soap_flag_pathInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__modifyResContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifyResContent, 0, sizeof(struct ns1__modifyResContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0 || soap_flag_startTime > 0 || soap_flag_endTime > 0 || soap_flag_bandwidth > 0 || soap_flag_description > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__modifyResContent(struct soap *soap, const struct ns1__modifyResContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__modifyResContent);
	if (soap_out_ns1__modifyResContent(soap, tag?tag:"ns1:modifyResContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modifyResContent * SOAP_FMAC4 soap_get_ns1__modifyResContent(struct soap *soap, struct ns1__modifyResContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__modifyResContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__createReply(struct soap *soap, struct ns1__createReply *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->globalReservationId);
	soap_default_string(soap, &a->token);
	soap_default_string(soap, &a->status);
	a->pathInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__createReply(struct soap *soap, const struct ns1__createReply *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->globalReservationId);
	soap_serialize_string(soap, &a->token);
	soap_serialize_string(soap, &a->status);
	soap_serialize_PointerTons1__pathInfo(soap, &a->pathInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createReply(struct soap *soap, const char *tag, int id, const struct ns1__createReply *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createReply), type))
		return soap->error;
	if (a->globalReservationId)
		soap_element_result(soap, "ns1:globalReservationId");
	if (a->globalReservationId)
	{	if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:globalReservationId"))
		return soap->error;
	if (soap_out_string(soap, "ns1:token", -1, &a->token, ""))
		return soap->error;
	if (a->status)
	{	if (soap_out_string(soap, "ns1:status", -1, &a->status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:status"))
		return soap->error;
	if (soap_out_PointerTons1__pathInfo(soap, "ns1:pathInfo", -1, &a->pathInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__createReply * SOAP_FMAC4 soap_in_ns1__createReply(struct soap *soap, const char *tag, struct ns1__createReply *a, const char *type)
{
	size_t soap_flag_globalReservationId = 1;
	size_t soap_flag_token = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_pathInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__createReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createReply, sizeof(struct ns1__createReply), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__createReply(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string"))
				{	soap_flag_globalReservationId--;
					continue;
				}
			if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:token", &a->token, "xsd:string"))
				{	soap_flag_token--;
					continue;
				}
			if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:status", &a->status, "xsd:string"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_pathInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__pathInfo(soap, "ns1:pathInfo", &a->pathInfo, "ns1:pathInfo"))
				{	soap_flag_pathInfo--;
					continue;
				}
			soap_check_result(soap, "ns1:globalReservationId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__createReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createReply, 0, sizeof(struct ns1__createReply), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__createReply(struct soap *soap, const struct ns1__createReply *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__createReply);
	if (soap_out_ns1__createReply(soap, tag?tag:"ns1:createReply", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createReply * SOAP_FMAC4 soap_get_ns1__createReply(struct soap *soap, struct ns1__createReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__pathInfo(struct soap *soap, struct ns1__pathInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->pathSetupMode);
	soap_default_string(soap, &a->pathType);
	a->path = NULL;
	a->layer2Info = NULL;
	a->layer3Info = NULL;
	a->mplsInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__pathInfo(struct soap *soap, const struct ns1__pathInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->pathSetupMode);
	soap_serialize_string(soap, &a->pathType);
	soap_serialize_PointerTons3__CtrlPlanePathContent(soap, &a->path);
	soap_serialize_PointerTons1__layer2Info(soap, &a->layer2Info);
	soap_serialize_PointerTons1__layer3Info(soap, &a->layer3Info);
	soap_serialize_PointerTons1__mplsInfo(soap, &a->mplsInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__pathInfo(struct soap *soap, const char *tag, int id, const struct ns1__pathInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__pathInfo), type))
		return soap->error;
	if (a->pathSetupMode)
	{	if (soap_out_string(soap, "ns1:pathSetupMode", -1, &a->pathSetupMode, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:pathSetupMode"))
		return soap->error;
	if (soap_out_string(soap, "ns1:pathType", -1, &a->pathType, ""))
		return soap->error;
	if (soap_out_PointerTons3__CtrlPlanePathContent(soap, "ns1:path", -1, &a->path, ""))
		return soap->error;
	if (soap_out_PointerTons1__layer2Info(soap, "ns1:layer2Info", -1, &a->layer2Info, ""))
		return soap->error;
	if (soap_out_PointerTons1__layer3Info(soap, "ns1:layer3Info", -1, &a->layer3Info, ""))
		return soap->error;
	if (soap_out_PointerTons1__mplsInfo(soap, "ns1:mplsInfo", -1, &a->mplsInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__pathInfo * SOAP_FMAC4 soap_in_ns1__pathInfo(struct soap *soap, const char *tag, struct ns1__pathInfo *a, const char *type)
{
	size_t soap_flag_pathSetupMode = 1;
	size_t soap_flag_pathType = 1;
	size_t soap_flag_path = 1;
	size_t soap_flag_layer2Info = 1;
	size_t soap_flag_layer3Info = 1;
	size_t soap_flag_mplsInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__pathInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__pathInfo, sizeof(struct ns1__pathInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__pathInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathSetupMode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:pathSetupMode", &a->pathSetupMode, "xsd:string"))
				{	soap_flag_pathSetupMode--;
					continue;
				}
			if (soap_flag_pathType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:pathType", &a->pathType, "xsd:string"))
				{	soap_flag_pathType--;
					continue;
				}
			if (soap_flag_path && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__CtrlPlanePathContent(soap, "ns1:path", &a->path, "ns3:CtrlPlanePathContent"))
				{	soap_flag_path--;
					continue;
				}
			if (soap_flag_layer2Info && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__layer2Info(soap, "ns1:layer2Info", &a->layer2Info, "ns1:layer2Info"))
				{	soap_flag_layer2Info--;
					continue;
				}
			if (soap_flag_layer3Info && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__layer3Info(soap, "ns1:layer3Info", &a->layer3Info, "ns1:layer3Info"))
				{	soap_flag_layer3Info--;
					continue;
				}
			if (soap_flag_mplsInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__mplsInfo(soap, "ns1:mplsInfo", &a->mplsInfo, "ns1:mplsInfo"))
				{	soap_flag_mplsInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__pathInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__pathInfo, 0, sizeof(struct ns1__pathInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathSetupMode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__pathInfo(struct soap *soap, const struct ns1__pathInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__pathInfo);
	if (soap_out_ns1__pathInfo(soap, tag?tag:"ns1:pathInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__pathInfo * SOAP_FMAC4 soap_get_ns1__pathInfo(struct soap *soap, struct ns1__pathInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__pathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__resCreateContent(struct soap *soap, struct ns1__resCreateContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->globalReservationId);
	soap_default_LONG64(soap, &a->startTime);
	soap_default_LONG64(soap, &a->endTime);
	soap_default_int(soap, &a->bandwidth);
	soap_default_string(soap, &a->description);
	a->pathInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__resCreateContent(struct soap *soap, const struct ns1__resCreateContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->globalReservationId);
	soap_embedded(soap, &a->bandwidth, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->description);
	soap_serialize_PointerTons1__pathInfo(soap, &a->pathInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__resCreateContent(struct soap *soap, const char *tag, int id, const struct ns1__resCreateContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__resCreateContent), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:endTime", -1, &a->endTime, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:bandwidth", -1, &a->bandwidth, ""))
		return soap->error;
	if (a->description)
	{	if (soap_out_string(soap, "ns1:description", -1, &a->description, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:description"))
		return soap->error;
	if (a->pathInfo)
	{	if (soap_out_PointerTons1__pathInfo(soap, "ns1:pathInfo", -1, &a->pathInfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:pathInfo"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__resCreateContent * SOAP_FMAC4 soap_in_ns1__resCreateContent(struct soap *soap, const char *tag, struct ns1__resCreateContent *a, const char *type)
{
	size_t soap_flag_globalReservationId = 1;
	size_t soap_flag_startTime = 1;
	size_t soap_flag_endTime = 1;
	size_t soap_flag_bandwidth = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_pathInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__resCreateContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__resCreateContent, sizeof(struct ns1__resCreateContent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__resCreateContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string"))
				{	soap_flag_globalReservationId--;
					continue;
				}
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:startTime", &a->startTime, "xsd:long"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:endTime", &a->endTime, "xsd:long"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap_flag_bandwidth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:bandwidth", &a->bandwidth, "xsd:int"))
				{	soap_flag_bandwidth--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_pathInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__pathInfo(soap, "ns1:pathInfo", &a->pathInfo, "ns1:pathInfo"))
				{	soap_flag_pathInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__resCreateContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__resCreateContent, 0, sizeof(struct ns1__resCreateContent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0 || soap_flag_endTime > 0 || soap_flag_bandwidth > 0 || soap_flag_description > 0 || soap_flag_pathInfo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__resCreateContent(struct soap *soap, const struct ns1__resCreateContent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__resCreateContent);
	if (soap_out_ns1__resCreateContent(soap, tag?tag:"ns1:resCreateContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__resCreateContent * SOAP_FMAC4 soap_get_ns1__resCreateContent(struct soap *soap, struct ns1__resCreateContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__resCreateContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->xenc__EncryptedKey = NULL;
	a->xenc__ReferenceList = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->xenc__ReferenceList);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", a->SOAP_ENV__actor, 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", a->SOAP_ENV__role, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->xenc__ReferenceList, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_xenc__EncryptedKey = 1;
	size_t soap_flag_xenc__ReferenceList = 1;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	soap_flag_xenc__EncryptedKey--;
					continue;
				}
			if (soap_flag_xenc__ReferenceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->xenc__ReferenceList, ""))
				{	soap_flag_xenc__ReferenceList--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, 0, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Security);
	if (soap_out__wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DataReference = NULL;
	a->KeyReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->DataReference);
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->KeyReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, const struct __xenc__union_ReferenceList *a, const char *type)
{
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:DataReference", -1, &a->DataReference, ""))
		return soap->error;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", -1, &a->KeyReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_in___xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList *a, const char *type)
{
	size_t soap_flag_DataReference = 1;
	size_t soap_flag_KeyReference = 1;
	short soap_flag;
	a = (struct __xenc__union_ReferenceList *)soap_id_enter(soap, "", a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___xenc__union_ReferenceList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:DataReference", &a->DataReference, "xenc:ReferenceType"))
				{	soap_flag_DataReference--;
					continue;
				}
			if (soap_flag_KeyReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", &a->KeyReference, "xenc:ReferenceType"))
				{	soap_flag_KeyReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___xenc__union_ReferenceList(soap, tag?tag:"-xenc:union-ReferenceList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_get___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in___xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ReferenceList = 0;
	a->__union_ReferenceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < a->__size_ReferenceList; i++)
		{
			soap_serialize___xenc__union_ReferenceList(soap, a->__union_ReferenceList + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xenc__ReferenceList(struct soap *soap, const char *tag, int id, const struct _xenc__ReferenceList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xenc__ReferenceList), type))
		return soap->error;
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < a->__size_ReferenceList; i++)
			if (soap_out___xenc__union_ReferenceList(soap, "-union-ReferenceList", -1, a->__union_ReferenceList + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_in__xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList *a, const char *type)
{
	struct soap_blist *soap_blist___union_ReferenceList = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _xenc__ReferenceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xenc__ReferenceList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ReferenceList == NULL)
				{	if (soap_blist___union_ReferenceList == NULL)
						soap_blist___union_ReferenceList = soap_new_block(soap);
					a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_push_block(soap, soap_blist___union_ReferenceList, sizeof(struct __xenc__union_ReferenceList));
					if (a->__union_ReferenceList == NULL)
						return NULL;
					soap_default___xenc__union_ReferenceList(soap, a->__union_ReferenceList);
				}
				if (soap_in___xenc__union_ReferenceList(soap, "-union-ReferenceList", a->__union_ReferenceList, "-xenc:union-ReferenceList"))
				{	a->__size_ReferenceList++;
					a->__union_ReferenceList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ReferenceList)
			soap_pop_block(soap, soap_blist___union_ReferenceList);
		if (a->__size_ReferenceList)
			a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_save_block(soap, soap_blist___union_ReferenceList, NULL, 1);
		else
		{	a->__union_ReferenceList = NULL;
			if (soap_blist___union_ReferenceList)
				soap_end_block(soap, soap_blist___union_ReferenceList);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xenc__ReferenceList, 0, sizeof(struct _xenc__ReferenceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__size_ReferenceList < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__xenc__ReferenceList);
	if (soap_out__xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_get__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in__xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Target);
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (a->Target)
		soap_set_attr(soap, "Target", a->Target, 1);
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertyType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Target", 0), &a->Target, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertyType, 0, sizeof(struct xenc__EncryptionPropertyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionPropertyType);
	if (soap_out_xenc__EncryptionPropertyType(soap, tag?tag:"xenc:EncryptionPropertyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEncryptionProperty = 0;
	a->EncryptionProperty = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < a->__sizeEncryptionProperty; i++)
		{
			soap_embedded(soap, a->EncryptionProperty + i, SOAP_TYPE_xenc__EncryptionPropertyType);
			soap_serialize_xenc__EncryptionPropertyType(soap, a->EncryptionProperty + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertiesType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertiesType), type))
		return soap->error;
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < a->__sizeEncryptionProperty; i++)
			if (soap_out_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", -1, a->EncryptionProperty + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist_EncryptionProperty = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertiesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptionProperty", 1, NULL))
			{	if (a->EncryptionProperty == NULL)
				{	if (soap_blist_EncryptionProperty == NULL)
						soap_blist_EncryptionProperty = soap_new_block(soap);
					a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_push_block(soap, soap_blist_EncryptionProperty, sizeof(struct xenc__EncryptionPropertyType));
					if (a->EncryptionProperty == NULL)
						return NULL;
					soap_default_xenc__EncryptionPropertyType(soap, a->EncryptionProperty);
				}
				soap_revert(soap);
				if (soap_in_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", a->EncryptionProperty, "xenc:EncryptionPropertyType"))
				{	a->__sizeEncryptionProperty++;
					a->EncryptionProperty = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EncryptionProperty)
			soap_pop_block(soap, soap_blist_EncryptionProperty);
		if (a->__sizeEncryptionProperty)
			a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_save_block(soap, soap_blist_EncryptionProperty, NULL, 1);
		else
		{	a->EncryptionProperty = NULL;
			if (soap_blist_EncryptionProperty)
				soap_end_block(soap, soap_blist_EncryptionProperty);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertiesType, 0, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEncryptionProperty < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionPropertiesType);
	if (soap_out_xenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__ReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__ReferenceType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__ReferenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_in_xenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__ReferenceType, 0, sizeof(struct xenc__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__ReferenceType);
	if (soap_out_xenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_get_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KA_Nonce);
	a->OriginatorKeyInfo = NULL;
	a->RecipientKeyInfo = NULL;
	soap_default_string(soap, &a->Algorithm);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KA_Nonce);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->OriginatorKeyInfo);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->RecipientKeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__AgreementMethodType(struct soap *soap, const char *tag, int id, const struct xenc__AgreementMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__AgreementMethodType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:KA-Nonce", -1, &a->KA_Nonce, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", -1, &a->OriginatorKeyInfo, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", -1, &a->RecipientKeyInfo, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_in_xenc__AgreementMethodType(struct soap *soap, const char *tag, struct xenc__AgreementMethodType *a, const char *type)
{
	size_t soap_flag_KA_Nonce = 1;
	size_t soap_flag_OriginatorKeyInfo = 1;
	size_t soap_flag_RecipientKeyInfo = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__AgreementMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__AgreementMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KA_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:KA-Nonce", &a->KA_Nonce, "xsd:string"))
				{	soap_flag_KA_Nonce--;
					continue;
				}
			if (soap_flag_OriginatorKeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", &a->OriginatorKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_OriginatorKeyInfo--;
					continue;
				}
			if (soap_flag_RecipientKeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", &a->RecipientKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_RecipientKeyInfo--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__AgreementMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__AgreementMethodType, 0, sizeof(struct xenc__AgreementMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__AgreementMethodType);
	if (soap_out_xenc__AgreementMethodType(soap, tag?tag:"xenc:AgreementMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_get_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__AgreementMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
	a->ReferenceList = NULL;
	soap_default_string(soap, &a->CarriedKeyName);
	soap_default_string(soap, &a->Recipient);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->ReferenceList);
	soap_serialize_string(soap, &a->CarriedKeyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedKeyType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", a->Recipient, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedKeyType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->ReferenceList, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:CarriedKeyName", -1, &a->CarriedKeyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_in_xenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	size_t soap_flag_ReferenceList = 1;
	size_t soap_flag_CarriedKeyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedKeyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedKeyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 0), &a->Recipient, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap_flag_ReferenceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->ReferenceList, ""))
				{	soap_flag_ReferenceList--;
					continue;
				}
			if (soap_flag_CarriedKeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:CarriedKeyName", &a->CarriedKeyName, "xsd:string"))
				{	soap_flag_CarriedKeyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedKeyType, 0, sizeof(struct xenc__EncryptedKeyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedKeyType);
	if (soap_out_xenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_get_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedDataType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedDataType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedDataType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_in_xenc__EncryptedDataType(struct soap *soap, const char *tag, struct xenc__EncryptedDataType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedDataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedDataType, 0, sizeof(struct xenc__EncryptedDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedDataType);
	if (soap_out_xenc__EncryptedDataType(soap, tag?tag:"xenc:EncryptedDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_get_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__TransformsType(struct soap *soap, const char *tag, int id, const struct xenc__TransformsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__TransformsType), type))
		return soap->error;
	if (soap_out__ds__Transform(soap, "ds:Transform", -1, &a->ds__Transform, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_in_xenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType *a, const char *type)
{
	size_t soap_flag_ds__Transform = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ds__Transform && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ds__Transform(soap, "ds:Transform", &a->ds__Transform, ""))
				{	soap_flag_ds__Transform--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__TransformsType, 0, sizeof(struct xenc__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__Transform > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__TransformsType);
	if (soap_out_xenc__TransformsType(soap, tag?tag:"xenc:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_get_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__CipherReferenceType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherReferenceType), type))
		return soap->error;
	if (soap_out_PointerToxenc__TransformsType(soap, "xenc:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_in_xenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__TransformsType(soap, "xenc:Transforms", &a->Transforms, "xenc:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherReferenceType, 0, sizeof(struct xenc__CipherReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__CipherReferenceType);
	if (soap_out_xenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_get_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->CipherValue);
	a->CipherReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->CipherValue);
	soap_serialize_PointerToxenc__CipherReferenceType(soap, &a->CipherReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherDataType(struct soap *soap, const char *tag, int id, const struct xenc__CipherDataType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherDataType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:CipherValue", -1, &a->CipherValue, ""))
		return soap->error;
	if (soap_out_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", -1, &a->CipherReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_in_xenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType *a, const char *type)
{
	size_t soap_flag_CipherValue = 1;
	size_t soap_flag_CipherReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherDataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CipherValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:CipherValue", &a->CipherValue, "xsd:string"))
				{	soap_flag_CipherValue--;
					continue;
				}
			if (soap_flag_CipherReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", &a->CipherReference, "xenc:CipherReferenceType"))
				{	soap_flag_CipherReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherDataType, 0, sizeof(struct xenc__CipherDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__CipherDataType);
	if (soap_out_xenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_get_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->KeySize = NULL;
	soap_default_string(soap, &a->OAEPparams);
	soap_default_string(soap, &a->Algorithm);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->KeySize);
	soap_serialize_string(soap, &a->OAEPparams);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "xenc:KeySize", -1, &a->KeySize, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:OAEPparams", -1, &a->OAEPparams, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_in_xenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType *a, const char *type)
{
	size_t soap_flag_KeySize = 1;
	size_t soap_flag_OAEPparams = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "xenc:KeySize", &a->KeySize, "xsd:int"))
				{	soap_flag_KeySize--;
					continue;
				}
			if (soap_flag_OAEPparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:OAEPparams", &a->OAEPparams, "xsd:string"))
				{	soap_flag_OAEPparams--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionMethodType, 0, sizeof(struct xenc__EncryptionMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionMethodType);
	if (soap_out_xenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_get_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_in_xenc__EncryptedType(struct soap *soap, const char *tag, struct xenc__EncryptedType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedType, 0, sizeof(struct xenc__EncryptedType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedType);
	if (soap_out_xenc__EncryptedType(soap, tag?tag:"xenc:EncryptedType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_get_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Modulus);
	soap_serialize_string(soap, &a->Exponent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (a->Modulus)
	{	if (soap_out_string(soap, "ds:Modulus", -1, &a->Modulus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Modulus"))
		return soap->error;
	if (a->Exponent)
	{	if (soap_out_string(soap, "ds:Exponent", -1, &a->Exponent, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Exponent"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Modulus", &a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Exponent", &a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, 0, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RSAKeyValueType);
	if (soap_out_ds__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->G);
	soap_serialize_string(soap, &a->Y);
	soap_serialize_string(soap, &a->J);
	soap_serialize_string(soap, &a->P);
	soap_serialize_string(soap, &a->Q);
	soap_serialize_string(soap, &a->Seed);
	soap_serialize_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, &a->G, ""))
		return soap->error;
	if (a->Y)
	{	if (soap_out_string(soap, "ds:Y", -1, &a->Y, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Y"))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, &a->J, ""))
		return soap->error;
	if (a->P)
	{	if (soap_out_string(soap, "ds:P", -1, &a->P, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:P"))
		return soap->error;
	if (a->Q)
	{	if (soap_out_string(soap, "ds:Q", -1, &a->Q, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Q"))
		return soap->error;
	if (a->Seed)
	{	if (soap_out_string(soap, "ds:Seed", -1, &a->Seed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Seed"))
		return soap->error;
	if (a->PgenCounter)
	{	if (soap_out_string(soap, "ds:PgenCounter", -1, &a->PgenCounter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:PgenCounter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:G", &a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Y", &a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:J", &a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:P", &a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Q", &a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Seed", &a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:PgenCounter", &a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, 0, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DSAKeyValueType);
	if (soap_out_ds__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_int(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->X509IssuerName);
	soap_embedded(soap, &a->X509SerialNumber, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (a->X509IssuerName)
	{	if (soap_out_string(soap, "ds:X509IssuerName", -1, &a->X509IssuerName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509IssuerName"))
		return soap->error;
	if (soap_out_int(soap, "ds:X509SerialNumber", -1, &a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509IssuerName", &a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			if (soap_flag_X509SerialNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ds:X509SerialNumber", &a->X509SerialNumber, "xsd:int"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, 0, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509IssuerSerialType);
	if (soap_out_ds__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, &a->X509SKI);
	soap_serialize_string(soap, &a->X509SubjectName);
	soap_serialize_string(soap, &a->X509Certificate);
	soap_serialize_string(soap, &a->X509CRL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (a->X509IssuerSerial)
	{	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509IssuerSerial"))
		return soap->error;
	if (a->X509SKI)
	{	if (soap_out_string(soap, "ds:X509SKI", -1, &a->X509SKI, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509SKI"))
		return soap->error;
	if (a->X509SubjectName)
	{	if (soap_out_string(soap, "ds:X509SubjectName", -1, &a->X509SubjectName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509SubjectName"))
		return soap->error;
	if (a->X509Certificate)
	{	if (soap_out_string(soap, "ds:X509Certificate", -1, &a->X509Certificate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509Certificate"))
		return soap->error;
	if (a->X509CRL)
	{	if (soap_out_string(soap, "ds:X509CRL", -1, &a->X509CRL, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509CRL"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SKI", &a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SubjectName", &a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509Certificate", &a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509CRL", &a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, 0, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerSerial > 0 || soap_flag_X509SKI > 0 || soap_flag_X509SubjectName > 0 || soap_flag_X509Certificate > 0 || soap_flag_X509CRL > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509DataType);
	if (soap_out_ds__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, 0, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RetrievalMethodType);
	if (soap_out_ds__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (a->DSAKeyValue)
	{	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DSAKeyValue"))
		return soap->error;
	if (a->RSAKeyValue)
	{	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:RSAKeyValue"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, 0, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DSAKeyValue > 0 || soap_flag_RSAKeyValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyValueType);
	if (soap_out_ds__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, 0, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DigestMethodType);
	if (soap_out_ds__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, 0, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformType);
	if (soap_out_ds__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", a->PrefixList, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, 0, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (soap_out__c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_new_block(soap);
					a->Transform = (struct ds__TransformType *)soap_push_block(soap, soap_blist_Transform, sizeof(struct ds__TransformType));
					if (a->Transform == NULL)
						return NULL;
					soap_default_ds__TransformType(soap, a->Transform);
				}
				soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_pop_block(soap, soap_blist_Transform);
		if (a->__sizeTransform)
			a->Transform = (struct ds__TransformType *)soap_save_block(soap, soap_blist_Transform, NULL, 1);
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_end_block(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, 0, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformsType);
	if (soap_out_ds__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, &a->DigestValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (a->DigestMethod)
	{	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DigestMethod"))
		return soap->error;
	if (a->DigestValue)
	{	if (soap_out_string(soap, "ds:DigestValue", -1, &a->DigestValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DigestValue"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:DigestValue", &a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, 0, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__ReferenceType);
	if (soap_out_ds__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, 0, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureMethodType);
	if (soap_out_ds__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, 0, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (soap_out_ds__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, &a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:KeyName", &a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, 0, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyInfoType);
	if (soap_out_ds__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (a->CanonicalizationMethod)
	{	if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:CanonicalizationMethod"))
		return soap->error;
	if (a->SignatureMethod)
	{	if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:SignatureMethod"))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
			{	if (a->Reference == NULL)
				{	if (soap_blist_Reference == NULL)
						soap_blist_Reference = soap_new_block(soap);
					a->Reference = (struct ds__ReferenceType **)soap_push_block(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
					if (a->Reference == NULL)
						return NULL;
					*a->Reference = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
				{	a->__sizeReference++;
					a->Reference = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
			a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		else
		{	a->Reference = NULL;
			if (soap_blist_Reference)
				soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, 0, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignedInfoType);
	if (soap_out_ds__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default_string(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize_string(soap, &a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:SignatureValue", -1, &a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:SignatureValue", &a->SignatureValue, "xsd:string"))
				{	soap_flag_SignatureValue--;
					continue;
				}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, 0, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureType);
	if (soap_out_ds__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->Usage)
		soap_set_attr(soap, "Usage", a->Usage, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, 0, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__SecurityTokenReference);
	if (soap_out__wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__KeyIdentifier);
	if (soap_out__wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, 0, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Embedded);
	if (soap_out__wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, 0, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Reference);
	if (soap_out__wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__BinarySecurityToken);
	if (soap_out__wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Password);
	if (soap_out__wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_string(soap, &a->Nonce);
	soap_serialize_string(soap, &a->wsu__Created);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Nonce", &a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, 0, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__UsernameToken);
	if (soap_out__wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Created);
	soap_serialize_string(soap, &a->Expires);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, &a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Expires", &a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, 0, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsu__Timestamp);
	if (soap_out__wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->wsse__Security = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa5__MessageID(soap, &a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, &a->wsa5__To);
	soap_serialize__wsa5__Action(soap, &a->wsa5__Action);
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, &a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, &a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, &a->wsa5__Action, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_wsse__Security = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", &a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__To(soap, "wsa5:To", &a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__Action(soap, "wsa5:Action", &a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Action);
	soap_serialize_string(soap, &a->SoapAction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, &a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, &a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:Action", &a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:SoapAction", &a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, 0, sizeof(struct wsa5__ProblemActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ProblemActionType);
	if (soap_out_wsa5__ProblemActionType(soap, tag?tag:"wsa5:ProblemActionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", a->RelationshipType, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelatesToType);
	if (soap_out_wsa5__RelatesToType(soap, tag?tag:"wsa5:RelatesToType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, 0, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__MetadataType);
	if (soap_out_wsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, 0, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (soap_out_wsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_string(soap, "wsa5:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsa5:Address"))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:Address", &a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, 0, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__EndpointReferenceType);
	if (soap_out_wsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__Notify(struct soap *soap, struct _ns4__Notify *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__Notify))
		soap_serialize__ns4__Notify(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__Notify(struct soap *soap, const char *tag, int id, struct _ns4__Notify *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__Notify);
	if (id < 0)
		return soap->error;
	return soap_out__ns4__Notify(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns4__Notify ** SOAP_FMAC4 soap_in_PointerTo_ns4__Notify(struct soap *soap, const char *tag, struct _ns4__Notify **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns4__Notify **)soap_malloc(soap, sizeof(struct _ns4__Notify *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns4__Notify(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns4__Notify **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__Notify, sizeof(struct _ns4__Notify), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__Notify(struct soap *soap, struct _ns4__Notify *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__Notify);
	if (soap_out_PointerTo_ns4__Notify(soap, tag?tag:"ns4:Notify", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__Notify ** SOAP_FMAC4 soap_get_PointerTo_ns4__Notify(struct soap *soap, struct _ns4__Notify **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__forward(struct soap *soap, struct _ns1__forward *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__forward))
		soap_serialize__ns1__forward(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__forward(struct soap *soap, const char *tag, int id, struct _ns1__forward *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__forward);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__forward(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__forward ** SOAP_FMAC4 soap_in_PointerTo_ns1__forward(struct soap *soap, const char *tag, struct _ns1__forward **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__forward **)soap_malloc(soap, sizeof(struct _ns1__forward *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__forward(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__forward **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__forward, sizeof(struct _ns1__forward), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__forward(struct soap *soap, struct _ns1__forward *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__forward);
	if (soap_out_PointerTo_ns1__forward(soap, tag?tag:"ns1:forward", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__forward ** SOAP_FMAC4 soap_get_PointerTo_ns1__forward(struct soap *soap, struct _ns1__forward **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__forward(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTopologyResponseContent(struct soap *soap, struct ns1__getTopologyResponseContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTopologyResponseContent))
		soap_serialize_ns1__getTopologyResponseContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTopologyResponseContent(struct soap *soap, const char *tag, int id, struct ns1__getTopologyResponseContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTopologyResponseContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__getTopologyResponseContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__getTopologyResponseContent ** SOAP_FMAC4 soap_in_PointerTons1__getTopologyResponseContent(struct soap *soap, const char *tag, struct ns1__getTopologyResponseContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__getTopologyResponseContent **)soap_malloc(soap, sizeof(struct ns1__getTopologyResponseContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__getTopologyResponseContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__getTopologyResponseContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTopologyResponseContent, sizeof(struct ns1__getTopologyResponseContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTopologyResponseContent(struct soap *soap, struct ns1__getTopologyResponseContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTopologyResponseContent);
	if (soap_out_PointerTons1__getTopologyResponseContent(soap, tag?tag:"ns1:getTopologyResponseContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTopologyResponseContent ** SOAP_FMAC4 soap_get_PointerTons1__getTopologyResponseContent(struct soap *soap, struct ns1__getTopologyResponseContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getTopologyResponseContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTopologyContent(struct soap *soap, struct ns1__getTopologyContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTopologyContent))
		soap_serialize_ns1__getTopologyContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTopologyContent(struct soap *soap, const char *tag, int id, struct ns1__getTopologyContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTopologyContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__getTopologyContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__getTopologyContent ** SOAP_FMAC4 soap_in_PointerTons1__getTopologyContent(struct soap *soap, const char *tag, struct ns1__getTopologyContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__getTopologyContent **)soap_malloc(soap, sizeof(struct ns1__getTopologyContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__getTopologyContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__getTopologyContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTopologyContent, sizeof(struct ns1__getTopologyContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTopologyContent(struct soap *soap, struct ns1__getTopologyContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTopologyContent);
	if (soap_out_PointerTons1__getTopologyContent(soap, tag?tag:"ns1:getTopologyContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTopologyContent ** SOAP_FMAC4 soap_get_PointerTons1__getTopologyContent(struct soap *soap, struct ns1__getTopologyContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getTopologyContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BSSFault(struct soap *soap, struct _ns1__BSSFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BSSFault))
		soap_serialize__ns1__BSSFault(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BSSFault(struct soap *soap, const char *tag, int id, struct _ns1__BSSFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BSSFault);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__BSSFault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__BSSFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__BSSFault(struct soap *soap, const char *tag, struct _ns1__BSSFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__BSSFault **)soap_malloc(soap, sizeof(struct _ns1__BSSFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__BSSFault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__BSSFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BSSFault, sizeof(struct _ns1__BSSFault), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BSSFault(struct soap *soap, struct _ns1__BSSFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__BSSFault);
	if (soap_out_PointerTo_ns1__BSSFault(soap, tag?tag:"ns1:BSSFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__BSSFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__BSSFault(struct soap *soap, struct _ns1__BSSFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BSSFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AAAFault(struct soap *soap, struct _ns1__AAAFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AAAFault))
		soap_serialize__ns1__AAAFault(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AAAFault(struct soap *soap, const char *tag, int id, struct _ns1__AAAFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AAAFault);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__AAAFault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__AAAFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__AAAFault(struct soap *soap, const char *tag, struct _ns1__AAAFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__AAAFault **)soap_malloc(soap, sizeof(struct _ns1__AAAFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__AAAFault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__AAAFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AAAFault, sizeof(struct _ns1__AAAFault), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AAAFault(struct soap *soap, struct _ns1__AAAFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AAAFault);
	if (soap_out_PointerTo_ns1__AAAFault(soap, tag?tag:"ns1:AAAFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__AAAFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__AAAFault(struct soap *soap, struct _ns1__AAAFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AAAFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_QName(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__QName))
		soap_serialize__QName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_QName(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__QName);
	if (id < 0)
		return soap->error;
	return soap_out__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTo_QName(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__QName, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_QName(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_QName);
	if (soap_out_PointerTo_QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTo_QName(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns1__reservationResourceType_sequence(struct soap *soap, struct __ns1__reservationResourceType_sequence *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns1__reservationResourceType_sequence))
		soap_serialize___ns1__reservationResourceType_sequence(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns1__reservationResourceType_sequence(struct soap *soap, const char *tag, int id, struct __ns1__reservationResourceType_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns1__reservationResourceType_sequence);
	if (id < 0)
		return soap->error;
	return soap_out___ns1__reservationResourceType_sequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns1__reservationResourceType_sequence ** SOAP_FMAC4 soap_in_PointerTo__ns1__reservationResourceType_sequence(struct soap *soap, const char *tag, struct __ns1__reservationResourceType_sequence **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns1__reservationResourceType_sequence **)soap_malloc(soap, sizeof(struct __ns1__reservationResourceType_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns1__reservationResourceType_sequence(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns1__reservationResourceType_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns1__reservationResourceType_sequence, sizeof(struct __ns1__reservationResourceType_sequence), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns1__reservationResourceType_sequence(struct soap *soap, struct __ns1__reservationResourceType_sequence *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns1__reservationResourceType_sequence);
	if (soap_out_PointerTo__ns1__reservationResourceType_sequence(soap, tag?tag:"-ns1:reservationResourceType-sequence", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns1__reservationResourceType_sequence ** SOAP_FMAC4 soap_get_PointerTo__ns1__reservationResourceType_sequence(struct soap *soap, struct __ns1__reservationResourceType_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns1__reservationResourceType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__FaultCauseType(struct soap *soap, struct ns6__FaultCauseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__FaultCauseType))
		soap_serialize_ns6__FaultCauseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__FaultCauseType(struct soap *soap, const char *tag, int id, struct ns6__FaultCauseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__FaultCauseType);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__FaultCauseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__FaultCauseType ** SOAP_FMAC4 soap_in_PointerTons6__FaultCauseType(struct soap *soap, const char *tag, struct ns6__FaultCauseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns6__FaultCauseType **)soap_malloc(soap, sizeof(struct ns6__FaultCauseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__FaultCauseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns6__FaultCauseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__FaultCauseType, sizeof(struct ns6__FaultCauseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__FaultCauseType(struct soap *soap, struct ns6__FaultCauseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__FaultCauseType);
	if (soap_out_PointerTons6__FaultCauseType(soap, tag?tag:"ns6:FaultCauseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__FaultCauseType ** SOAP_FMAC4 soap_get_PointerTons6__FaultCauseType(struct soap *soap, struct ns6__FaultCauseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__FaultCauseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ErrorCodeType(struct soap *soap, struct ns6__ErrorCodeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ErrorCodeType))
		soap_serialize_ns6__ErrorCodeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ErrorCodeType(struct soap *soap, const char *tag, int id, struct ns6__ErrorCodeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ErrorCodeType);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__ErrorCodeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__ErrorCodeType ** SOAP_FMAC4 soap_in_PointerTons6__ErrorCodeType(struct soap *soap, const char *tag, struct ns6__ErrorCodeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns6__ErrorCodeType **)soap_malloc(soap, sizeof(struct ns6__ErrorCodeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__ErrorCodeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns6__ErrorCodeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ErrorCodeType, sizeof(struct ns6__ErrorCodeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ErrorCodeType(struct soap *soap, struct ns6__ErrorCodeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ErrorCodeType);
	if (soap_out_PointerTons6__ErrorCodeType(soap, tag?tag:"ns6:ErrorCodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__ErrorCodeType ** SOAP_FMAC4 soap_get_PointerTons6__ErrorCodeType(struct soap *soap, struct ns6__ErrorCodeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ErrorCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedInt);
	if (soap_out_PointerTounsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__Subscribe_SubscriptionPolicy(struct soap *soap, struct _ns4__Subscribe_SubscriptionPolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__Subscribe_SubscriptionPolicy))
		soap_serialize__ns4__Subscribe_SubscriptionPolicy(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _ns4__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__Subscribe_SubscriptionPolicy);
	if (id < 0)
		return soap->error;
	return soap_out__ns4__Subscribe_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns4__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_ns4__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _ns4__Subscribe_SubscriptionPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns4__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _ns4__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns4__Subscribe_SubscriptionPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns4__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__Subscribe_SubscriptionPolicy, sizeof(struct _ns4__Subscribe_SubscriptionPolicy), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__Subscribe_SubscriptionPolicy(struct soap *soap, struct _ns4__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__Subscribe_SubscriptionPolicy);
	if (soap_out_PointerTo_ns4__Subscribe_SubscriptionPolicy(soap, tag?tag:"ns4:Subscribe-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_ns4__Subscribe_SubscriptionPolicy(struct soap *soap, struct _ns4__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__NotificationMessageHolderType(struct soap *soap, struct ns4__NotificationMessageHolderType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__NotificationMessageHolderType))
		soap_serialize_PointerTons4__NotificationMessageHolderType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, struct ns4__NotificationMessageHolderType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__NotificationMessageHolderType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__NotificationMessageHolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__NotificationMessageHolderType *** SOAP_FMAC4 soap_in_PointerToPointerTons4__NotificationMessageHolderType(struct soap *soap, const char *tag, struct ns4__NotificationMessageHolderType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__NotificationMessageHolderType ***)soap_malloc(soap, sizeof(struct ns4__NotificationMessageHolderType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__NotificationMessageHolderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__NotificationMessageHolderType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__NotificationMessageHolderType, sizeof(struct ns4__NotificationMessageHolderType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__NotificationMessageHolderType(struct soap *soap, struct ns4__NotificationMessageHolderType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__NotificationMessageHolderType);
	if (soap_out_PointerToPointerTons4__NotificationMessageHolderType(soap, tag?tag:"ns4:NotificationMessageHolderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__NotificationMessageHolderType *** SOAP_FMAC4 soap_get_PointerToPointerTons4__NotificationMessageHolderType(struct soap *soap, struct ns4__NotificationMessageHolderType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__NotificationMessageHolderType(struct soap *soap, struct ns4__NotificationMessageHolderType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__NotificationMessageHolderType))
		soap_serialize_ns4__NotificationMessageHolderType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, struct ns4__NotificationMessageHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__NotificationMessageHolderType);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__NotificationMessageHolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTons4__NotificationMessageHolderType(struct soap *soap, const char *tag, struct ns4__NotificationMessageHolderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__NotificationMessageHolderType **)soap_malloc(soap, sizeof(struct ns4__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__NotificationMessageHolderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__NotificationMessageHolderType, sizeof(struct ns4__NotificationMessageHolderType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__NotificationMessageHolderType(struct soap *soap, struct ns4__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__NotificationMessageHolderType);
	if (soap_out_PointerTons4__NotificationMessageHolderType(soap, tag?tag:"ns4:NotificationMessageHolderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTons4__NotificationMessageHolderType(struct soap *soap, struct ns4__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__SubscriptionPolicyType(struct soap *soap, struct ns4__SubscriptionPolicyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__SubscriptionPolicyType))
		soap_serialize_ns4__SubscriptionPolicyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, struct ns4__SubscriptionPolicyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__SubscriptionPolicyType);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__SubscriptionPolicyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTons4__SubscriptionPolicyType(struct soap *soap, const char *tag, struct ns4__SubscriptionPolicyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__SubscriptionPolicyType **)soap_malloc(soap, sizeof(struct ns4__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__SubscriptionPolicyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__SubscriptionPolicyType, sizeof(struct ns4__SubscriptionPolicyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__SubscriptionPolicyType(struct soap *soap, struct ns4__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__SubscriptionPolicyType);
	if (soap_out_PointerTons4__SubscriptionPolicyType(soap, tag?tag:"ns4:SubscriptionPolicyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTons4__SubscriptionPolicyType(struct soap *soap, struct ns4__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__FilterType(struct soap *soap, struct ns4__FilterType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__FilterType))
		soap_serialize_ns4__FilterType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__FilterType(struct soap *soap, const char *tag, int id, struct ns4__FilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__FilterType);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__FilterType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__FilterType ** SOAP_FMAC4 soap_in_PointerTons4__FilterType(struct soap *soap, const char *tag, struct ns4__FilterType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__FilterType **)soap_malloc(soap, sizeof(struct ns4__FilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__FilterType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__FilterType, sizeof(struct ns4__FilterType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__FilterType(struct soap *soap, struct ns4__FilterType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__FilterType);
	if (soap_out_PointerTons4__FilterType(soap, tag?tag:"ns4:FilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FilterType ** SOAP_FMAC4 soap_get_PointerTons4__FilterType(struct soap *soap, struct ns4__FilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__MessageType(struct soap *soap, struct ns4__MessageType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__MessageType))
		soap_serialize_ns4__MessageType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__MessageType(struct soap *soap, const char *tag, int id, struct ns4__MessageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__MessageType);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__MessageType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__MessageType ** SOAP_FMAC4 soap_in_PointerTons4__MessageType(struct soap *soap, const char *tag, struct ns4__MessageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__MessageType **)soap_malloc(soap, sizeof(struct ns4__MessageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__MessageType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__MessageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__MessageType, sizeof(struct ns4__MessageType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__MessageType(struct soap *soap, struct ns4__MessageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__MessageType);
	if (soap_out_PointerTons4__MessageType(soap, tag?tag:"ns4:MessageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__MessageType ** SOAP_FMAC4 soap_get_PointerTons4__MessageType(struct soap *soap, struct ns4__MessageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__MessageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__EndpointReferenceType);
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__QueryExpressionType(struct soap *soap, struct ns4__QueryExpressionType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__QueryExpressionType))
		soap_serialize_PointerTons4__QueryExpressionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__QueryExpressionType(struct soap *soap, const char *tag, int id, struct ns4__QueryExpressionType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__QueryExpressionType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__QueryExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__QueryExpressionType *** SOAP_FMAC4 soap_in_PointerToPointerTons4__QueryExpressionType(struct soap *soap, const char *tag, struct ns4__QueryExpressionType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__QueryExpressionType ***)soap_malloc(soap, sizeof(struct ns4__QueryExpressionType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__QueryExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__QueryExpressionType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__QueryExpressionType, sizeof(struct ns4__QueryExpressionType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__QueryExpressionType(struct soap *soap, struct ns4__QueryExpressionType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__QueryExpressionType);
	if (soap_out_PointerToPointerTons4__QueryExpressionType(soap, tag?tag:"ns4:QueryExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__QueryExpressionType *** SOAP_FMAC4 soap_get_PointerToPointerTons4__QueryExpressionType(struct soap *soap, struct ns4__QueryExpressionType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__QueryExpressionType(struct soap *soap, struct ns4__QueryExpressionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__QueryExpressionType))
		soap_serialize_ns4__QueryExpressionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__QueryExpressionType(struct soap *soap, const char *tag, int id, struct ns4__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__QueryExpressionType);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__QueryExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTons4__QueryExpressionType(struct soap *soap, const char *tag, struct ns4__QueryExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__QueryExpressionType **)soap_malloc(soap, sizeof(struct ns4__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__QueryExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__QueryExpressionType, sizeof(struct ns4__QueryExpressionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__QueryExpressionType(struct soap *soap, struct ns4__QueryExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__QueryExpressionType);
	if (soap_out_PointerTons4__QueryExpressionType(soap, tag?tag:"ns4:QueryExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTons4__QueryExpressionType(struct soap *soap, struct ns4__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__TopicExpressionType(struct soap *soap, struct ns4__TopicExpressionType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__TopicExpressionType))
		soap_serialize_PointerTons4__TopicExpressionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__TopicExpressionType(struct soap *soap, const char *tag, int id, struct ns4__TopicExpressionType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__TopicExpressionType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__TopicExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__TopicExpressionType *** SOAP_FMAC4 soap_in_PointerToPointerTons4__TopicExpressionType(struct soap *soap, const char *tag, struct ns4__TopicExpressionType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__TopicExpressionType ***)soap_malloc(soap, sizeof(struct ns4__TopicExpressionType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__TopicExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__TopicExpressionType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__TopicExpressionType, sizeof(struct ns4__TopicExpressionType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__TopicExpressionType(struct soap *soap, struct ns4__TopicExpressionType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__TopicExpressionType);
	if (soap_out_PointerToPointerTons4__TopicExpressionType(soap, tag?tag:"ns4:TopicExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__TopicExpressionType *** SOAP_FMAC4 soap_get_PointerToPointerTons4__TopicExpressionType(struct soap *soap, struct ns4__TopicExpressionType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__TopicExpressionType(struct soap *soap, struct ns4__TopicExpressionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__TopicExpressionType))
		soap_serialize_ns4__TopicExpressionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__TopicExpressionType(struct soap *soap, const char *tag, int id, struct ns4__TopicExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__TopicExpressionType);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__TopicExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTons4__TopicExpressionType(struct soap *soap, const char *tag, struct ns4__TopicExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__TopicExpressionType **)soap_malloc(soap, sizeof(struct ns4__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__TopicExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__TopicExpressionType, sizeof(struct ns4__TopicExpressionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__TopicExpressionType(struct soap *soap, struct ns4__TopicExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__TopicExpressionType);
	if (soap_out_PointerTons4__TopicExpressionType(soap, tag?tag:"ns4:TopicExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTons4__TopicExpressionType(struct soap *soap, struct ns4__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean_(struct soap *soap, enum xsd__boolean_ *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean_(struct soap *soap, const char *tag, int id, enum xsd__boolean_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean_);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean_(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean_ ** SOAP_FMAC4 soap_in_PointerToxsd__boolean_(struct soap *soap, const char *tag, enum xsd__boolean_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean_ **)soap_malloc(soap, sizeof(enum xsd__boolean_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean_, sizeof(enum xsd__boolean_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean_(struct soap *soap, enum xsd__boolean_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean_);
	if (soap_out_PointerToxsd__boolean_(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean_ ** SOAP_FMAC4 soap_get_PointerToxsd__boolean_(struct soap *soap, enum xsd__boolean_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo))
		soap_serialize_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, const char *tag, struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo **)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlaneSwitchingCapabilitySpecificInfo, sizeof(struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo);
	if (soap_out_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag?tag:"ns3:CtrlPlaneSwitchingCapabilitySpecificInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, struct ns3__CtrlPlaneSwitchingCapabilitySpecificInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Duration(struct soap *soap, struct ns3__Duration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__Duration))
		soap_serialize_ns3__Duration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__Duration(struct soap *soap, const char *tag, int id, struct ns3__Duration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__Duration);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__Duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__Duration ** SOAP_FMAC4 soap_in_PointerTons3__Duration(struct soap *soap, const char *tag, struct ns3__Duration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__Duration **)soap_malloc(soap, sizeof(struct ns3__Duration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__Duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__Duration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__Duration, sizeof(struct ns3__Duration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Duration(struct soap *soap, struct ns3__Duration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__Duration);
	if (soap_out_PointerTons3__Duration(soap, tag?tag:"ns3:Duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__Duration ** SOAP_FMAC4 soap_get_PointerTons3__Duration(struct soap *soap, struct ns3__Duration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__Duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TimeContent(struct soap *soap, struct ns3__TimeContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TimeContent))
		soap_serialize_ns3__TimeContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TimeContent(struct soap *soap, const char *tag, int id, struct ns3__TimeContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TimeContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__TimeContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__TimeContent ** SOAP_FMAC4 soap_in_PointerTons3__TimeContent(struct soap *soap, const char *tag, struct ns3__TimeContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__TimeContent **)soap_malloc(soap, sizeof(struct ns3__TimeContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__TimeContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__TimeContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TimeContent, sizeof(struct ns3__TimeContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TimeContent(struct soap *soap, struct ns3__TimeContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__TimeContent);
	if (soap_out_PointerTons3__TimeContent(soap, tag?tag:"ns3:TimeContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__TimeContent ** SOAP_FMAC4 soap_get_PointerTons3__TimeContent(struct soap *soap, struct ns3__TimeContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TimeContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__CtrlPlaneNextHopContent(struct soap *soap, struct ns3__CtrlPlaneNextHopContent **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__CtrlPlaneNextHopContent))
		soap_serialize_PointerTons3__CtrlPlaneNextHopContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__CtrlPlaneNextHopContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneNextHopContent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__CtrlPlaneNextHopContent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__CtrlPlaneNextHopContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneNextHopContent *** SOAP_FMAC4 soap_in_PointerToPointerTons3__CtrlPlaneNextHopContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneNextHopContent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneNextHopContent ***)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneNextHopContent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__CtrlPlaneNextHopContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneNextHopContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__CtrlPlaneNextHopContent, sizeof(struct ns3__CtrlPlaneNextHopContent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__CtrlPlaneNextHopContent(struct soap *soap, struct ns3__CtrlPlaneNextHopContent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__CtrlPlaneNextHopContent);
	if (soap_out_PointerToPointerTons3__CtrlPlaneNextHopContent(soap, tag?tag:"ns3:CtrlPlaneNextHopContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneNextHopContent *** SOAP_FMAC4 soap_get_PointerToPointerTons3__CtrlPlaneNextHopContent(struct soap *soap, struct ns3__CtrlPlaneNextHopContent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__CtrlPlaneNextHopContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlaneNextHopContent(struct soap *soap, struct ns3__CtrlPlaneNextHopContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlaneNextHopContent))
		soap_serialize_ns3__CtrlPlaneNextHopContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlaneNextHopContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneNextHopContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlaneNextHopContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlaneNextHopContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneNextHopContent ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlaneNextHopContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneNextHopContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneNextHopContent **)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneNextHopContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlaneNextHopContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneNextHopContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlaneNextHopContent, sizeof(struct ns3__CtrlPlaneNextHopContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlaneNextHopContent(struct soap *soap, struct ns3__CtrlPlaneNextHopContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlaneNextHopContent);
	if (soap_out_PointerTons3__CtrlPlaneNextHopContent(soap, tag?tag:"ns3:CtrlPlaneNextHopContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneNextHopContent ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlaneNextHopContent(struct soap *soap, struct ns3__CtrlPlaneNextHopContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlaneNextHopContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__CtrlPlaneHopContent(struct soap *soap, struct ns3__CtrlPlaneHopContent **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__CtrlPlaneHopContent))
		soap_serialize_PointerTons3__CtrlPlaneHopContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__CtrlPlaneHopContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneHopContent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__CtrlPlaneHopContent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__CtrlPlaneHopContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneHopContent *** SOAP_FMAC4 soap_in_PointerToPointerTons3__CtrlPlaneHopContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneHopContent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneHopContent ***)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneHopContent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__CtrlPlaneHopContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneHopContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__CtrlPlaneHopContent, sizeof(struct ns3__CtrlPlaneHopContent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__CtrlPlaneHopContent(struct soap *soap, struct ns3__CtrlPlaneHopContent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__CtrlPlaneHopContent);
	if (soap_out_PointerToPointerTons3__CtrlPlaneHopContent(soap, tag?tag:"ns3:CtrlPlaneHopContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneHopContent *** SOAP_FMAC4 soap_get_PointerToPointerTons3__CtrlPlaneHopContent(struct soap *soap, struct ns3__CtrlPlaneHopContent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__CtrlPlaneHopContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlaneHopContent(struct soap *soap, struct ns3__CtrlPlaneHopContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlaneHopContent))
		soap_serialize_ns3__CtrlPlaneHopContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlaneHopContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneHopContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlaneHopContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlaneHopContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneHopContent ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlaneHopContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneHopContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneHopContent **)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneHopContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlaneHopContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneHopContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlaneHopContent, sizeof(struct ns3__CtrlPlaneHopContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlaneHopContent(struct soap *soap, struct ns3__CtrlPlaneHopContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlaneHopContent);
	if (soap_out_PointerTons3__CtrlPlaneHopContent(soap, tag?tag:"ns3:CtrlPlaneHopContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneHopContent ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlaneHopContent(struct soap *soap, struct ns3__CtrlPlaneHopContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlaneHopContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlaneSwcapContent(struct soap *soap, struct ns3__CtrlPlaneSwcapContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlaneSwcapContent))
		soap_serialize_ns3__CtrlPlaneSwcapContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlaneSwcapContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneSwcapContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlaneSwcapContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlaneSwcapContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneSwcapContent ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlaneSwcapContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneSwcapContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneSwcapContent **)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneSwcapContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlaneSwcapContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneSwcapContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlaneSwcapContent, sizeof(struct ns3__CtrlPlaneSwcapContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlaneSwcapContent(struct soap *soap, struct ns3__CtrlPlaneSwcapContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlaneSwcapContent);
	if (soap_out_PointerTons3__CtrlPlaneSwcapContent(soap, tag?tag:"ns3:CtrlPlaneSwcapContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneSwcapContent ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlaneSwcapContent(struct soap *soap, struct ns3__CtrlPlaneSwcapContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlaneSwcapContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns3__CtrlPlaneAdministrativeGroup **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__CtrlPlaneAdministrativeGroup))
		soap_serialize_PointerTons3__CtrlPlaneAdministrativeGroup(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__CtrlPlaneAdministrativeGroup(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneAdministrativeGroup **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__CtrlPlaneAdministrativeGroup);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__CtrlPlaneAdministrativeGroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneAdministrativeGroup *** SOAP_FMAC4 soap_in_PointerToPointerTons3__CtrlPlaneAdministrativeGroup(struct soap *soap, const char *tag, struct ns3__CtrlPlaneAdministrativeGroup ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneAdministrativeGroup ***)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneAdministrativeGroup **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__CtrlPlaneAdministrativeGroup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneAdministrativeGroup ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__CtrlPlaneAdministrativeGroup, sizeof(struct ns3__CtrlPlaneAdministrativeGroup *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns3__CtrlPlaneAdministrativeGroup **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__CtrlPlaneAdministrativeGroup);
	if (soap_out_PointerToPointerTons3__CtrlPlaneAdministrativeGroup(soap, tag?tag:"ns3:CtrlPlaneAdministrativeGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneAdministrativeGroup *** SOAP_FMAC4 soap_get_PointerToPointerTons3__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns3__CtrlPlaneAdministrativeGroup ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__CtrlPlaneAdministrativeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns3__CtrlPlaneAdministrativeGroup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlaneAdministrativeGroup))
		soap_serialize_ns3__CtrlPlaneAdministrativeGroup(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlaneAdministrativeGroup(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneAdministrativeGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlaneAdministrativeGroup);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlaneAdministrativeGroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneAdministrativeGroup ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlaneAdministrativeGroup(struct soap *soap, const char *tag, struct ns3__CtrlPlaneAdministrativeGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneAdministrativeGroup **)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneAdministrativeGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlaneAdministrativeGroup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneAdministrativeGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlaneAdministrativeGroup, sizeof(struct ns3__CtrlPlaneAdministrativeGroup), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns3__CtrlPlaneAdministrativeGroup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlaneAdministrativeGroup);
	if (soap_out_PointerTons3__CtrlPlaneAdministrativeGroup(soap, tag?tag:"ns3:CtrlPlaneAdministrativeGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneAdministrativeGroup ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns3__CtrlPlaneAdministrativeGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlaneAdministrativeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlaneAddressContent(struct soap *soap, struct ns3__CtrlPlaneAddressContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlaneAddressContent))
		soap_serialize_ns3__CtrlPlaneAddressContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlaneAddressContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneAddressContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlaneAddressContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlaneAddressContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneAddressContent ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlaneAddressContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneAddressContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneAddressContent **)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneAddressContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlaneAddressContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneAddressContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlaneAddressContent, sizeof(struct ns3__CtrlPlaneAddressContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlaneAddressContent(struct soap *soap, struct ns3__CtrlPlaneAddressContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlaneAddressContent);
	if (soap_out_PointerTons3__CtrlPlaneAddressContent(soap, tag?tag:"ns3:CtrlPlaneAddressContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneAddressContent ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlaneAddressContent(struct soap *soap, struct ns3__CtrlPlaneAddressContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlaneAddressContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__CtrlPlaneLinkContent(struct soap *soap, struct ns3__CtrlPlaneLinkContent **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__CtrlPlaneLinkContent))
		soap_serialize_PointerTons3__CtrlPlaneLinkContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__CtrlPlaneLinkContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneLinkContent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__CtrlPlaneLinkContent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__CtrlPlaneLinkContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneLinkContent *** SOAP_FMAC4 soap_in_PointerToPointerTons3__CtrlPlaneLinkContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneLinkContent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneLinkContent ***)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneLinkContent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__CtrlPlaneLinkContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneLinkContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__CtrlPlaneLinkContent, sizeof(struct ns3__CtrlPlaneLinkContent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__CtrlPlaneLinkContent(struct soap *soap, struct ns3__CtrlPlaneLinkContent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__CtrlPlaneLinkContent);
	if (soap_out_PointerToPointerTons3__CtrlPlaneLinkContent(soap, tag?tag:"ns3:CtrlPlaneLinkContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneLinkContent *** SOAP_FMAC4 soap_get_PointerToPointerTons3__CtrlPlaneLinkContent(struct soap *soap, struct ns3__CtrlPlaneLinkContent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__CtrlPlaneLinkContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlaneLinkContent(struct soap *soap, struct ns3__CtrlPlaneLinkContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlaneLinkContent))
		soap_serialize_ns3__CtrlPlaneLinkContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlaneLinkContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneLinkContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlaneLinkContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlaneLinkContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneLinkContent ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlaneLinkContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneLinkContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneLinkContent **)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneLinkContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlaneLinkContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneLinkContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlaneLinkContent, sizeof(struct ns3__CtrlPlaneLinkContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlaneLinkContent(struct soap *soap, struct ns3__CtrlPlaneLinkContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlaneLinkContent);
	if (soap_out_PointerTons3__CtrlPlaneLinkContent(soap, tag?tag:"ns3:CtrlPlaneLinkContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneLinkContent ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlaneLinkContent(struct soap *soap, struct ns3__CtrlPlaneLinkContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlaneLinkContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__CtrlPlanePortContent(struct soap *soap, struct ns3__CtrlPlanePortContent **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__CtrlPlanePortContent))
		soap_serialize_PointerTons3__CtrlPlanePortContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__CtrlPlanePortContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlanePortContent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__CtrlPlanePortContent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__CtrlPlanePortContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlanePortContent *** SOAP_FMAC4 soap_in_PointerToPointerTons3__CtrlPlanePortContent(struct soap *soap, const char *tag, struct ns3__CtrlPlanePortContent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlanePortContent ***)soap_malloc(soap, sizeof(struct ns3__CtrlPlanePortContent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__CtrlPlanePortContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlanePortContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__CtrlPlanePortContent, sizeof(struct ns3__CtrlPlanePortContent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__CtrlPlanePortContent(struct soap *soap, struct ns3__CtrlPlanePortContent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__CtrlPlanePortContent);
	if (soap_out_PointerToPointerTons3__CtrlPlanePortContent(soap, tag?tag:"ns3:CtrlPlanePortContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlanePortContent *** SOAP_FMAC4 soap_get_PointerToPointerTons3__CtrlPlanePortContent(struct soap *soap, struct ns3__CtrlPlanePortContent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__CtrlPlanePortContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlanePortContent(struct soap *soap, struct ns3__CtrlPlanePortContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlanePortContent))
		soap_serialize_ns3__CtrlPlanePortContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlanePortContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlanePortContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlanePortContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlanePortContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlanePortContent ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlanePortContent(struct soap *soap, const char *tag, struct ns3__CtrlPlanePortContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlanePortContent **)soap_malloc(soap, sizeof(struct ns3__CtrlPlanePortContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlanePortContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlanePortContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlanePortContent, sizeof(struct ns3__CtrlPlanePortContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlanePortContent(struct soap *soap, struct ns3__CtrlPlanePortContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlanePortContent);
	if (soap_out_PointerTons3__CtrlPlanePortContent(soap, tag?tag:"ns3:CtrlPlanePortContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlanePortContent ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlanePortContent(struct soap *soap, struct ns3__CtrlPlanePortContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlanePortContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__CtrlPlaneNodeContent(struct soap *soap, struct ns3__CtrlPlaneNodeContent **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__CtrlPlaneNodeContent))
		soap_serialize_PointerTons3__CtrlPlaneNodeContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__CtrlPlaneNodeContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneNodeContent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__CtrlPlaneNodeContent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__CtrlPlaneNodeContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneNodeContent *** SOAP_FMAC4 soap_in_PointerToPointerTons3__CtrlPlaneNodeContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneNodeContent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneNodeContent ***)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneNodeContent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__CtrlPlaneNodeContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneNodeContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__CtrlPlaneNodeContent, sizeof(struct ns3__CtrlPlaneNodeContent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__CtrlPlaneNodeContent(struct soap *soap, struct ns3__CtrlPlaneNodeContent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__CtrlPlaneNodeContent);
	if (soap_out_PointerToPointerTons3__CtrlPlaneNodeContent(soap, tag?tag:"ns3:CtrlPlaneNodeContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneNodeContent *** SOAP_FMAC4 soap_get_PointerToPointerTons3__CtrlPlaneNodeContent(struct soap *soap, struct ns3__CtrlPlaneNodeContent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__CtrlPlaneNodeContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlaneNodeContent(struct soap *soap, struct ns3__CtrlPlaneNodeContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlaneNodeContent))
		soap_serialize_ns3__CtrlPlaneNodeContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlaneNodeContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneNodeContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlaneNodeContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlaneNodeContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneNodeContent ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlaneNodeContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneNodeContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneNodeContent **)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneNodeContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlaneNodeContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneNodeContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlaneNodeContent, sizeof(struct ns3__CtrlPlaneNodeContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlaneNodeContent(struct soap *soap, struct ns3__CtrlPlaneNodeContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlaneNodeContent);
	if (soap_out_PointerTons3__CtrlPlaneNodeContent(soap, tag?tag:"ns3:CtrlPlaneNodeContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneNodeContent ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlaneNodeContent(struct soap *soap, struct ns3__CtrlPlaneNodeContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlaneNodeContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Lifetime(struct soap *soap, struct ns3__Lifetime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__Lifetime))
		soap_serialize_ns3__Lifetime(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__Lifetime(struct soap *soap, const char *tag, int id, struct ns3__Lifetime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__Lifetime);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__Lifetime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__Lifetime ** SOAP_FMAC4 soap_in_PointerTons3__Lifetime(struct soap *soap, const char *tag, struct ns3__Lifetime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__Lifetime **)soap_malloc(soap, sizeof(struct ns3__Lifetime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__Lifetime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__Lifetime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__Lifetime, sizeof(struct ns3__Lifetime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Lifetime(struct soap *soap, struct ns3__Lifetime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__Lifetime);
	if (soap_out_PointerTons3__Lifetime(soap, tag?tag:"ns3:Lifetime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__Lifetime ** SOAP_FMAC4 soap_get_PointerTons3__Lifetime(struct soap *soap, struct ns3__Lifetime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__Lifetime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns3__CtrlPlaneDomainSignatureContent **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__CtrlPlaneDomainSignatureContent))
		soap_serialize_PointerTons3__CtrlPlaneDomainSignatureContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__CtrlPlaneDomainSignatureContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneDomainSignatureContent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__CtrlPlaneDomainSignatureContent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__CtrlPlaneDomainSignatureContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneDomainSignatureContent *** SOAP_FMAC4 soap_in_PointerToPointerTons3__CtrlPlaneDomainSignatureContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneDomainSignatureContent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneDomainSignatureContent ***)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneDomainSignatureContent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__CtrlPlaneDomainSignatureContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneDomainSignatureContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__CtrlPlaneDomainSignatureContent, sizeof(struct ns3__CtrlPlaneDomainSignatureContent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns3__CtrlPlaneDomainSignatureContent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__CtrlPlaneDomainSignatureContent);
	if (soap_out_PointerToPointerTons3__CtrlPlaneDomainSignatureContent(soap, tag?tag:"ns3:CtrlPlaneDomainSignatureContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneDomainSignatureContent *** SOAP_FMAC4 soap_get_PointerToPointerTons3__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns3__CtrlPlaneDomainSignatureContent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__CtrlPlaneDomainSignatureContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns3__CtrlPlaneDomainSignatureContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlaneDomainSignatureContent))
		soap_serialize_ns3__CtrlPlaneDomainSignatureContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlaneDomainSignatureContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneDomainSignatureContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlaneDomainSignatureContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlaneDomainSignatureContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneDomainSignatureContent ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlaneDomainSignatureContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneDomainSignatureContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneDomainSignatureContent **)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneDomainSignatureContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlaneDomainSignatureContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneDomainSignatureContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlaneDomainSignatureContent, sizeof(struct ns3__CtrlPlaneDomainSignatureContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns3__CtrlPlaneDomainSignatureContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlaneDomainSignatureContent);
	if (soap_out_PointerTons3__CtrlPlaneDomainSignatureContent(soap, tag?tag:"ns3:CtrlPlaneDomainSignatureContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneDomainSignatureContent ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns3__CtrlPlaneDomainSignatureContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlaneDomainSignatureContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__CtrlPlaneDomainContent(struct soap *soap, struct ns3__CtrlPlaneDomainContent **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__CtrlPlaneDomainContent))
		soap_serialize_PointerTons3__CtrlPlaneDomainContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__CtrlPlaneDomainContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneDomainContent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__CtrlPlaneDomainContent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__CtrlPlaneDomainContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneDomainContent *** SOAP_FMAC4 soap_in_PointerToPointerTons3__CtrlPlaneDomainContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneDomainContent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneDomainContent ***)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneDomainContent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__CtrlPlaneDomainContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneDomainContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__CtrlPlaneDomainContent, sizeof(struct ns3__CtrlPlaneDomainContent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__CtrlPlaneDomainContent(struct soap *soap, struct ns3__CtrlPlaneDomainContent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__CtrlPlaneDomainContent);
	if (soap_out_PointerToPointerTons3__CtrlPlaneDomainContent(soap, tag?tag:"ns3:CtrlPlaneDomainContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneDomainContent *** SOAP_FMAC4 soap_get_PointerToPointerTons3__CtrlPlaneDomainContent(struct soap *soap, struct ns3__CtrlPlaneDomainContent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__CtrlPlaneDomainContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlaneDomainContent(struct soap *soap, struct ns3__CtrlPlaneDomainContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlaneDomainContent))
		soap_serialize_ns3__CtrlPlaneDomainContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlaneDomainContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneDomainContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlaneDomainContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlaneDomainContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneDomainContent ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlaneDomainContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneDomainContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneDomainContent **)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneDomainContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlaneDomainContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneDomainContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlaneDomainContent, sizeof(struct ns3__CtrlPlaneDomainContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlaneDomainContent(struct soap *soap, struct ns3__CtrlPlaneDomainContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlaneDomainContent);
	if (soap_out_PointerTons3__CtrlPlaneDomainContent(soap, tag?tag:"ns3:CtrlPlaneDomainContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneDomainContent ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlaneDomainContent(struct soap *soap, struct ns3__CtrlPlaneDomainContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlaneDomainContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__CtrlPlanePathContent(struct soap *soap, struct ns3__CtrlPlanePathContent **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__CtrlPlanePathContent))
		soap_serialize_PointerTons3__CtrlPlanePathContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__CtrlPlanePathContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlanePathContent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__CtrlPlanePathContent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__CtrlPlanePathContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlanePathContent *** SOAP_FMAC4 soap_in_PointerToPointerTons3__CtrlPlanePathContent(struct soap *soap, const char *tag, struct ns3__CtrlPlanePathContent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlanePathContent ***)soap_malloc(soap, sizeof(struct ns3__CtrlPlanePathContent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__CtrlPlanePathContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlanePathContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__CtrlPlanePathContent, sizeof(struct ns3__CtrlPlanePathContent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__CtrlPlanePathContent(struct soap *soap, struct ns3__CtrlPlanePathContent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__CtrlPlanePathContent);
	if (soap_out_PointerToPointerTons3__CtrlPlanePathContent(soap, tag?tag:"ns3:CtrlPlanePathContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlanePathContent *** SOAP_FMAC4 soap_get_PointerToPointerTons3__CtrlPlanePathContent(struct soap *soap, struct ns3__CtrlPlanePathContent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__CtrlPlanePathContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__forwardReply(struct soap *soap, struct ns1__forwardReply *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__forwardReply))
		soap_serialize_ns1__forwardReply(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__forwardReply(struct soap *soap, const char *tag, int id, struct ns1__forwardReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__forwardReply);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__forwardReply(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__forwardReply ** SOAP_FMAC4 soap_in_PointerTons1__forwardReply(struct soap *soap, const char *tag, struct ns1__forwardReply **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__forwardReply **)soap_malloc(soap, sizeof(struct ns1__forwardReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__forwardReply(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__forwardReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__forwardReply, sizeof(struct ns1__forwardReply), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__forwardReply(struct soap *soap, struct ns1__forwardReply *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__forwardReply);
	if (soap_out_PointerTons1__forwardReply(soap, tag?tag:"ns1:forwardReply", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__forwardReply ** SOAP_FMAC4 soap_get_PointerTons1__forwardReply(struct soap *soap, struct ns1__forwardReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__forwardReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__forwardPayload(struct soap *soap, struct ns1__forwardPayload *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__forwardPayload))
		soap_serialize_ns1__forwardPayload(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__forwardPayload(struct soap *soap, const char *tag, int id, struct ns1__forwardPayload *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__forwardPayload);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__forwardPayload(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__forwardPayload ** SOAP_FMAC4 soap_in_PointerTons1__forwardPayload(struct soap *soap, const char *tag, struct ns1__forwardPayload **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__forwardPayload **)soap_malloc(soap, sizeof(struct ns1__forwardPayload *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__forwardPayload(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__forwardPayload **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__forwardPayload, sizeof(struct ns1__forwardPayload), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__forwardPayload(struct soap *soap, struct ns1__forwardPayload *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__forwardPayload);
	if (soap_out_PointerTons1__forwardPayload(soap, tag?tag:"ns1:forwardPayload", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__forwardPayload ** SOAP_FMAC4 soap_get_PointerTons1__forwardPayload(struct soap *soap, struct ns1__forwardPayload **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__forwardPayload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__localDetails(struct soap *soap, struct ns1__localDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__localDetails))
		soap_serialize_ns1__localDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__localDetails(struct soap *soap, const char *tag, int id, struct ns1__localDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__localDetails);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__localDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__localDetails ** SOAP_FMAC4 soap_in_PointerTons1__localDetails(struct soap *soap, const char *tag, struct ns1__localDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__localDetails **)soap_malloc(soap, sizeof(struct ns1__localDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__localDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__localDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__localDetails, sizeof(struct ns1__localDetails), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__localDetails(struct soap *soap, struct ns1__localDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__localDetails);
	if (soap_out_PointerTons1__localDetails(soap, tag?tag:"ns1:localDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__localDetails ** SOAP_FMAC4 soap_get_PointerTons1__localDetails(struct soap *soap, struct ns1__localDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__localDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__msgDetails(struct soap *soap, struct ns1__msgDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__msgDetails))
		soap_serialize_ns1__msgDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__msgDetails(struct soap *soap, const char *tag, int id, struct ns1__msgDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__msgDetails);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__msgDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__msgDetails ** SOAP_FMAC4 soap_in_PointerTons1__msgDetails(struct soap *soap, const char *tag, struct ns1__msgDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__msgDetails **)soap_malloc(soap, sizeof(struct ns1__msgDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__msgDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__msgDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__msgDetails, sizeof(struct ns1__msgDetails), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__msgDetails(struct soap *soap, struct ns1__msgDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__msgDetails);
	if (soap_out_PointerTons1__msgDetails(soap, tag?tag:"ns1:msgDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__msgDetails ** SOAP_FMAC4 soap_get_PointerTons1__msgDetails(struct soap *soap, struct ns1__msgDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__msgDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mplsInfo(struct soap *soap, struct ns1__mplsInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mplsInfo))
		soap_serialize_ns1__mplsInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mplsInfo(struct soap *soap, const char *tag, int id, struct ns1__mplsInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mplsInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mplsInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mplsInfo ** SOAP_FMAC4 soap_in_PointerTons1__mplsInfo(struct soap *soap, const char *tag, struct ns1__mplsInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mplsInfo **)soap_malloc(soap, sizeof(struct ns1__mplsInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mplsInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mplsInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mplsInfo, sizeof(struct ns1__mplsInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mplsInfo(struct soap *soap, struct ns1__mplsInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mplsInfo);
	if (soap_out_PointerTons1__mplsInfo(soap, tag?tag:"ns1:mplsInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mplsInfo ** SOAP_FMAC4 soap_get_PointerTons1__mplsInfo(struct soap *soap, struct ns1__mplsInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mplsInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__layer3Info(struct soap *soap, struct ns1__layer3Info *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__layer3Info))
		soap_serialize_ns1__layer3Info(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__layer3Info(struct soap *soap, const char *tag, int id, struct ns1__layer3Info *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__layer3Info);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__layer3Info(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__layer3Info ** SOAP_FMAC4 soap_in_PointerTons1__layer3Info(struct soap *soap, const char *tag, struct ns1__layer3Info **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__layer3Info **)soap_malloc(soap, sizeof(struct ns1__layer3Info *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__layer3Info(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__layer3Info **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__layer3Info, sizeof(struct ns1__layer3Info), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__layer3Info(struct soap *soap, struct ns1__layer3Info *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__layer3Info);
	if (soap_out_PointerTons1__layer3Info(soap, tag?tag:"ns1:layer3Info", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__layer3Info ** SOAP_FMAC4 soap_get_PointerTons1__layer3Info(struct soap *soap, struct ns1__layer3Info **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__layer3Info(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__layer2Info(struct soap *soap, struct ns1__layer2Info *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__layer2Info))
		soap_serialize_ns1__layer2Info(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__layer2Info(struct soap *soap, const char *tag, int id, struct ns1__layer2Info *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__layer2Info);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__layer2Info(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__layer2Info ** SOAP_FMAC4 soap_in_PointerTons1__layer2Info(struct soap *soap, const char *tag, struct ns1__layer2Info **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__layer2Info **)soap_malloc(soap, sizeof(struct ns1__layer2Info *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__layer2Info(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__layer2Info **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__layer2Info, sizeof(struct ns1__layer2Info), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__layer2Info(struct soap *soap, struct ns1__layer2Info *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__layer2Info);
	if (soap_out_PointerTons1__layer2Info(soap, tag?tag:"ns1:layer2Info", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__layer2Info ** SOAP_FMAC4 soap_get_PointerTons1__layer2Info(struct soap *soap, struct ns1__layer2Info **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__layer2Info(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlanePathContent(struct soap *soap, struct ns3__CtrlPlanePathContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlanePathContent))
		soap_serialize_ns3__CtrlPlanePathContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlanePathContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlanePathContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlanePathContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlanePathContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlanePathContent ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlanePathContent(struct soap *soap, const char *tag, struct ns3__CtrlPlanePathContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlanePathContent **)soap_malloc(soap, sizeof(struct ns3__CtrlPlanePathContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlanePathContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlanePathContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlanePathContent, sizeof(struct ns3__CtrlPlanePathContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlanePathContent(struct soap *soap, struct ns3__CtrlPlanePathContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlanePathContent);
	if (soap_out_PointerTons3__CtrlPlanePathContent(soap, tag?tag:"ns3:CtrlPlanePathContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlanePathContent ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlanePathContent(struct soap *soap, struct ns3__CtrlPlanePathContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlanePathContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__teardownPathResponseContent(struct soap *soap, struct ns1__teardownPathResponseContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__teardownPathResponseContent))
		soap_serialize_ns1__teardownPathResponseContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__teardownPathResponseContent(struct soap *soap, const char *tag, int id, struct ns1__teardownPathResponseContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__teardownPathResponseContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__teardownPathResponseContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__teardownPathResponseContent ** SOAP_FMAC4 soap_in_PointerTons1__teardownPathResponseContent(struct soap *soap, const char *tag, struct ns1__teardownPathResponseContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__teardownPathResponseContent **)soap_malloc(soap, sizeof(struct ns1__teardownPathResponseContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__teardownPathResponseContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__teardownPathResponseContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__teardownPathResponseContent, sizeof(struct ns1__teardownPathResponseContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__teardownPathResponseContent(struct soap *soap, struct ns1__teardownPathResponseContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__teardownPathResponseContent);
	if (soap_out_PointerTons1__teardownPathResponseContent(soap, tag?tag:"ns1:teardownPathResponseContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__teardownPathResponseContent ** SOAP_FMAC4 soap_get_PointerTons1__teardownPathResponseContent(struct soap *soap, struct ns1__teardownPathResponseContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__teardownPathResponseContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__refreshPathResponseContent(struct soap *soap, struct ns1__refreshPathResponseContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__refreshPathResponseContent))
		soap_serialize_ns1__refreshPathResponseContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__refreshPathResponseContent(struct soap *soap, const char *tag, int id, struct ns1__refreshPathResponseContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__refreshPathResponseContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__refreshPathResponseContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__refreshPathResponseContent ** SOAP_FMAC4 soap_in_PointerTons1__refreshPathResponseContent(struct soap *soap, const char *tag, struct ns1__refreshPathResponseContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__refreshPathResponseContent **)soap_malloc(soap, sizeof(struct ns1__refreshPathResponseContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__refreshPathResponseContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__refreshPathResponseContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__refreshPathResponseContent, sizeof(struct ns1__refreshPathResponseContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__refreshPathResponseContent(struct soap *soap, struct ns1__refreshPathResponseContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__refreshPathResponseContent);
	if (soap_out_PointerTons1__refreshPathResponseContent(soap, tag?tag:"ns1:refreshPathResponseContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__refreshPathResponseContent ** SOAP_FMAC4 soap_get_PointerTons1__refreshPathResponseContent(struct soap *soap, struct ns1__refreshPathResponseContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__refreshPathResponseContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createPathResponseContent(struct soap *soap, struct ns1__createPathResponseContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createPathResponseContent))
		soap_serialize_ns1__createPathResponseContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createPathResponseContent(struct soap *soap, const char *tag, int id, struct ns1__createPathResponseContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createPathResponseContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__createPathResponseContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__createPathResponseContent ** SOAP_FMAC4 soap_in_PointerTons1__createPathResponseContent(struct soap *soap, const char *tag, struct ns1__createPathResponseContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__createPathResponseContent **)soap_malloc(soap, sizeof(struct ns1__createPathResponseContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__createPathResponseContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__createPathResponseContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createPathResponseContent, sizeof(struct ns1__createPathResponseContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createPathResponseContent(struct soap *soap, struct ns1__createPathResponseContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createPathResponseContent);
	if (soap_out_PointerTons1__createPathResponseContent(soap, tag?tag:"ns1:createPathResponseContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createPathResponseContent ** SOAP_FMAC4 soap_get_PointerTons1__createPathResponseContent(struct soap *soap, struct ns1__createPathResponseContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createPathResponseContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listReply(struct soap *soap, struct ns1__listReply *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listReply))
		soap_serialize_ns1__listReply(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listReply(struct soap *soap, const char *tag, int id, struct ns1__listReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listReply);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__listReply(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__listReply ** SOAP_FMAC4 soap_in_PointerTons1__listReply(struct soap *soap, const char *tag, struct ns1__listReply **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__listReply **)soap_malloc(soap, sizeof(struct ns1__listReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__listReply(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__listReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listReply, sizeof(struct ns1__listReply), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listReply(struct soap *soap, struct ns1__listReply *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listReply);
	if (soap_out_PointerTons1__listReply(soap, tag?tag:"ns1:listReply", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__listReply ** SOAP_FMAC4 soap_get_PointerTons1__listReply(struct soap *soap, struct ns1__listReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyResReply(struct soap *soap, struct ns1__modifyResReply *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyResReply))
		soap_serialize_ns1__modifyResReply(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyResReply(struct soap *soap, const char *tag, int id, struct ns1__modifyResReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyResReply);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__modifyResReply(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__modifyResReply ** SOAP_FMAC4 soap_in_PointerTons1__modifyResReply(struct soap *soap, const char *tag, struct ns1__modifyResReply **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__modifyResReply **)soap_malloc(soap, sizeof(struct ns1__modifyResReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__modifyResReply(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__modifyResReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyResReply, sizeof(struct ns1__modifyResReply), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyResReply(struct soap *soap, struct ns1__modifyResReply *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyResReply);
	if (soap_out_PointerTons1__modifyResReply(soap, tag?tag:"ns1:modifyResReply", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modifyResReply ** SOAP_FMAC4 soap_get_PointerTons1__modifyResReply(struct soap *soap, struct ns1__modifyResReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyResReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createReply(struct soap *soap, struct ns1__createReply *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createReply))
		soap_serialize_ns1__createReply(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createReply(struct soap *soap, const char *tag, int id, struct ns1__createReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createReply);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__createReply(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__createReply ** SOAP_FMAC4 soap_in_PointerTons1__createReply(struct soap *soap, const char *tag, struct ns1__createReply **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__createReply **)soap_malloc(soap, sizeof(struct ns1__createReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__createReply(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__createReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createReply, sizeof(struct ns1__createReply), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createReply(struct soap *soap, struct ns1__createReply *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createReply);
	if (soap_out_PointerTons1__createReply(soap, tag?tag:"ns1:createReply", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createReply ** SOAP_FMAC4 soap_get_PointerTons1__createReply(struct soap *soap, struct ns1__createReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__teardownPathContent(struct soap *soap, struct ns1__teardownPathContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__teardownPathContent))
		soap_serialize_ns1__teardownPathContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__teardownPathContent(struct soap *soap, const char *tag, int id, struct ns1__teardownPathContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__teardownPathContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__teardownPathContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__teardownPathContent ** SOAP_FMAC4 soap_in_PointerTons1__teardownPathContent(struct soap *soap, const char *tag, struct ns1__teardownPathContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__teardownPathContent **)soap_malloc(soap, sizeof(struct ns1__teardownPathContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__teardownPathContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__teardownPathContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__teardownPathContent, sizeof(struct ns1__teardownPathContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__teardownPathContent(struct soap *soap, struct ns1__teardownPathContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__teardownPathContent);
	if (soap_out_PointerTons1__teardownPathContent(soap, tag?tag:"ns1:teardownPathContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__teardownPathContent ** SOAP_FMAC4 soap_get_PointerTons1__teardownPathContent(struct soap *soap, struct ns1__teardownPathContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__teardownPathContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__refreshPathContent(struct soap *soap, struct ns1__refreshPathContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__refreshPathContent))
		soap_serialize_ns1__refreshPathContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__refreshPathContent(struct soap *soap, const char *tag, int id, struct ns1__refreshPathContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__refreshPathContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__refreshPathContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__refreshPathContent ** SOAP_FMAC4 soap_in_PointerTons1__refreshPathContent(struct soap *soap, const char *tag, struct ns1__refreshPathContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__refreshPathContent **)soap_malloc(soap, sizeof(struct ns1__refreshPathContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__refreshPathContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__refreshPathContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__refreshPathContent, sizeof(struct ns1__refreshPathContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__refreshPathContent(struct soap *soap, struct ns1__refreshPathContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__refreshPathContent);
	if (soap_out_PointerTons1__refreshPathContent(soap, tag?tag:"ns1:refreshPathContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__refreshPathContent ** SOAP_FMAC4 soap_get_PointerTons1__refreshPathContent(struct soap *soap, struct ns1__refreshPathContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__refreshPathContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createPathContent(struct soap *soap, struct ns1__createPathContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createPathContent))
		soap_serialize_ns1__createPathContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createPathContent(struct soap *soap, const char *tag, int id, struct ns1__createPathContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createPathContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__createPathContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__createPathContent ** SOAP_FMAC4 soap_in_PointerTons1__createPathContent(struct soap *soap, const char *tag, struct ns1__createPathContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__createPathContent **)soap_malloc(soap, sizeof(struct ns1__createPathContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__createPathContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__createPathContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createPathContent, sizeof(struct ns1__createPathContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createPathContent(struct soap *soap, struct ns1__createPathContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createPathContent);
	if (soap_out_PointerTons1__createPathContent(soap, tag?tag:"ns1:createPathContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createPathContent ** SOAP_FMAC4 soap_get_PointerTons1__createPathContent(struct soap *soap, struct ns1__createPathContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createPathContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listRequest(struct soap *soap, struct ns1__listRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listRequest))
		soap_serialize_ns1__listRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listRequest(struct soap *soap, const char *tag, int id, struct ns1__listRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__listRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__listRequest ** SOAP_FMAC4 soap_in_PointerTons1__listRequest(struct soap *soap, const char *tag, struct ns1__listRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__listRequest **)soap_malloc(soap, sizeof(struct ns1__listRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__listRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__listRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listRequest, sizeof(struct ns1__listRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listRequest(struct soap *soap, struct ns1__listRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listRequest);
	if (soap_out_PointerTons1__listRequest(soap, tag?tag:"ns1:listRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__listRequest ** SOAP_FMAC4 soap_get_PointerTons1__listRequest(struct soap *soap, struct ns1__listRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__globalReservationId(struct soap *soap, struct ns1__globalReservationId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__globalReservationId))
		soap_serialize_ns1__globalReservationId(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__globalReservationId(struct soap *soap, const char *tag, int id, struct ns1__globalReservationId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__globalReservationId);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__globalReservationId(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__globalReservationId ** SOAP_FMAC4 soap_in_PointerTons1__globalReservationId(struct soap *soap, const char *tag, struct ns1__globalReservationId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__globalReservationId **)soap_malloc(soap, sizeof(struct ns1__globalReservationId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__globalReservationId(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__globalReservationId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__globalReservationId, sizeof(struct ns1__globalReservationId), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__globalReservationId(struct soap *soap, struct ns1__globalReservationId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__globalReservationId);
	if (soap_out_PointerTons1__globalReservationId(soap, tag?tag:"ns1:globalReservationId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__globalReservationId ** SOAP_FMAC4 soap_get_PointerTons1__globalReservationId(struct soap *soap, struct ns1__globalReservationId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__globalReservationId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyResContent(struct soap *soap, struct ns1__modifyResContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyResContent))
		soap_serialize_ns1__modifyResContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyResContent(struct soap *soap, const char *tag, int id, struct ns1__modifyResContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyResContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__modifyResContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__modifyResContent ** SOAP_FMAC4 soap_in_PointerTons1__modifyResContent(struct soap *soap, const char *tag, struct ns1__modifyResContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__modifyResContent **)soap_malloc(soap, sizeof(struct ns1__modifyResContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__modifyResContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__modifyResContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyResContent, sizeof(struct ns1__modifyResContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyResContent(struct soap *soap, struct ns1__modifyResContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyResContent);
	if (soap_out_PointerTons1__modifyResContent(soap, tag?tag:"ns1:modifyResContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modifyResContent ** SOAP_FMAC4 soap_get_PointerTons1__modifyResContent(struct soap *soap, struct ns1__modifyResContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__modifyResContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__resCreateContent(struct soap *soap, struct ns1__resCreateContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__resCreateContent))
		soap_serialize_ns1__resCreateContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__resCreateContent(struct soap *soap, const char *tag, int id, struct ns1__resCreateContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__resCreateContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__resCreateContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__resCreateContent ** SOAP_FMAC4 soap_in_PointerTons1__resCreateContent(struct soap *soap, const char *tag, struct ns1__resCreateContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__resCreateContent **)soap_malloc(soap, sizeof(struct ns1__resCreateContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__resCreateContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__resCreateContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__resCreateContent, sizeof(struct ns1__resCreateContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__resCreateContent(struct soap *soap, struct ns1__resCreateContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__resCreateContent);
	if (soap_out_PointerTons1__resCreateContent(soap, tag?tag:"ns1:resCreateContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__resCreateContent ** SOAP_FMAC4 soap_get_PointerTons1__resCreateContent(struct soap *soap, struct ns1__resCreateContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__resCreateContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__resDetails(struct soap *soap, struct ns1__resDetails **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__resDetails))
		soap_serialize_PointerTons1__resDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__resDetails(struct soap *soap, const char *tag, int id, struct ns1__resDetails **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__resDetails);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__resDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__resDetails *** SOAP_FMAC4 soap_in_PointerToPointerTons1__resDetails(struct soap *soap, const char *tag, struct ns1__resDetails ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__resDetails ***)soap_malloc(soap, sizeof(struct ns1__resDetails **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__resDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__resDetails ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__resDetails, sizeof(struct ns1__resDetails *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__resDetails(struct soap *soap, struct ns1__resDetails **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__resDetails);
	if (soap_out_PointerToPointerTons1__resDetails(soap, tag?tag:"ns1:resDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__resDetails *** SOAP_FMAC4 soap_get_PointerToPointerTons1__resDetails(struct soap *soap, struct ns1__resDetails ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__resDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__vlanTag(struct soap *soap, struct ns1__vlanTag **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__vlanTag))
		soap_serialize_PointerTons1__vlanTag(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__vlanTag(struct soap *soap, const char *tag, int id, struct ns1__vlanTag **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__vlanTag);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__vlanTag(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__vlanTag *** SOAP_FMAC4 soap_in_PointerToPointerTons1__vlanTag(struct soap *soap, const char *tag, struct ns1__vlanTag ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__vlanTag ***)soap_malloc(soap, sizeof(struct ns1__vlanTag **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__vlanTag(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__vlanTag ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__vlanTag, sizeof(struct ns1__vlanTag *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__vlanTag(struct soap *soap, struct ns1__vlanTag **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__vlanTag);
	if (soap_out_PointerToPointerTons1__vlanTag(soap, tag?tag:"ns1:vlanTag", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__vlanTag *** SOAP_FMAC4 soap_get_PointerToPointerTons1__vlanTag(struct soap *soap, struct ns1__vlanTag ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__vlanTag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__vlanTag(struct soap *soap, struct ns1__vlanTag *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__vlanTag))
		soap_serialize_ns1__vlanTag(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__vlanTag(struct soap *soap, const char *tag, int id, struct ns1__vlanTag *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__vlanTag);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__vlanTag(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__vlanTag ** SOAP_FMAC4 soap_in_PointerTons1__vlanTag(struct soap *soap, const char *tag, struct ns1__vlanTag **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__vlanTag **)soap_malloc(soap, sizeof(struct ns1__vlanTag *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__vlanTag(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__vlanTag **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__vlanTag, sizeof(struct ns1__vlanTag), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__vlanTag(struct soap *soap, struct ns1__vlanTag *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__vlanTag);
	if (soap_out_PointerTons1__vlanTag(soap, tag?tag:"ns1:vlanTag", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__vlanTag ** SOAP_FMAC4 soap_get_PointerTons1__vlanTag(struct soap *soap, struct ns1__vlanTag **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__vlanTag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns1__listRequest_sequence(struct soap *soap, struct __ns1__listRequest_sequence *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns1__listRequest_sequence))
		soap_serialize___ns1__listRequest_sequence(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns1__listRequest_sequence(struct soap *soap, const char *tag, int id, struct __ns1__listRequest_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns1__listRequest_sequence);
	if (id < 0)
		return soap->error;
	return soap_out___ns1__listRequest_sequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns1__listRequest_sequence ** SOAP_FMAC4 soap_in_PointerTo__ns1__listRequest_sequence(struct soap *soap, const char *tag, struct __ns1__listRequest_sequence **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns1__listRequest_sequence **)soap_malloc(soap, sizeof(struct __ns1__listRequest_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns1__listRequest_sequence(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns1__listRequest_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns1__listRequest_sequence, sizeof(struct __ns1__listRequest_sequence), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns1__listRequest_sequence(struct soap *soap, struct __ns1__listRequest_sequence *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns1__listRequest_sequence);
	if (soap_out_PointerTo__ns1__listRequest_sequence(soap, tag?tag:"-ns1:listRequest-sequence", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns1__listRequest_sequence ** SOAP_FMAC4 soap_get_PointerTo__ns1__listRequest_sequence(struct soap *soap, struct __ns1__listRequest_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns1__listRequest_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CtrlPlaneTopologyContent(struct soap *soap, struct ns3__CtrlPlaneTopologyContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CtrlPlaneTopologyContent))
		soap_serialize_ns3__CtrlPlaneTopologyContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CtrlPlaneTopologyContent(struct soap *soap, const char *tag, int id, struct ns3__CtrlPlaneTopologyContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CtrlPlaneTopologyContent);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__CtrlPlaneTopologyContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__CtrlPlaneTopologyContent ** SOAP_FMAC4 soap_in_PointerTons3__CtrlPlaneTopologyContent(struct soap *soap, const char *tag, struct ns3__CtrlPlaneTopologyContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__CtrlPlaneTopologyContent **)soap_malloc(soap, sizeof(struct ns3__CtrlPlaneTopologyContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__CtrlPlaneTopologyContent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__CtrlPlaneTopologyContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CtrlPlaneTopologyContent, sizeof(struct ns3__CtrlPlaneTopologyContent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CtrlPlaneTopologyContent(struct soap *soap, struct ns3__CtrlPlaneTopologyContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CtrlPlaneTopologyContent);
	if (soap_out_PointerTons3__CtrlPlaneTopologyContent(soap, tag?tag:"ns3:CtrlPlaneTopologyContent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__CtrlPlaneTopologyContent ** SOAP_FMAC4 soap_get_PointerTons3__CtrlPlaneTopologyContent(struct soap *soap, struct ns3__CtrlPlaneTopologyContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CtrlPlaneTopologyContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__resDetails(struct soap *soap, struct ns1__resDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__resDetails))
		soap_serialize_ns1__resDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__resDetails(struct soap *soap, const char *tag, int id, struct ns1__resDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__resDetails);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__resDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__resDetails ** SOAP_FMAC4 soap_in_PointerTons1__resDetails(struct soap *soap, const char *tag, struct ns1__resDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__resDetails **)soap_malloc(soap, sizeof(struct ns1__resDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__resDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__resDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__resDetails, sizeof(struct ns1__resDetails), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__resDetails(struct soap *soap, struct ns1__resDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__resDetails);
	if (soap_out_PointerTons1__resDetails(soap, tag?tag:"ns1:resDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__resDetails ** SOAP_FMAC4 soap_get_PointerTons1__resDetails(struct soap *soap, struct ns1__resDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__resDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__pathInfo(struct soap *soap, struct ns1__pathInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__pathInfo))
		soap_serialize_ns1__pathInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__pathInfo(struct soap *soap, const char *tag, int id, struct ns1__pathInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__pathInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__pathInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__pathInfo ** SOAP_FMAC4 soap_in_PointerTons1__pathInfo(struct soap *soap, const char *tag, struct ns1__pathInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__pathInfo **)soap_malloc(soap, sizeof(struct ns1__pathInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__pathInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__pathInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__pathInfo, sizeof(struct ns1__pathInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__pathInfo(struct soap *soap, struct ns1__pathInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__pathInfo);
	if (soap_out_PointerTons1__pathInfo(soap, tag?tag:"ns1:pathInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__pathInfo ** SOAP_FMAC4 soap_get_PointerTons1__pathInfo(struct soap *soap, struct ns1__pathInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__pathInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns4__AbsoluteOrRelativeTimeType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns4__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns4__AbsoluteOrRelativeTimeType, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__AbsoluteOrRelativeTimeType);
	if (soap_out_ns4__AbsoluteOrRelativeTimeType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns4__AbsoluteOrRelativeTimeType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Security);
	if (soap_out_PointerTo_wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureType);
	if (soap_out_PointerTods__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptedKeyType))
		soap_serialize_xenc__EncryptedKeyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptedKeyType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptedKeyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptedKeyType **)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptedKeyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptedKeyType);
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__BinarySecurityToken);
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__UsernameToken);
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsu__Timestamp);
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__xenc__ReferenceList))
		soap_serialize__xenc__ReferenceList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, int id, struct _xenc__ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xenc__ReferenceList);
	if (id < 0)
		return soap->error;
	return soap_out__xenc__ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_in_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _xenc__ReferenceList **)soap_malloc(soap, sizeof(struct _xenc__ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xenc__ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xenc__ReferenceList);
	if (soap_out_PointerTo_xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_get_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___xenc__union_ReferenceList))
		soap_serialize___xenc__union_ReferenceList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, struct __xenc__union_ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___xenc__union_ReferenceList);
	if (id < 0)
		return soap->error;
	return soap_out___xenc__union_ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_in_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __xenc__union_ReferenceList **)soap_malloc(soap, sizeof(struct __xenc__union_ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___xenc__union_ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __xenc__union_ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__xenc__union_ReferenceList);
	if (soap_out_PointerTo__xenc__union_ReferenceList(soap, tag?tag:"-xenc:union-ReferenceList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_get_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__ReferenceType))
		soap_serialize_xenc__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, int id, struct xenc__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__ReferenceType **)soap_malloc(soap, sizeof(struct xenc__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__ReferenceType);
	if (soap_out_PointerToxenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertyType))
		soap_serialize_xenc__EncryptionPropertyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertyType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertyType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionPropertyType);
	if (soap_out_PointerToxenc__EncryptionPropertyType(soap, tag?tag:"xenc:EncryptionPropertyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__TransformsType))
		soap_serialize_xenc__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__TransformsType(struct soap *soap, const char *tag, int id, struct xenc__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_in_PointerToxenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__TransformsType **)soap_malloc(soap, sizeof(struct xenc__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__TransformsType);
	if (soap_out_PointerToxenc__TransformsType(soap, tag?tag:"xenc:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_get_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherReferenceType))
		soap_serialize_xenc__CipherReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, int id, struct xenc__CipherReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherReferenceType **)soap_malloc(soap, sizeof(struct xenc__CipherReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__CipherReferenceType);
	if (soap_out_PointerToxenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertiesType))
		soap_serialize_xenc__EncryptionPropertiesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertiesType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertiesType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionPropertiesType);
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherDataType))
		soap_serialize_xenc__CipherDataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, int id, struct xenc__CipherDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherDataType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherDataType **)soap_malloc(soap, sizeof(struct xenc__CipherDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__CipherDataType);
	if (soap_out_PointerToxenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ds__KeyInfo))
		soap_serialize__ds__KeyInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__KeyInfo);
	if (id < 0)
		return soap->error;
	return soap_out__ds__KeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ds__KeyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ds__KeyInfo);
	if (soap_out_PointerTo_ds__KeyInfo(soap, tag?tag:"ds:KeyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ds__KeyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionMethodType))
		soap_serialize_xenc__EncryptionMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionMethodType **)soap_malloc(soap, sizeof(struct xenc__EncryptionMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionMethodType);
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509IssuerSerialType);
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RSAKeyValueType);
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DSAKeyValueType);
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformType);
	if (soap_out_PointerTods__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DigestMethodType);
	if (soap_out_PointerTods__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformsType);
	if (soap_out_PointerTods__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTods__ReferenceType, sizeof(struct ds__ReferenceType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTods__ReferenceType);
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__ReferenceType);
	if (soap_out_PointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureMethodType);
	if (soap_out_PointerTods__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__CanonicalizationMethodType);
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__SecurityTokenReference);
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509DataType);
	if (soap_out_PointerTods__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RetrievalMethodType);
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyValueType);
	if (soap_out_PointerTods__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces);
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyInfoType);
	if (soap_out_PointerTods__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignedInfoType);
	if (soap_out_PointerTods__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Embedded);
	if (soap_out_PointerTo_wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__KeyIdentifier);
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Reference);
	if (soap_out_PointerTo_wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Password);
	if (soap_out_PointerTo_wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__FaultTo);
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag?tag:"wsa5:FaultTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__ReplyTo);
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag?tag:"wsa5:ReplyTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__From);
	if (soap_out_PointerTo_wsa5__From(soap, tag?tag:"wsa5:From", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__RelatesTo);
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag?tag:"wsa5:RelatesTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__ProblemHeaderQName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__wsa5__ProblemHeaderQName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__wsa5__ProblemHeaderQName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__wsa5__ProblemHeaderQName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemHeaderQName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa5__ProblemHeaderQName);
	if (soap_out__wsa5__ProblemHeaderQName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__wsa5__ProblemHeaderQName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__ProblemHeaderQName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__MetadataType);
	if (soap_out_PointerTowsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__ReferenceParametersType);
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of oscarsC.c */
