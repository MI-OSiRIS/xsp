/* oscars6C.c
   Generated by gSOAP 2.8.1 from oscars6API.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   The generated code is released under one of the following licenses:
   GPL OR Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "oscars6H.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) oscars6C.c ver 2.8.1 2011-04-10 17:09:09 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap) {
  if (soap->header)
    soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap) {
  if (soap->header) {
    soap->part = SOAP_IN_HEADER;
    if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
      return soap->error;
    soap->part = SOAP_END_HEADER;
  }
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap) {
  soap->part = SOAP_IN_HEADER;
  soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
  soap->part = SOAP_END_HEADER;
  return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap) {
  if (!soap->header) {
    if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
      soap_default_SOAP_ENV__Header(soap, soap->header);
  }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap) {
  if (!soap->fault) {
    soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
    if (!soap->fault)
      return;
    soap_default_SOAP_ENV__Fault(soap, soap->fault);
  }
  if (soap->version == 2 && !soap->fault->SOAP_ENV__Code) {
    soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
    soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
  }
  if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason) {
    soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
    soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
  }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap) {
  if (soap->fault)
    soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap) {
  if (soap->fault)
    return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap) {
  return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2)
    return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
  return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2) {
    if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode) {
      soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
      soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
    }
    return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
  }
  return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 2)
    return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
  return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap) {
  soap_fault(soap);
  if (soap->version == 1) {
    if (!soap->fault->detail) {
      soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
      soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
    }
    return (const char**)&soap->fault->detail->__any;
  }
  if (!soap->fault->SOAP_ENV__Detail) {
    soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
    soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
  }
  return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap) {
  int t;
  if (soap->version == 1) {
    for (;;) {
      if (!soap_getelement(soap, &t))
        if (soap->error || soap_ignore_element(soap))
          break;
    }
  }
  if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
    soap->error = SOAP_OK;
  return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type) {
  if (soap_peek_element(soap))
    return NULL;
  if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
    *type = soap_lookup_type(soap, soap->href);
  switch (*type) {
  case SOAP_TYPE_byte:
    return soap_in_byte(soap, NULL, NULL, "xsd:byte");
  case SOAP_TYPE_int:
    return soap_in_int(soap, NULL, NULL, "xsd:int");
  case SOAP_TYPE_LONG64:
    return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
  case SOAP_TYPE_unsignedInt:
    return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
  case SOAP_TYPE_unsignedLONG64:
    return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
  case SOAP_TYPE_time:
    return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
  case SOAP_TYPE_ns8__DecisionType:
    return soap_in_ns8__DecisionType(soap, NULL, NULL, "ns8:DecisionType");
  case SOAP_TYPE_xsd__boolean_:
    return soap_in_xsd__boolean_(soap, NULL, NULL, "xsd:boolean");
  case SOAP_TYPE_wsse__FaultcodeEnum:
    return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, "wsse:FaultcodeEnum");
  case SOAP_TYPE_wsu__tTimestampFault:
    return soap_in_wsu__tTimestampFault(soap, NULL, NULL, "wsu:tTimestampFault");
  case SOAP_TYPE__wsa5__IsReferenceParameter:
    return soap_in__wsa5__IsReferenceParameter(soap, NULL, NULL, "wsa5:IsReferenceParameter");
  case SOAP_TYPE_wsa5__FaultCodesType:
    return soap_in_wsa5__FaultCodesType(soap, NULL, NULL, "wsa5:FaultCodesType");
  case SOAP_TYPE_wsa5__RelationshipType:
    return soap_in_wsa5__RelationshipType(soap, NULL, NULL, "wsa5:RelationshipType");
  case SOAP_TYPE_ns8__KeyInfoConfirmationDataType:
    return soap_in_ns8__KeyInfoConfirmationDataType(soap, NULL, NULL, "ns8:KeyInfoConfirmationDataType");
  case SOAP_TYPE_ns8__ActionType:
    return soap_in_ns8__ActionType(soap, NULL, NULL, "ns8:ActionType");
  case SOAP_TYPE_ns4__ResourceUnavailableFaultType:
    return soap_in_ns4__ResourceUnavailableFaultType(soap, NULL, NULL, "ns4:ResourceUnavailableFaultType");
  case SOAP_TYPE_ns4__ResourceUnknownFaultType:
    return soap_in_ns4__ResourceUnknownFaultType(soap, NULL, NULL, "ns4:ResourceUnknownFaultType");
  case SOAP_TYPE_ns3__ResumeFailedFaultType:
    return soap_in_ns3__ResumeFailedFaultType(soap, NULL, NULL, "ns3:ResumeFailedFaultType");
  case SOAP_TYPE_ns3__PauseFailedFaultType:
    return soap_in_ns3__PauseFailedFaultType(soap, NULL, NULL, "ns3:PauseFailedFaultType");
  case SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType:
    return soap_in_ns3__UnableToDestroySubscriptionFaultType(soap, NULL, NULL, "ns3:UnableToDestroySubscriptionFaultType");
  case SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType:
    return soap_in_ns3__UnacceptableTerminationTimeFaultType(soap, NULL, NULL, "ns3:UnacceptableTerminationTimeFaultType");
  case SOAP_TYPE_ns3__UnableToCreatePullPointFaultType:
    return soap_in_ns3__UnableToCreatePullPointFaultType(soap, NULL, NULL, "ns3:UnableToCreatePullPointFaultType");
  case SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType:
    return soap_in_ns3__UnableToDestroyPullPointFaultType(soap, NULL, NULL, "ns3:UnableToDestroyPullPointFaultType");
  case SOAP_TYPE_ns3__UnableToGetMessagesFaultType:
    return soap_in_ns3__UnableToGetMessagesFaultType(soap, NULL, NULL, "ns3:UnableToGetMessagesFaultType");
  case SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType:
    return soap_in_ns3__NoCurrentMessageOnTopicFaultType(soap, NULL, NULL, "ns3:NoCurrentMessageOnTopicFaultType");
  case SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType:
    return soap_in_ns3__UnacceptableInitialTerminationTimeFaultType(soap, NULL, NULL, "ns3:UnacceptableInitialTerminationTimeFaultType");
  case SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType:
    return soap_in_ns3__NotifyMessageNotSupportedFaultType(soap, NULL, NULL, "ns3:NotifyMessageNotSupportedFaultType");
  case SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType:
    return soap_in_ns3__UnsupportedPolicyRequestFaultType(soap, NULL, NULL, "ns3:UnsupportedPolicyRequestFaultType");
  case SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType:
    return soap_in_ns3__UnrecognizedPolicyRequestFaultType(soap, NULL, NULL, "ns3:UnrecognizedPolicyRequestFaultType");
  case SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType:
    return soap_in_ns3__InvalidMessageContentExpressionFaultType(soap, NULL, NULL, "ns3:InvalidMessageContentExpressionFaultType");
  case SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType:
    return soap_in_ns3__InvalidProducerPropertiesExpressionFaultType(soap, NULL, NULL, "ns3:InvalidProducerPropertiesExpressionFaultType");
  case SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType:
    return soap_in_ns3__MultipleTopicsSpecifiedFaultType(soap, NULL, NULL, "ns3:MultipleTopicsSpecifiedFaultType");
  case SOAP_TYPE_ns3__TopicNotSupportedFaultType:
    return soap_in_ns3__TopicNotSupportedFaultType(soap, NULL, NULL, "ns3:TopicNotSupportedFaultType");
  case SOAP_TYPE_ns3__InvalidTopicExpressionFaultType:
    return soap_in_ns3__InvalidTopicExpressionFaultType(soap, NULL, NULL, "ns3:InvalidTopicExpressionFaultType");
  case SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType:
    return soap_in_ns3__TopicExpressionDialectUnknownFaultType(soap, NULL, NULL, "ns3:TopicExpressionDialectUnknownFaultType");
  case SOAP_TYPE_ns3__InvalidFilterFaultType:
    return soap_in_ns3__InvalidFilterFaultType(soap, NULL, NULL, "ns3:InvalidFilterFaultType");
  case SOAP_TYPE_ns3__SubscribeCreationFailedFaultType:
    return soap_in_ns3__SubscribeCreationFailedFaultType(soap, NULL, NULL, "ns3:SubscribeCreationFailedFaultType");
  case SOAP_TYPE_ns1__reservationResourceType:
    return soap_in_ns1__reservationResourceType(soap, NULL, NULL, "ns1:reservationResourceType");
  case SOAP_TYPE_ns8__EvidenceType:
    return soap_in_ns8__EvidenceType(soap, NULL, NULL, "ns8:EvidenceType");
  case SOAP_TYPE_ns8__AuthnContextType:
    return soap_in_ns8__AuthnContextType(soap, NULL, NULL, "ns8:AuthnContextType");
  case SOAP_TYPE_ns8__SubjectLocalityType:
    return soap_in_ns8__SubjectLocalityType(soap, NULL, NULL, "ns8:SubjectLocalityType");
  case SOAP_TYPE_ns8__ProxyRestrictionType:
    return soap_in_ns8__ProxyRestrictionType(soap, NULL, NULL, "ns8:ProxyRestrictionType");
  case SOAP_TYPE_ns8__OneTimeUseType:
    return soap_in_ns8__OneTimeUseType(soap, NULL, NULL, "ns8:OneTimeUseType");
  case SOAP_TYPE_ns8__AudienceRestrictionType:
    return soap_in_ns8__AudienceRestrictionType(soap, NULL, NULL, "ns8:AudienceRestrictionType");
  case SOAP_TYPE_ns8__ConditionAbstractType:
    return soap_in_ns8__ConditionAbstractType(soap, NULL, NULL, "ns8:ConditionAbstractType");
  case SOAP_TYPE_ns8__SubjectConfirmationDataType:
    return soap_in_ns8__SubjectConfirmationDataType(soap, NULL, NULL, "ns8:SubjectConfirmationDataType");
  case SOAP_TYPE_ns8__SubjectConfirmationType:
    return soap_in_ns8__SubjectConfirmationType(soap, NULL, NULL, "ns8:SubjectConfirmationType");
  case SOAP_TYPE_ns8__AttributeStatementType:
    return soap_in_ns8__AttributeStatementType(soap, NULL, NULL, "ns8:AttributeStatementType");
  case SOAP_TYPE_ns8__AuthzDecisionStatementType:
    return soap_in_ns8__AuthzDecisionStatementType(soap, NULL, NULL, "ns8:AuthzDecisionStatementType");
  case SOAP_TYPE_ns8__AuthnStatementType:
    return soap_in_ns8__AuthnStatementType(soap, NULL, NULL, "ns8:AuthnStatementType");
  case SOAP_TYPE_ns8__StatementAbstractType:
    return soap_in_ns8__StatementAbstractType(soap, NULL, NULL, "ns8:StatementAbstractType");
  case SOAP_TYPE_ns8__AdviceType:
    return soap_in_ns8__AdviceType(soap, NULL, NULL, "ns8:AdviceType");
  case SOAP_TYPE_ns8__ConditionsType:
    return soap_in_ns8__ConditionsType(soap, NULL, NULL, "ns8:ConditionsType");
  case SOAP_TYPE_ns8__SubjectType:
    return soap_in_ns8__SubjectType(soap, NULL, NULL, "ns8:SubjectType");
  case SOAP_TYPE_ns8__NameIDType:
    return soap_in_ns8__NameIDType(soap, NULL, NULL, "ns8:NameIDType");
  case SOAP_TYPE_ns8__AssertionType:
    return soap_in_ns8__AssertionType(soap, NULL, NULL, "ns8:AssertionType");
  case SOAP_TYPE_ns8__EncryptedElementType:
    return soap_in_ns8__EncryptedElementType(soap, NULL, NULL, "ns8:EncryptedElementType");
  case SOAP_TYPE_ns8__BaseIDAbstractType:
    return soap_in_ns8__BaseIDAbstractType(soap, NULL, NULL, "ns8:BaseIDAbstractType");
  case SOAP_TYPE_ns7__FaultCauseType:
    return soap_in_ns7__FaultCauseType(soap, NULL, NULL, "ns7:FaultCauseType");
  case SOAP_TYPE_ns7__ErrorCodeType:
    return soap_in_ns7__ErrorCodeType(soap, NULL, NULL, "ns7:ErrorCodeType");
  case SOAP_TYPE_ns7__BaseFaultType:
    return soap_in_ns7__BaseFaultType(soap, NULL, NULL, "ns7:BaseFaultType");
  case SOAP_TYPE_ns6__authConditionType:
    return soap_in_ns6__authConditionType(soap, NULL, NULL, "ns6:authConditionType");
  case SOAP_TYPE_ns6__authConditions:
    return soap_in_ns6__authConditions(soap, NULL, NULL, "ns6:authConditions");
  case SOAP_TYPE_ns8__AttributeType:
    return soap_in_ns8__AttributeType(soap, NULL, NULL, "ns8:AttributeType");
  case SOAP_TYPE_ns6__subjectAttributes:
    return soap_in_ns6__subjectAttributes(soap, NULL, NULL, "ns6:subjectAttributes");
  case SOAP_TYPE_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo:
    return soap_in_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, NULL, NULL, "ns5:CtrlPlaneSwitchingCapabilitySpecificInfo");
  case SOAP_TYPE_ns5__Duration:
    return soap_in_ns5__Duration(soap, NULL, NULL, "ns5:Duration");
  case SOAP_TYPE_ns5__TimeContent:
    return soap_in_ns5__TimeContent(soap, NULL, NULL, "ns5:TimeContent");
  case SOAP_TYPE_ns5__CtrlPlaneNextHopContent:
    return soap_in_ns5__CtrlPlaneNextHopContent(soap, NULL, NULL, "ns5:CtrlPlaneNextHopContent");
  case SOAP_TYPE_ns5__CtrlPlaneHopContent:
    return soap_in_ns5__CtrlPlaneHopContent(soap, NULL, NULL, "ns5:CtrlPlaneHopContent");
  case SOAP_TYPE_ns5__CtrlPlaneSwcapContent:
    return soap_in_ns5__CtrlPlaneSwcapContent(soap, NULL, NULL, "ns5:CtrlPlaneSwcapContent");
  case SOAP_TYPE_ns5__CtrlPlaneAdministrativeGroup:
    return soap_in_ns5__CtrlPlaneAdministrativeGroup(soap, NULL, NULL, "ns5:CtrlPlaneAdministrativeGroup");
  case SOAP_TYPE_ns5__CtrlPlaneAddressContent:
    return soap_in_ns5__CtrlPlaneAddressContent(soap, NULL, NULL, "ns5:CtrlPlaneAddressContent");
  case SOAP_TYPE_ns5__CtrlPlaneLinkContent:
    return soap_in_ns5__CtrlPlaneLinkContent(soap, NULL, NULL, "ns5:CtrlPlaneLinkContent");
  case SOAP_TYPE_ns5__CtrlPlanePortContent:
    return soap_in_ns5__CtrlPlanePortContent(soap, NULL, NULL, "ns5:CtrlPlanePortContent");
  case SOAP_TYPE_ns5__CtrlPlaneNodeContent:
    return soap_in_ns5__CtrlPlaneNodeContent(soap, NULL, NULL, "ns5:CtrlPlaneNodeContent");
  case SOAP_TYPE_ns5__Lifetime:
    return soap_in_ns5__Lifetime(soap, NULL, NULL, "ns5:Lifetime");
  case SOAP_TYPE_ns5__CtrlPlaneDomainSignatureContent:
    return soap_in_ns5__CtrlPlaneDomainSignatureContent(soap, NULL, NULL, "ns5:CtrlPlaneDomainSignatureContent");
  case SOAP_TYPE_ns5__CtrlPlaneDomainContent:
    return soap_in_ns5__CtrlPlaneDomainContent(soap, NULL, NULL, "ns5:CtrlPlaneDomainContent");
  case SOAP_TYPE_ns3__MessageType:
    return soap_in_ns3__MessageType(soap, NULL, NULL, "ns3:MessageType");
  case SOAP_TYPE_ns3__NotificationMessageHolderType:
    return soap_in_ns3__NotificationMessageHolderType(soap, NULL, NULL, "ns3:NotificationMessageHolderType");
  case SOAP_TYPE_ns3__SubscriptionPolicyType:
    return soap_in_ns3__SubscriptionPolicyType(soap, NULL, NULL, "ns3:SubscriptionPolicyType");
  case SOAP_TYPE_ns3__QueryExpressionType:
    return soap_in_ns3__QueryExpressionType(soap, NULL, NULL, "ns3:QueryExpressionType");
  case SOAP_TYPE_ns3__TopicExpressionType:
    return soap_in_ns3__TopicExpressionType(soap, NULL, NULL, "ns3:TopicExpressionType");
  case SOAP_TYPE_ns3__FilterType:
    return soap_in_ns3__FilterType(soap, NULL, NULL, "ns3:FilterType");
  case SOAP_TYPE_ns2__emptyArg:
    return soap_in_ns2__emptyArg(soap, NULL, NULL, "ns2:emptyArg");
  case SOAP_TYPE_ns1__optionalConstraintValue:
    return soap_in_ns1__optionalConstraintValue(soap, NULL, NULL, "ns1:optionalConstraintValue");
  case SOAP_TYPE_ns1__globalReservationId:
    return soap_in_ns1__globalReservationId(soap, NULL, NULL, "ns1:globalReservationId");
  case SOAP_TYPE_ns1__localDetails:
    return soap_in_ns1__localDetails(soap, NULL, NULL, "ns1:localDetails");
  case SOAP_TYPE_ns1__eventContent:
    return soap_in_ns1__eventContent(soap, NULL, NULL, "ns1:eventContent");
  case SOAP_TYPE_ns1__interDomainEventContent:
    return soap_in_ns1__interDomainEventContent(soap, NULL, NULL, "ns1:interDomainEventContent");
  case SOAP_TYPE_ns1__mplsInfo:
    return soap_in_ns1__mplsInfo(soap, NULL, NULL, "ns1:mplsInfo");
  case SOAP_TYPE_ns1__layer3Info:
    return soap_in_ns1__layer3Info(soap, NULL, NULL, "ns1:layer3Info");
  case SOAP_TYPE_ns1__layer2Info:
    return soap_in_ns1__layer2Info(soap, NULL, NULL, "ns1:layer2Info");
  case SOAP_TYPE_ns5__CtrlPlanePathContent:
    return soap_in_ns5__CtrlPlanePathContent(soap, NULL, NULL, "ns5:CtrlPlanePathContent");
  case SOAP_TYPE_ns1__pathInfo:
    return soap_in_ns1__pathInfo(soap, NULL, NULL, "ns1:pathInfo");
  case SOAP_TYPE_ns1__listReply:
    return soap_in_ns1__listReply(soap, NULL, NULL, "ns1:listReply");
  case SOAP_TYPE_ns1__vlanTag:
    return soap_in_ns1__vlanTag(soap, NULL, NULL, "ns1:vlanTag");
  case SOAP_TYPE_ns1__listRequest:
    return soap_in_ns1__listRequest(soap, NULL, NULL, "ns1:listRequest");
  case SOAP_TYPE_ns1__teardownPathResponseContent:
    return soap_in_ns1__teardownPathResponseContent(soap, NULL, NULL, "ns1:teardownPathResponseContent");
  case SOAP_TYPE_ns1__teardownPathContent:
    return soap_in_ns1__teardownPathContent(soap, NULL, NULL, "ns1:teardownPathContent");
  case SOAP_TYPE_ns1__refreshPathResponseContent:
    return soap_in_ns1__refreshPathResponseContent(soap, NULL, NULL, "ns1:refreshPathResponseContent");
  case SOAP_TYPE_ns1__refreshPathContent:
    return soap_in_ns1__refreshPathContent(soap, NULL, NULL, "ns1:refreshPathContent");
  case SOAP_TYPE_ns1__createPathResponseContent:
    return soap_in_ns1__createPathResponseContent(soap, NULL, NULL, "ns1:createPathResponseContent");
  case SOAP_TYPE_ns1__createPathContent:
    return soap_in_ns1__createPathContent(soap, NULL, NULL, "ns1:createPathContent");
  case SOAP_TYPE_ns5__CtrlPlaneTopologyContent:
    return soap_in_ns5__CtrlPlaneTopologyContent(soap, NULL, NULL, "ns5:CtrlPlaneTopologyContent");
  case SOAP_TYPE_ns1__getTopologyResponseContent:
    return soap_in_ns1__getTopologyResponseContent(soap, NULL, NULL, "ns1:getTopologyResponseContent");
  case SOAP_TYPE_ns1__getTopologyContent:
    return soap_in_ns1__getTopologyContent(soap, NULL, NULL, "ns1:getTopologyContent");
  case SOAP_TYPE_ns1__modifyResReply:
    return soap_in_ns1__modifyResReply(soap, NULL, NULL, "ns1:modifyResReply");
  case SOAP_TYPE_ns1__modifyResContent:
    return soap_in_ns1__modifyResContent(soap, NULL, NULL, "ns1:modifyResContent");
  case SOAP_TYPE_ns1__resDetails:
    return soap_in_ns1__resDetails(soap, NULL, NULL, "ns1:resDetails");
  case SOAP_TYPE_ns1__queryResReply:
    return soap_in_ns1__queryResReply(soap, NULL, NULL, "ns1:queryResReply");
  case SOAP_TYPE_ns1__queryResContent:
    return soap_in_ns1__queryResContent(soap, NULL, NULL, "ns1:queryResContent");
  case SOAP_TYPE_ns1__cancelResReply:
    return soap_in_ns1__cancelResReply(soap, NULL, NULL, "ns1:cancelResReply");
  case SOAP_TYPE_ns1__cancelResContent:
    return soap_in_ns1__cancelResContent(soap, NULL, NULL, "ns1:cancelResContent");
  case SOAP_TYPE_ns1__createReply:
    return soap_in_ns1__createReply(soap, NULL, NULL, "ns1:createReply");
  case SOAP_TYPE_ns1__optionalConstraintType:
    return soap_in_ns1__optionalConstraintType(soap, NULL, NULL, "ns1:optionalConstraintType");
  case SOAP_TYPE_ns1__reservedConstraintType:
    return soap_in_ns1__reservedConstraintType(soap, NULL, NULL, "ns1:reservedConstraintType");
  case SOAP_TYPE_ns1__userRequestConstraintType:
    return soap_in_ns1__userRequestConstraintType(soap, NULL, NULL, "ns1:userRequestConstraintType");
  case SOAP_TYPE_ns6__messagePropertiesType:
    return soap_in_ns6__messagePropertiesType(soap, NULL, NULL, "ns6:messagePropertiesType");
  case SOAP_TYPE_ns1__resCreateContent:
    return soap_in_ns1__resCreateContent(soap, NULL, NULL, "ns1:resCreateContent");
  case SOAP_TYPE_wsa5__ProblemActionType:
    return soap_in_wsa5__ProblemActionType(soap, NULL, NULL, "wsa5:ProblemActionType");
  case SOAP_TYPE_wsa5__RelatesToType:
    return soap_in_wsa5__RelatesToType(soap, NULL, NULL, "wsa5:RelatesToType");
  case SOAP_TYPE_wsa5__MetadataType:
    return soap_in_wsa5__MetadataType(soap, NULL, NULL, "wsa5:MetadataType");
  case SOAP_TYPE_wsa5__ReferenceParametersType:
    return soap_in_wsa5__ReferenceParametersType(soap, NULL, NULL, "wsa5:ReferenceParametersType");
  case SOAP_TYPE_wsa5__EndpointReferenceType:
    return soap_in_wsa5__EndpointReferenceType(soap, NULL, NULL, "wsa5:EndpointReferenceType");
  case SOAP_TYPE_xenc__EncryptionPropertyType:
    return soap_in_xenc__EncryptionPropertyType(soap, NULL, NULL, "xenc:EncryptionPropertyType");
  case SOAP_TYPE_xenc__EncryptionPropertiesType:
    return soap_in_xenc__EncryptionPropertiesType(soap, NULL, NULL, "xenc:EncryptionPropertiesType");
  case SOAP_TYPE_xenc__ReferenceType:
    return soap_in_xenc__ReferenceType(soap, NULL, NULL, "xenc:ReferenceType");
  case SOAP_TYPE_xenc__AgreementMethodType:
    return soap_in_xenc__AgreementMethodType(soap, NULL, NULL, "xenc:AgreementMethodType");
  case SOAP_TYPE_xenc__EncryptedKeyType:
    return soap_in_xenc__EncryptedKeyType(soap, NULL, NULL, "xenc:EncryptedKeyType");
  case SOAP_TYPE_xenc__EncryptedDataType:
    return soap_in_xenc__EncryptedDataType(soap, NULL, NULL, "xenc:EncryptedDataType");
  case SOAP_TYPE_xenc__TransformsType:
    return soap_in_xenc__TransformsType(soap, NULL, NULL, "xenc:TransformsType");
  case SOAP_TYPE_xenc__CipherReferenceType:
    return soap_in_xenc__CipherReferenceType(soap, NULL, NULL, "xenc:CipherReferenceType");
  case SOAP_TYPE_xenc__CipherDataType:
    return soap_in_xenc__CipherDataType(soap, NULL, NULL, "xenc:CipherDataType");
  case SOAP_TYPE_xenc__EncryptionMethodType:
    return soap_in_xenc__EncryptionMethodType(soap, NULL, NULL, "xenc:EncryptionMethodType");
  case SOAP_TYPE_xenc__EncryptedType:
    return soap_in_xenc__EncryptedType(soap, NULL, NULL, "xenc:EncryptedType");
  case SOAP_TYPE_ds__RSAKeyValueType:
    return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
  case SOAP_TYPE_ds__DSAKeyValueType:
    return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
  case SOAP_TYPE_ds__X509IssuerSerialType:
    return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
  case SOAP_TYPE_ds__X509DataType:
    return soap_in_ds__X509DataType(soap, NULL, NULL, "ds:X509DataType");
  case SOAP_TYPE_ds__RetrievalMethodType:
    return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
  case SOAP_TYPE_ds__KeyValueType:
    return soap_in_ds__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
  case SOAP_TYPE_ds__DigestMethodType:
    return soap_in_ds__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
  case SOAP_TYPE_ds__TransformType:
    return soap_in_ds__TransformType(soap, NULL, NULL, "ds:TransformType");
  case SOAP_TYPE_ds__TransformsType:
    return soap_in_ds__TransformsType(soap, NULL, NULL, "ds:TransformsType");
  case SOAP_TYPE_ds__ReferenceType:
    return soap_in_ds__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
  case SOAP_TYPE_ds__SignatureMethodType:
    return soap_in_ds__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
  case SOAP_TYPE_ds__CanonicalizationMethodType:
    return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
  case SOAP_TYPE_ds__KeyInfoType:
    return soap_in_ds__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
  case SOAP_TYPE_ds__SignedInfoType:
    return soap_in_ds__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
  case SOAP_TYPE_ds__SignatureType:
    return soap_in_ds__SignatureType(soap, NULL, NULL, "ds:SignatureType");
  case SOAP_TYPE_PointerTons1__interDomainEventContent:
    return soap_in_PointerTons1__interDomainEventContent(soap, NULL, NULL, "ns1:interDomainEventContent");
  case SOAP_TYPE_PointerTons1__teardownPathResponseContent:
    return soap_in_PointerTons1__teardownPathResponseContent(soap, NULL, NULL, "ns1:teardownPathResponseContent");
  case SOAP_TYPE_PointerTons1__teardownPathContent:
    return soap_in_PointerTons1__teardownPathContent(soap, NULL, NULL, "ns1:teardownPathContent");
  case SOAP_TYPE_PointerTons1__refreshPathResponseContent:
    return soap_in_PointerTons1__refreshPathResponseContent(soap, NULL, NULL, "ns1:refreshPathResponseContent");
  case SOAP_TYPE_PointerTons1__refreshPathContent:
    return soap_in_PointerTons1__refreshPathContent(soap, NULL, NULL, "ns1:refreshPathContent");
  case SOAP_TYPE_PointerTons1__createPathResponseContent:
    return soap_in_PointerTons1__createPathResponseContent(soap, NULL, NULL, "ns1:createPathResponseContent");
  case SOAP_TYPE_PointerTons1__createPathContent:
    return soap_in_PointerTons1__createPathContent(soap, NULL, NULL, "ns1:createPathContent");
  case SOAP_TYPE_PointerTons1__getTopologyResponseContent:
    return soap_in_PointerTons1__getTopologyResponseContent(soap, NULL, NULL, "ns1:getTopologyResponseContent");
  case SOAP_TYPE_PointerTons1__getTopologyContent:
    return soap_in_PointerTons1__getTopologyContent(soap, NULL, NULL, "ns1:getTopologyContent");
  case SOAP_TYPE_PointerTons1__modifyResReply:
    return soap_in_PointerTons1__modifyResReply(soap, NULL, NULL, "ns1:modifyResReply");
  case SOAP_TYPE_PointerTons1__modifyResContent:
    return soap_in_PointerTons1__modifyResContent(soap, NULL, NULL, "ns1:modifyResContent");
  case SOAP_TYPE_PointerTons1__cancelResReply:
    return soap_in_PointerTons1__cancelResReply(soap, NULL, NULL, "ns1:cancelResReply");
  case SOAP_TYPE_PointerTons1__cancelResContent:
    return soap_in_PointerTons1__cancelResContent(soap, NULL, NULL, "ns1:cancelResContent");
  case SOAP_TYPE_PointerTons1__listReply:
    return soap_in_PointerTons1__listReply(soap, NULL, NULL, "ns1:listReply");
  case SOAP_TYPE_PointerTons1__listRequest:
    return soap_in_PointerTons1__listRequest(soap, NULL, NULL, "ns1:listRequest");
  case SOAP_TYPE_PointerTons1__queryResReply:
    return soap_in_PointerTons1__queryResReply(soap, NULL, NULL, "ns1:queryResReply");
  case SOAP_TYPE_PointerTons1__queryResContent:
    return soap_in_PointerTons1__queryResContent(soap, NULL, NULL, "ns1:queryResContent");
  case SOAP_TYPE_PointerTons1__createReply:
    return soap_in_PointerTons1__createReply(soap, NULL, NULL, "ns1:createReply");
  case SOAP_TYPE_PointerTons1__resCreateContent:
    return soap_in_PointerTons1__resCreateContent(soap, NULL, NULL, "ns1:resCreateContent");
  case SOAP_TYPE_PointerTo_ns2__OSCARSFault:
    return soap_in_PointerTo_ns2__OSCARSFault(soap, NULL, NULL, "ns2:OSCARSFault");
  case SOAP_TYPE_PointerTons8__EvidenceType:
    return soap_in_PointerTons8__EvidenceType(soap, NULL, NULL, "ns8:EvidenceType");
  case SOAP_TYPE_PointerToPointerTons8__ActionType:
    return soap_in_PointerToPointerTons8__ActionType(soap, NULL, NULL, "ns8:ActionType");
  case SOAP_TYPE_PointerTons8__ActionType:
    return soap_in_PointerTons8__ActionType(soap, NULL, NULL, "ns8:ActionType");
  case SOAP_TYPE_PointerTons8__AuthnContextType:
    return soap_in_PointerTons8__AuthnContextType(soap, NULL, NULL, "ns8:AuthnContextType");
  case SOAP_TYPE_PointerTons8__SubjectLocalityType:
    return soap_in_PointerTons8__SubjectLocalityType(soap, NULL, NULL, "ns8:SubjectLocalityType");
  case SOAP_TYPE_PointerTo_QName:
    return soap_in_PointerTo_QName(soap, NULL, NULL, "xsd:QName");
  case SOAP_TYPE_PointerTons8__AssertionType:
    return soap_in_PointerTons8__AssertionType(soap, NULL, NULL, "ns8:AssertionType");
  case SOAP_TYPE_PointerTons8__ProxyRestrictionType:
    return soap_in_PointerTons8__ProxyRestrictionType(soap, NULL, NULL, "ns8:ProxyRestrictionType");
  case SOAP_TYPE_PointerTons8__OneTimeUseType:
    return soap_in_PointerTons8__OneTimeUseType(soap, NULL, NULL, "ns8:OneTimeUseType");
  case SOAP_TYPE_PointerTons8__AudienceRestrictionType:
    return soap_in_PointerTons8__AudienceRestrictionType(soap, NULL, NULL, "ns8:AudienceRestrictionType");
  case SOAP_TYPE_PointerTons8__ConditionAbstractType:
    return soap_in_PointerTons8__ConditionAbstractType(soap, NULL, NULL, "ns8:ConditionAbstractType");
  case SOAP_TYPE_PointerTons8__SubjectConfirmationDataType:
    return soap_in_PointerTons8__SubjectConfirmationDataType(soap, NULL, NULL, "ns8:SubjectConfirmationDataType");
  case SOAP_TYPE_PointerToPointerTons8__SubjectConfirmationType:
    return soap_in_PointerToPointerTons8__SubjectConfirmationType(soap, NULL, NULL, "ns8:SubjectConfirmationType");
  case SOAP_TYPE_PointerTons8__SubjectConfirmationType:
    return soap_in_PointerTons8__SubjectConfirmationType(soap, NULL, NULL, "ns8:SubjectConfirmationType");
  case SOAP_TYPE_PointerTons8__EncryptedElementType:
    return soap_in_PointerTons8__EncryptedElementType(soap, NULL, NULL, "ns8:EncryptedElementType");
  case SOAP_TYPE_PointerTons8__BaseIDAbstractType:
    return soap_in_PointerTons8__BaseIDAbstractType(soap, NULL, NULL, "ns8:BaseIDAbstractType");
  case SOAP_TYPE_PointerTons8__AttributeStatementType:
    return soap_in_PointerTons8__AttributeStatementType(soap, NULL, NULL, "ns8:AttributeStatementType");
  case SOAP_TYPE_PointerTons8__AuthzDecisionStatementType:
    return soap_in_PointerTons8__AuthzDecisionStatementType(soap, NULL, NULL, "ns8:AuthzDecisionStatementType");
  case SOAP_TYPE_PointerTons8__AuthnStatementType:
    return soap_in_PointerTons8__AuthnStatementType(soap, NULL, NULL, "ns8:AuthnStatementType");
  case SOAP_TYPE_PointerTons8__StatementAbstractType:
    return soap_in_PointerTons8__StatementAbstractType(soap, NULL, NULL, "ns8:StatementAbstractType");
  case SOAP_TYPE_PointerTons8__AdviceType:
    return soap_in_PointerTons8__AdviceType(soap, NULL, NULL, "ns8:AdviceType");
  case SOAP_TYPE_PointerTons8__ConditionsType:
    return soap_in_PointerTons8__ConditionsType(soap, NULL, NULL, "ns8:ConditionsType");
  case SOAP_TYPE_PointerTons8__SubjectType:
    return soap_in_PointerTons8__SubjectType(soap, NULL, NULL, "ns8:SubjectType");
  case SOAP_TYPE_PointerTo_ds__Signature:
    return soap_in_PointerTo_ds__Signature(soap, NULL, NULL, "ds:Signature");
  case SOAP_TYPE_PointerTons8__NameIDType:
    return soap_in_PointerTons8__NameIDType(soap, NULL, NULL, "ns8:NameIDType");
  case SOAP_TYPE_PointerTo_xenc__EncryptedKey:
    return soap_in_PointerTo_xenc__EncryptedKey(soap, NULL, NULL, "xenc:EncryptedKey");
  case SOAP_TYPE_PointerTons7__FaultCauseType:
    return soap_in_PointerTons7__FaultCauseType(soap, NULL, NULL, "ns7:FaultCauseType");
  case SOAP_TYPE_PointerTons7__ErrorCodeType:
    return soap_in_PointerTons7__ErrorCodeType(soap, NULL, NULL, "ns7:ErrorCodeType");
  case SOAP_TYPE_PointerToPointerTons6__authConditionType:
    return soap_in_PointerToPointerTons6__authConditionType(soap, NULL, NULL, "ns6:authConditionType");
  case SOAP_TYPE_PointerTons6__authConditionType:
    return soap_in_PointerTons6__authConditionType(soap, NULL, NULL, "ns6:authConditionType");
  case SOAP_TYPE_PointerToPointerTons8__AttributeType:
    return soap_in_PointerToPointerTons8__AttributeType(soap, NULL, NULL, "ns8:AttributeType");
  case SOAP_TYPE_PointerTons8__AttributeType:
    return soap_in_PointerTons8__AttributeType(soap, NULL, NULL, "ns8:AttributeType");
  case SOAP_TYPE_PointerTons6__subjectAttributes:
    return soap_in_PointerTons6__subjectAttributes(soap, NULL, NULL, "ns6:subjectAttributes");
  case SOAP_TYPE_PointerToxsd__boolean_:
    return soap_in_PointerToxsd__boolean_(soap, NULL, NULL, "xsd:boolean");
  case SOAP_TYPE_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo:
    return soap_in_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, NULL, NULL, "ns5:CtrlPlaneSwitchingCapabilitySpecificInfo");
  case SOAP_TYPE_PointerTons5__Duration:
    return soap_in_PointerTons5__Duration(soap, NULL, NULL, "ns5:Duration");
  case SOAP_TYPE_PointerTons5__TimeContent:
    return soap_in_PointerTons5__TimeContent(soap, NULL, NULL, "ns5:TimeContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneNextHopContent:
    return soap_in_PointerToPointerTons5__CtrlPlaneNextHopContent(soap, NULL, NULL, "ns5:CtrlPlaneNextHopContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneNextHopContent:
    return soap_in_PointerTons5__CtrlPlaneNextHopContent(soap, NULL, NULL, "ns5:CtrlPlaneNextHopContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneHopContent:
    return soap_in_PointerToPointerTons5__CtrlPlaneHopContent(soap, NULL, NULL, "ns5:CtrlPlaneHopContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneHopContent:
    return soap_in_PointerTons5__CtrlPlaneHopContent(soap, NULL, NULL, "ns5:CtrlPlaneHopContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneSwcapContent:
    return soap_in_PointerTons5__CtrlPlaneSwcapContent(soap, NULL, NULL, "ns5:CtrlPlaneSwcapContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneAdministrativeGroup:
    return soap_in_PointerToPointerTons5__CtrlPlaneAdministrativeGroup(soap, NULL, NULL, "ns5:CtrlPlaneAdministrativeGroup");
  case SOAP_TYPE_PointerTons5__CtrlPlaneAdministrativeGroup:
    return soap_in_PointerTons5__CtrlPlaneAdministrativeGroup(soap, NULL, NULL, "ns5:CtrlPlaneAdministrativeGroup");
  case SOAP_TYPE_PointerTons5__CtrlPlaneAddressContent:
    return soap_in_PointerTons5__CtrlPlaneAddressContent(soap, NULL, NULL, "ns5:CtrlPlaneAddressContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneLinkContent:
    return soap_in_PointerToPointerTons5__CtrlPlaneLinkContent(soap, NULL, NULL, "ns5:CtrlPlaneLinkContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneLinkContent:
    return soap_in_PointerTons5__CtrlPlaneLinkContent(soap, NULL, NULL, "ns5:CtrlPlaneLinkContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlanePortContent:
    return soap_in_PointerToPointerTons5__CtrlPlanePortContent(soap, NULL, NULL, "ns5:CtrlPlanePortContent");
  case SOAP_TYPE_PointerTons5__CtrlPlanePortContent:
    return soap_in_PointerTons5__CtrlPlanePortContent(soap, NULL, NULL, "ns5:CtrlPlanePortContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneNodeContent:
    return soap_in_PointerToPointerTons5__CtrlPlaneNodeContent(soap, NULL, NULL, "ns5:CtrlPlaneNodeContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneNodeContent:
    return soap_in_PointerTons5__CtrlPlaneNodeContent(soap, NULL, NULL, "ns5:CtrlPlaneNodeContent");
  case SOAP_TYPE_PointerTons5__Lifetime:
    return soap_in_PointerTons5__Lifetime(soap, NULL, NULL, "ns5:Lifetime");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneDomainSignatureContent:
    return soap_in_PointerToPointerTons5__CtrlPlaneDomainSignatureContent(soap, NULL, NULL, "ns5:CtrlPlaneDomainSignatureContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneDomainSignatureContent:
    return soap_in_PointerTons5__CtrlPlaneDomainSignatureContent(soap, NULL, NULL, "ns5:CtrlPlaneDomainSignatureContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneDomainContent:
    return soap_in_PointerToPointerTons5__CtrlPlaneDomainContent(soap, NULL, NULL, "ns5:CtrlPlaneDomainContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneDomainContent:
    return soap_in_PointerTons5__CtrlPlaneDomainContent(soap, NULL, NULL, "ns5:CtrlPlaneDomainContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlanePathContent:
    return soap_in_PointerToPointerTons5__CtrlPlanePathContent(soap, NULL, NULL, "ns5:CtrlPlanePathContent");
  case SOAP_TYPE_PointerTounsignedInt:
    return soap_in_PointerTounsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
  case SOAP_TYPE_PointerTo_ns3__Subscribe_SubscriptionPolicy:
    return soap_in_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, NULL, NULL, "ns3:Subscribe-SubscriptionPolicy");
  case SOAP_TYPE_PointerToPointerTons3__NotificationMessageHolderType:
    return soap_in_PointerToPointerTons3__NotificationMessageHolderType(soap, NULL, NULL, "ns3:NotificationMessageHolderType");
  case SOAP_TYPE_PointerTons3__NotificationMessageHolderType:
    return soap_in_PointerTons3__NotificationMessageHolderType(soap, NULL, NULL, "ns3:NotificationMessageHolderType");
  case SOAP_TYPE_PointerTotime:
    return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
  case SOAP_TYPE_PointerTons3__SubscriptionPolicyType:
    return soap_in_PointerTons3__SubscriptionPolicyType(soap, NULL, NULL, "ns3:SubscriptionPolicyType");
  case SOAP_TYPE_PointerTons3__FilterType:
    return soap_in_PointerTons3__FilterType(soap, NULL, NULL, "ns3:FilterType");
  case SOAP_TYPE_PointerTons3__MessageType:
    return soap_in_PointerTons3__MessageType(soap, NULL, NULL, "ns3:MessageType");
  case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
    return soap_in_PointerTowsa5__EndpointReferenceType(soap, NULL, NULL, "wsa5:EndpointReferenceType");
  case SOAP_TYPE_PointerToPointerTons3__QueryExpressionType:
    return soap_in_PointerToPointerTons3__QueryExpressionType(soap, NULL, NULL, "ns3:QueryExpressionType");
  case SOAP_TYPE_PointerTons3__QueryExpressionType:
    return soap_in_PointerTons3__QueryExpressionType(soap, NULL, NULL, "ns3:QueryExpressionType");
  case SOAP_TYPE_PointerToPointerTons3__TopicExpressionType:
    return soap_in_PointerToPointerTons3__TopicExpressionType(soap, NULL, NULL, "ns3:TopicExpressionType");
  case SOAP_TYPE_PointerTons3__TopicExpressionType:
    return soap_in_PointerTons3__TopicExpressionType(soap, NULL, NULL, "ns3:TopicExpressionType");
  case SOAP_TYPE_PointerTons1__pathInfo:
    return soap_in_PointerTons1__pathInfo(soap, NULL, NULL, "ns1:pathInfo");
  case SOAP_TYPE_PointerTons1__optionalConstraintValue:
    return soap_in_PointerTons1__optionalConstraintValue(soap, NULL, NULL, "ns1:optionalConstraintValue");
  case SOAP_TYPE_PointerTons1__localDetails:
    return soap_in_PointerTons1__localDetails(soap, NULL, NULL, "ns1:localDetails");
  case SOAP_TYPE_PointerTons1__mplsInfo:
    return soap_in_PointerTons1__mplsInfo(soap, NULL, NULL, "ns1:mplsInfo");
  case SOAP_TYPE_PointerTons1__layer3Info:
    return soap_in_PointerTons1__layer3Info(soap, NULL, NULL, "ns1:layer3Info");
  case SOAP_TYPE_PointerTons1__layer2Info:
    return soap_in_PointerTons1__layer2Info(soap, NULL, NULL, "ns1:layer2Info");
  case SOAP_TYPE_PointerTons5__CtrlPlanePathContent:
    return soap_in_PointerTons5__CtrlPlanePathContent(soap, NULL, NULL, "ns5:CtrlPlanePathContent");
  case SOAP_TYPE_PointerToPointerTons1__resDetails:
    return soap_in_PointerToPointerTons1__resDetails(soap, NULL, NULL, "ns1:resDetails");
  case SOAP_TYPE_PointerToPointerTons1__vlanTag:
    return soap_in_PointerToPointerTons1__vlanTag(soap, NULL, NULL, "ns1:vlanTag");
  case SOAP_TYPE_PointerTons1__vlanTag:
    return soap_in_PointerTons1__vlanTag(soap, NULL, NULL, "ns1:vlanTag");
  case SOAP_TYPE_PointerTostring:
    return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
  case SOAP_TYPE_PointerTons5__CtrlPlaneTopologyContent:
    return soap_in_PointerTons5__CtrlPlaneTopologyContent(soap, NULL, NULL, "ns5:CtrlPlaneTopologyContent");
  case SOAP_TYPE_PointerTons1__resDetails:
    return soap_in_PointerTons1__resDetails(soap, NULL, NULL, "ns1:resDetails");
  case SOAP_TYPE_PointerToPointerTons1__optionalConstraintType:
    return soap_in_PointerToPointerTons1__optionalConstraintType(soap, NULL, NULL, "ns1:optionalConstraintType");
  case SOAP_TYPE_PointerTons1__optionalConstraintType:
    return soap_in_PointerTons1__optionalConstraintType(soap, NULL, NULL, "ns1:optionalConstraintType");
  case SOAP_TYPE_PointerTons1__reservedConstraintType:
    return soap_in_PointerTons1__reservedConstraintType(soap, NULL, NULL, "ns1:reservedConstraintType");
  case SOAP_TYPE_PointerTons1__userRequestConstraintType:
    return soap_in_PointerTons1__userRequestConstraintType(soap, NULL, NULL, "ns1:userRequestConstraintType");
  case SOAP_TYPE_PointerTons6__messagePropertiesType:
    return soap_in_PointerTons6__messagePropertiesType(soap, NULL, NULL, "ns6:messagePropertiesType");
  case SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType: {
    char **s;
    s = soap_in_ns3__AbsoluteOrRelativeTimeType(soap, NULL, NULL, "ns3:AbsoluteOrRelativeTimeType");
    return s ? *s : NULL;
  }
  case SOAP_TYPE_PointerTo_wsse__Security:
    return soap_in_PointerTo_wsse__Security(soap, NULL, NULL, "wsse:Security");
  case SOAP_TYPE_PointerTods__SignatureType:
    return soap_in_PointerTods__SignatureType(soap, NULL, NULL, "ds:SignatureType");
  case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
    return soap_in_PointerToxenc__EncryptedKeyType(soap, NULL, NULL, "xenc:EncryptedKeyType");
  case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
    return soap_in_PointerTo_wsse__BinarySecurityToken(soap, NULL, NULL, "wsse:BinarySecurityToken");
  case SOAP_TYPE_PointerTo_wsse__UsernameToken:
    return soap_in_PointerTo_wsse__UsernameToken(soap, NULL, NULL, "wsse:UsernameToken");
  case SOAP_TYPE_PointerTo_wsu__Timestamp:
    return soap_in_PointerTo_wsu__Timestamp(soap, NULL, NULL, "wsu:Timestamp");
  case SOAP_TYPE_PointerTo_wsse__Embedded:
    return soap_in_PointerTo_wsse__Embedded(soap, NULL, NULL, "wsse:Embedded");
  case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
    return soap_in_PointerTo_wsse__KeyIdentifier(soap, NULL, NULL, "wsse:KeyIdentifier");
  case SOAP_TYPE_PointerTo_wsse__Reference:
    return soap_in_PointerTo_wsse__Reference(soap, NULL, NULL, "wsse:Reference");
  case SOAP_TYPE_PointerTo_wsse__Password:
    return soap_in_PointerTo_wsse__Password(soap, NULL, NULL, "wsse:Password");
  case SOAP_TYPE_PointerTo_wsa5__FaultTo:
    return soap_in_PointerTo_wsa5__FaultTo(soap, NULL, NULL, "wsa5:FaultTo");
  case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
    return soap_in_PointerTo_wsa5__ReplyTo(soap, NULL, NULL, "wsa5:ReplyTo");
  case SOAP_TYPE_PointerTo_wsa5__From:
    return soap_in_PointerTo_wsa5__From(soap, NULL, NULL, "wsa5:From");
  case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
    return soap_in_PointerTo_wsa5__RelatesTo(soap, NULL, NULL, "wsa5:RelatesTo");
  case SOAP_TYPE__wsa5__ProblemHeaderQName: {
    char **s;
    s = soap_in__wsa5__ProblemHeaderQName(soap, NULL, NULL, "xsd:QName");
    return s ? *s : NULL;
  }
  case SOAP_TYPE_PointerTowsa5__MetadataType:
    return soap_in_PointerTowsa5__MetadataType(soap, NULL, NULL, "wsa5:MetadataType");
  case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
    return soap_in_PointerTowsa5__ReferenceParametersType(soap, NULL, NULL, "wsa5:ReferenceParametersType");
  case SOAP_TYPE_wsa5__FaultCodesOpenEnumType: {
    char **s;
    s = soap_in_wsa5__FaultCodesOpenEnumType(soap, NULL, NULL, "wsa5:FaultCodesOpenEnumType");
    return s ? *s : NULL;
  }
  case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum: {
    char **s;
    s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, NULL, NULL, "wsa5:RelationshipTypeOpenEnum");
    return s ? *s : NULL;
  }
  case SOAP_TYPE_PointerTo_xenc__ReferenceList:
    return soap_in_PointerTo_xenc__ReferenceList(soap, NULL, NULL, "xenc:ReferenceList");
  case SOAP_TYPE_PointerToxenc__ReferenceType:
    return soap_in_PointerToxenc__ReferenceType(soap, NULL, NULL, "xenc:ReferenceType");
  case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
    return soap_in_PointerToxenc__EncryptionPropertyType(soap, NULL, NULL, "xenc:EncryptionPropertyType");
  case SOAP_TYPE_PointerToxenc__TransformsType:
    return soap_in_PointerToxenc__TransformsType(soap, NULL, NULL, "xenc:TransformsType");
  case SOAP_TYPE_PointerToxenc__CipherReferenceType:
    return soap_in_PointerToxenc__CipherReferenceType(soap, NULL, NULL, "xenc:CipherReferenceType");
  case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
    return soap_in_PointerToxenc__EncryptionPropertiesType(soap, NULL, NULL, "xenc:EncryptionPropertiesType");
  case SOAP_TYPE_PointerToxenc__CipherDataType:
    return soap_in_PointerToxenc__CipherDataType(soap, NULL, NULL, "xenc:CipherDataType");
  case SOAP_TYPE_PointerTo_ds__KeyInfo:
    return soap_in_PointerTo_ds__KeyInfo(soap, NULL, NULL, "ds:KeyInfo");
  case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
    return soap_in_PointerToxenc__EncryptionMethodType(soap, NULL, NULL, "xenc:EncryptionMethodType");
  case SOAP_TYPE_PointerTods__X509IssuerSerialType:
    return soap_in_PointerTods__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
  case SOAP_TYPE_PointerTods__RSAKeyValueType:
    return soap_in_PointerTods__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
  case SOAP_TYPE_PointerTods__DSAKeyValueType:
    return soap_in_PointerTods__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
  case SOAP_TYPE_PointerTods__TransformType:
    return soap_in_PointerTods__TransformType(soap, NULL, NULL, "ds:TransformType");
  case SOAP_TYPE_PointerTods__DigestMethodType:
    return soap_in_PointerTods__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
  case SOAP_TYPE_PointerTods__TransformsType:
    return soap_in_PointerTods__TransformsType(soap, NULL, NULL, "ds:TransformsType");
  case SOAP_TYPE_PointerToint:
    return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
  case SOAP_TYPE_PointerToPointerTods__ReferenceType:
    return soap_in_PointerToPointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
  case SOAP_TYPE_PointerTods__ReferenceType:
    return soap_in_PointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
  case SOAP_TYPE_PointerTods__SignatureMethodType:
    return soap_in_PointerTods__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
  case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
    return soap_in_PointerTods__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
  case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
    return soap_in_PointerTo_wsse__SecurityTokenReference(soap, NULL, NULL, "wsse:SecurityTokenReference");
  case SOAP_TYPE_PointerTods__X509DataType:
    return soap_in_PointerTods__X509DataType(soap, NULL, NULL, "ds:X509DataType");
  case SOAP_TYPE_PointerTods__RetrievalMethodType:
    return soap_in_PointerTods__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
  case SOAP_TYPE_PointerTods__KeyValueType:
    return soap_in_PointerTods__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
  case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
    return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, NULL, NULL, "c14n:InclusiveNamespaces");
  case SOAP_TYPE_PointerTods__KeyInfoType:
    return soap_in_PointerTods__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
  case SOAP_TYPE_PointerTods__SignedInfoType:
    return soap_in_PointerTods__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
  case SOAP_TYPE__QName: {
    char **s;
    s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
    return s ? *s : NULL;
  }
  case SOAP_TYPE_string: {
    char **s;
    s = soap_in_string(soap, NULL, NULL, "xsd:string");
    return s ? *s : NULL;
  }
  default: {
    const char *t = soap->type;
    if (!*t)
      t = soap->tag;
    if (!soap_match_tag(soap, t, "xsd:byte")) {
      *type = SOAP_TYPE_byte;
      return soap_in_byte(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:int")) {
      *type = SOAP_TYPE_int;
      return soap_in_int(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:long")) {
      *type = SOAP_TYPE_LONG64;
      return soap_in_LONG64(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:unsignedInt")) {
      *type = SOAP_TYPE_unsignedInt;
      return soap_in_unsignedInt(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:unsignedLong")) {
      *type = SOAP_TYPE_unsignedLONG64;
      return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:dateTime")) {
      *type = SOAP_TYPE_time;
      return soap_in_time(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:DecisionType")) {
      *type = SOAP_TYPE_ns8__DecisionType;
      return soap_in_ns8__DecisionType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xsd:boolean")) {
      *type = SOAP_TYPE_xsd__boolean_;
      return soap_in_xsd__boolean_(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum")) {
      *type = SOAP_TYPE_wsse__FaultcodeEnum;
      return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsu:tTimestampFault")) {
      *type = SOAP_TYPE_wsu__tTimestampFault;
      return soap_in_wsu__tTimestampFault(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter")) {
      *type = SOAP_TYPE__wsa5__IsReferenceParameter;
      return soap_in__wsa5__IsReferenceParameter(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:FaultCodesType")) {
      *type = SOAP_TYPE_wsa5__FaultCodesType;
      return soap_in_wsa5__FaultCodesType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:RelationshipType")) {
      *type = SOAP_TYPE_wsa5__RelationshipType;
      return soap_in_wsa5__RelationshipType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:KeyInfoConfirmationDataType")) {
      *type = SOAP_TYPE_ns8__KeyInfoConfirmationDataType;
      return soap_in_ns8__KeyInfoConfirmationDataType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:ActionType")) {
      *type = SOAP_TYPE_ns8__ActionType;
      return soap_in_ns8__ActionType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns4:ResourceUnavailableFaultType")) {
      *type = SOAP_TYPE_ns4__ResourceUnavailableFaultType;
      return soap_in_ns4__ResourceUnavailableFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns4:ResourceUnknownFaultType")) {
      *type = SOAP_TYPE_ns4__ResourceUnknownFaultType;
      return soap_in_ns4__ResourceUnknownFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:ResumeFailedFaultType")) {
      *type = SOAP_TYPE_ns3__ResumeFailedFaultType;
      return soap_in_ns3__ResumeFailedFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:PauseFailedFaultType")) {
      *type = SOAP_TYPE_ns3__PauseFailedFaultType;
      return soap_in_ns3__PauseFailedFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:UnableToDestroySubscriptionFaultType")) {
      *type = SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType;
      return soap_in_ns3__UnableToDestroySubscriptionFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:UnacceptableTerminationTimeFaultType")) {
      *type = SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType;
      return soap_in_ns3__UnacceptableTerminationTimeFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:UnableToCreatePullPointFaultType")) {
      *type = SOAP_TYPE_ns3__UnableToCreatePullPointFaultType;
      return soap_in_ns3__UnableToCreatePullPointFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:UnableToDestroyPullPointFaultType")) {
      *type = SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType;
      return soap_in_ns3__UnableToDestroyPullPointFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:UnableToGetMessagesFaultType")) {
      *type = SOAP_TYPE_ns3__UnableToGetMessagesFaultType;
      return soap_in_ns3__UnableToGetMessagesFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:NoCurrentMessageOnTopicFaultType")) {
      *type = SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType;
      return soap_in_ns3__NoCurrentMessageOnTopicFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:UnacceptableInitialTerminationTimeFaultType")) {
      *type = SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType;
      return soap_in_ns3__UnacceptableInitialTerminationTimeFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:NotifyMessageNotSupportedFaultType")) {
      *type = SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType;
      return soap_in_ns3__NotifyMessageNotSupportedFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:UnsupportedPolicyRequestFaultType")) {
      *type = SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType;
      return soap_in_ns3__UnsupportedPolicyRequestFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:UnrecognizedPolicyRequestFaultType")) {
      *type = SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType;
      return soap_in_ns3__UnrecognizedPolicyRequestFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:InvalidMessageContentExpressionFaultType")) {
      *type = SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType;
      return soap_in_ns3__InvalidMessageContentExpressionFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:InvalidProducerPropertiesExpressionFaultType")) {
      *type = SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType;
      return soap_in_ns3__InvalidProducerPropertiesExpressionFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:MultipleTopicsSpecifiedFaultType")) {
      *type = SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType;
      return soap_in_ns3__MultipleTopicsSpecifiedFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:TopicNotSupportedFaultType")) {
      *type = SOAP_TYPE_ns3__TopicNotSupportedFaultType;
      return soap_in_ns3__TopicNotSupportedFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:InvalidTopicExpressionFaultType")) {
      *type = SOAP_TYPE_ns3__InvalidTopicExpressionFaultType;
      return soap_in_ns3__InvalidTopicExpressionFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:TopicExpressionDialectUnknownFaultType")) {
      *type = SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType;
      return soap_in_ns3__TopicExpressionDialectUnknownFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:InvalidFilterFaultType")) {
      *type = SOAP_TYPE_ns3__InvalidFilterFaultType;
      return soap_in_ns3__InvalidFilterFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:SubscribeCreationFailedFaultType")) {
      *type = SOAP_TYPE_ns3__SubscribeCreationFailedFaultType;
      return soap_in_ns3__SubscribeCreationFailedFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:reservationResourceType")) {
      *type = SOAP_TYPE_ns1__reservationResourceType;
      return soap_in_ns1__reservationResourceType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:EvidenceType")) {
      *type = SOAP_TYPE_ns8__EvidenceType;
      return soap_in_ns8__EvidenceType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:AuthnContextType")) {
      *type = SOAP_TYPE_ns8__AuthnContextType;
      return soap_in_ns8__AuthnContextType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:SubjectLocalityType")) {
      *type = SOAP_TYPE_ns8__SubjectLocalityType;
      return soap_in_ns8__SubjectLocalityType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:ProxyRestrictionType")) {
      *type = SOAP_TYPE_ns8__ProxyRestrictionType;
      return soap_in_ns8__ProxyRestrictionType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:OneTimeUseType")) {
      *type = SOAP_TYPE_ns8__OneTimeUseType;
      return soap_in_ns8__OneTimeUseType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:AudienceRestrictionType")) {
      *type = SOAP_TYPE_ns8__AudienceRestrictionType;
      return soap_in_ns8__AudienceRestrictionType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:ConditionAbstractType")) {
      *type = SOAP_TYPE_ns8__ConditionAbstractType;
      return soap_in_ns8__ConditionAbstractType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:SubjectConfirmationDataType")) {
      *type = SOAP_TYPE_ns8__SubjectConfirmationDataType;
      return soap_in_ns8__SubjectConfirmationDataType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:SubjectConfirmationType")) {
      *type = SOAP_TYPE_ns8__SubjectConfirmationType;
      return soap_in_ns8__SubjectConfirmationType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:AttributeStatementType")) {
      *type = SOAP_TYPE_ns8__AttributeStatementType;
      return soap_in_ns8__AttributeStatementType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:AuthzDecisionStatementType")) {
      *type = SOAP_TYPE_ns8__AuthzDecisionStatementType;
      return soap_in_ns8__AuthzDecisionStatementType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:AuthnStatementType")) {
      *type = SOAP_TYPE_ns8__AuthnStatementType;
      return soap_in_ns8__AuthnStatementType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:StatementAbstractType")) {
      *type = SOAP_TYPE_ns8__StatementAbstractType;
      return soap_in_ns8__StatementAbstractType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:AdviceType")) {
      *type = SOAP_TYPE_ns8__AdviceType;
      return soap_in_ns8__AdviceType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:ConditionsType")) {
      *type = SOAP_TYPE_ns8__ConditionsType;
      return soap_in_ns8__ConditionsType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:SubjectType")) {
      *type = SOAP_TYPE_ns8__SubjectType;
      return soap_in_ns8__SubjectType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:NameIDType")) {
      *type = SOAP_TYPE_ns8__NameIDType;
      return soap_in_ns8__NameIDType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:AssertionType")) {
      *type = SOAP_TYPE_ns8__AssertionType;
      return soap_in_ns8__AssertionType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:EncryptedElementType")) {
      *type = SOAP_TYPE_ns8__EncryptedElementType;
      return soap_in_ns8__EncryptedElementType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:BaseIDAbstractType")) {
      *type = SOAP_TYPE_ns8__BaseIDAbstractType;
      return soap_in_ns8__BaseIDAbstractType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns7:FaultCauseType")) {
      *type = SOAP_TYPE_ns7__FaultCauseType;
      return soap_in_ns7__FaultCauseType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns7:ErrorCodeType")) {
      *type = SOAP_TYPE_ns7__ErrorCodeType;
      return soap_in_ns7__ErrorCodeType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns7:BaseFaultType")) {
      *type = SOAP_TYPE_ns7__BaseFaultType;
      return soap_in_ns7__BaseFaultType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns6:authConditionType")) {
      *type = SOAP_TYPE_ns6__authConditionType;
      return soap_in_ns6__authConditionType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns6:authConditions")) {
      *type = SOAP_TYPE_ns6__authConditions;
      return soap_in_ns6__authConditions(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns8:AttributeType")) {
      *type = SOAP_TYPE_ns8__AttributeType;
      return soap_in_ns8__AttributeType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns6:subjectAttributes")) {
      *type = SOAP_TYPE_ns6__subjectAttributes;
      return soap_in_ns6__subjectAttributes(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlaneSwitchingCapabilitySpecificInfo")) {
      *type = SOAP_TYPE_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo;
      return soap_in_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:Duration")) {
      *type = SOAP_TYPE_ns5__Duration;
      return soap_in_ns5__Duration(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:TimeContent")) {
      *type = SOAP_TYPE_ns5__TimeContent;
      return soap_in_ns5__TimeContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlaneNextHopContent")) {
      *type = SOAP_TYPE_ns5__CtrlPlaneNextHopContent;
      return soap_in_ns5__CtrlPlaneNextHopContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlaneHopContent")) {
      *type = SOAP_TYPE_ns5__CtrlPlaneHopContent;
      return soap_in_ns5__CtrlPlaneHopContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlaneSwcapContent")) {
      *type = SOAP_TYPE_ns5__CtrlPlaneSwcapContent;
      return soap_in_ns5__CtrlPlaneSwcapContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlaneAdministrativeGroup")) {
      *type = SOAP_TYPE_ns5__CtrlPlaneAdministrativeGroup;
      return soap_in_ns5__CtrlPlaneAdministrativeGroup(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlaneAddressContent")) {
      *type = SOAP_TYPE_ns5__CtrlPlaneAddressContent;
      return soap_in_ns5__CtrlPlaneAddressContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlaneLinkContent")) {
      *type = SOAP_TYPE_ns5__CtrlPlaneLinkContent;
      return soap_in_ns5__CtrlPlaneLinkContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlanePortContent")) {
      *type = SOAP_TYPE_ns5__CtrlPlanePortContent;
      return soap_in_ns5__CtrlPlanePortContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlaneNodeContent")) {
      *type = SOAP_TYPE_ns5__CtrlPlaneNodeContent;
      return soap_in_ns5__CtrlPlaneNodeContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:Lifetime")) {
      *type = SOAP_TYPE_ns5__Lifetime;
      return soap_in_ns5__Lifetime(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlaneDomainSignatureContent")) {
      *type = SOAP_TYPE_ns5__CtrlPlaneDomainSignatureContent;
      return soap_in_ns5__CtrlPlaneDomainSignatureContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlaneDomainContent")) {
      *type = SOAP_TYPE_ns5__CtrlPlaneDomainContent;
      return soap_in_ns5__CtrlPlaneDomainContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:MessageType")) {
      *type = SOAP_TYPE_ns3__MessageType;
      return soap_in_ns3__MessageType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:NotificationMessageHolderType")) {
      *type = SOAP_TYPE_ns3__NotificationMessageHolderType;
      return soap_in_ns3__NotificationMessageHolderType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:SubscriptionPolicyType")) {
      *type = SOAP_TYPE_ns3__SubscriptionPolicyType;
      return soap_in_ns3__SubscriptionPolicyType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:QueryExpressionType")) {
      *type = SOAP_TYPE_ns3__QueryExpressionType;
      return soap_in_ns3__QueryExpressionType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:TopicExpressionType")) {
      *type = SOAP_TYPE_ns3__TopicExpressionType;
      return soap_in_ns3__TopicExpressionType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:FilterType")) {
      *type = SOAP_TYPE_ns3__FilterType;
      return soap_in_ns3__FilterType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns2:emptyArg")) {
      *type = SOAP_TYPE_ns2__emptyArg;
      return soap_in_ns2__emptyArg(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:optionalConstraintValue")) {
      *type = SOAP_TYPE_ns1__optionalConstraintValue;
      return soap_in_ns1__optionalConstraintValue(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:globalReservationId")) {
      *type = SOAP_TYPE_ns1__globalReservationId;
      return soap_in_ns1__globalReservationId(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:localDetails")) {
      *type = SOAP_TYPE_ns1__localDetails;
      return soap_in_ns1__localDetails(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:eventContent")) {
      *type = SOAP_TYPE_ns1__eventContent;
      return soap_in_ns1__eventContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:interDomainEventContent")) {
      *type = SOAP_TYPE_ns1__interDomainEventContent;
      return soap_in_ns1__interDomainEventContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:mplsInfo")) {
      *type = SOAP_TYPE_ns1__mplsInfo;
      return soap_in_ns1__mplsInfo(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:layer3Info")) {
      *type = SOAP_TYPE_ns1__layer3Info;
      return soap_in_ns1__layer3Info(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:layer2Info")) {
      *type = SOAP_TYPE_ns1__layer2Info;
      return soap_in_ns1__layer2Info(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlanePathContent")) {
      *type = SOAP_TYPE_ns5__CtrlPlanePathContent;
      return soap_in_ns5__CtrlPlanePathContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:pathInfo")) {
      *type = SOAP_TYPE_ns1__pathInfo;
      return soap_in_ns1__pathInfo(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:listReply")) {
      *type = SOAP_TYPE_ns1__listReply;
      return soap_in_ns1__listReply(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:vlanTag")) {
      *type = SOAP_TYPE_ns1__vlanTag;
      return soap_in_ns1__vlanTag(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:listRequest")) {
      *type = SOAP_TYPE_ns1__listRequest;
      return soap_in_ns1__listRequest(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:teardownPathResponseContent")) {
      *type = SOAP_TYPE_ns1__teardownPathResponseContent;
      return soap_in_ns1__teardownPathResponseContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:teardownPathContent")) {
      *type = SOAP_TYPE_ns1__teardownPathContent;
      return soap_in_ns1__teardownPathContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:refreshPathResponseContent")) {
      *type = SOAP_TYPE_ns1__refreshPathResponseContent;
      return soap_in_ns1__refreshPathResponseContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:refreshPathContent")) {
      *type = SOAP_TYPE_ns1__refreshPathContent;
      return soap_in_ns1__refreshPathContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:createPathResponseContent")) {
      *type = SOAP_TYPE_ns1__createPathResponseContent;
      return soap_in_ns1__createPathResponseContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:createPathContent")) {
      *type = SOAP_TYPE_ns1__createPathContent;
      return soap_in_ns1__createPathContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns5:CtrlPlaneTopologyContent")) {
      *type = SOAP_TYPE_ns5__CtrlPlaneTopologyContent;
      return soap_in_ns5__CtrlPlaneTopologyContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:getTopologyResponseContent")) {
      *type = SOAP_TYPE_ns1__getTopologyResponseContent;
      return soap_in_ns1__getTopologyResponseContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:getTopologyContent")) {
      *type = SOAP_TYPE_ns1__getTopologyContent;
      return soap_in_ns1__getTopologyContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:modifyResReply")) {
      *type = SOAP_TYPE_ns1__modifyResReply;
      return soap_in_ns1__modifyResReply(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:modifyResContent")) {
      *type = SOAP_TYPE_ns1__modifyResContent;
      return soap_in_ns1__modifyResContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:resDetails")) {
      *type = SOAP_TYPE_ns1__resDetails;
      return soap_in_ns1__resDetails(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:queryResReply")) {
      *type = SOAP_TYPE_ns1__queryResReply;
      return soap_in_ns1__queryResReply(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:queryResContent")) {
      *type = SOAP_TYPE_ns1__queryResContent;
      return soap_in_ns1__queryResContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:cancelResReply")) {
      *type = SOAP_TYPE_ns1__cancelResReply;
      return soap_in_ns1__cancelResReply(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:cancelResContent")) {
      *type = SOAP_TYPE_ns1__cancelResContent;
      return soap_in_ns1__cancelResContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:createReply")) {
      *type = SOAP_TYPE_ns1__createReply;
      return soap_in_ns1__createReply(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:optionalConstraintType")) {
      *type = SOAP_TYPE_ns1__optionalConstraintType;
      return soap_in_ns1__optionalConstraintType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:reservedConstraintType")) {
      *type = SOAP_TYPE_ns1__reservedConstraintType;
      return soap_in_ns1__reservedConstraintType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:userRequestConstraintType")) {
      *type = SOAP_TYPE_ns1__userRequestConstraintType;
      return soap_in_ns1__userRequestConstraintType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns6:messagePropertiesType")) {
      *type = SOAP_TYPE_ns6__messagePropertiesType;
      return soap_in_ns6__messagePropertiesType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns1:resCreateContent")) {
      *type = SOAP_TYPE_ns1__resCreateContent;
      return soap_in_ns1__resCreateContent(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:ProblemActionType")) {
      *type = SOAP_TYPE_wsa5__ProblemActionType;
      return soap_in_wsa5__ProblemActionType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:RelatesToType")) {
      *type = SOAP_TYPE_wsa5__RelatesToType;
      return soap_in_wsa5__RelatesToType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:MetadataType")) {
      *type = SOAP_TYPE_wsa5__MetadataType;
      return soap_in_wsa5__MetadataType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType")) {
      *type = SOAP_TYPE_wsa5__ReferenceParametersType;
      return soap_in_wsa5__ReferenceParametersType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType")) {
      *type = SOAP_TYPE_wsa5__EndpointReferenceType;
      return soap_in_wsa5__EndpointReferenceType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:EncryptionPropertyType")) {
      *type = SOAP_TYPE_xenc__EncryptionPropertyType;
      return soap_in_xenc__EncryptionPropertyType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:EncryptionPropertiesType")) {
      *type = SOAP_TYPE_xenc__EncryptionPropertiesType;
      return soap_in_xenc__EncryptionPropertiesType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:ReferenceType")) {
      *type = SOAP_TYPE_xenc__ReferenceType;
      return soap_in_xenc__ReferenceType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:AgreementMethodType")) {
      *type = SOAP_TYPE_xenc__AgreementMethodType;
      return soap_in_xenc__AgreementMethodType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:EncryptedKeyType")) {
      *type = SOAP_TYPE_xenc__EncryptedKeyType;
      return soap_in_xenc__EncryptedKeyType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:EncryptedDataType")) {
      *type = SOAP_TYPE_xenc__EncryptedDataType;
      return soap_in_xenc__EncryptedDataType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:TransformsType")) {
      *type = SOAP_TYPE_xenc__TransformsType;
      return soap_in_xenc__TransformsType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:CipherReferenceType")) {
      *type = SOAP_TYPE_xenc__CipherReferenceType;
      return soap_in_xenc__CipherReferenceType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:CipherDataType")) {
      *type = SOAP_TYPE_xenc__CipherDataType;
      return soap_in_xenc__CipherDataType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:EncryptionMethodType")) {
      *type = SOAP_TYPE_xenc__EncryptionMethodType;
      return soap_in_xenc__EncryptionMethodType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:EncryptedType")) {
      *type = SOAP_TYPE_xenc__EncryptedType;
      return soap_in_xenc__EncryptedType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:RSAKeyValueType")) {
      *type = SOAP_TYPE_ds__RSAKeyValueType;
      return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:DSAKeyValueType")) {
      *type = SOAP_TYPE_ds__DSAKeyValueType;
      return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType")) {
      *type = SOAP_TYPE_ds__X509IssuerSerialType;
      return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:X509DataType")) {
      *type = SOAP_TYPE_ds__X509DataType;
      return soap_in_ds__X509DataType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:RetrievalMethodType")) {
      *type = SOAP_TYPE_ds__RetrievalMethodType;
      return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:KeyValueType")) {
      *type = SOAP_TYPE_ds__KeyValueType;
      return soap_in_ds__KeyValueType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:DigestMethodType")) {
      *type = SOAP_TYPE_ds__DigestMethodType;
      return soap_in_ds__DigestMethodType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:TransformType")) {
      *type = SOAP_TYPE_ds__TransformType;
      return soap_in_ds__TransformType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:TransformsType")) {
      *type = SOAP_TYPE_ds__TransformsType;
      return soap_in_ds__TransformsType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:ReferenceType")) {
      *type = SOAP_TYPE_ds__ReferenceType;
      return soap_in_ds__ReferenceType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:SignatureMethodType")) {
      *type = SOAP_TYPE_ds__SignatureMethodType;
      return soap_in_ds__SignatureMethodType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType")) {
      *type = SOAP_TYPE_ds__CanonicalizationMethodType;
      return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:KeyInfoType")) {
      *type = SOAP_TYPE_ds__KeyInfoType;
      return soap_in_ds__KeyInfoType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:SignedInfoType")) {
      *type = SOAP_TYPE_ds__SignedInfoType;
      return soap_in_ds__SignedInfoType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:SignatureType")) {
      *type = SOAP_TYPE_ds__SignatureType;
      return soap_in_ds__SignatureType(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:AbsoluteOrRelativeTimeType")) {
      char **s;
      *type = SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType;
      s = soap_in_ns3__AbsoluteOrRelativeTimeType(soap, NULL, NULL, NULL);
      return s ? *s : NULL;
    }
    if (!soap_match_tag(soap, t, "xsd:QName")) {
      char **s;
      *type = SOAP_TYPE__wsa5__ProblemHeaderQName;
      s = soap_in__wsa5__ProblemHeaderQName(soap, NULL, NULL, NULL);
      return s ? *s : NULL;
    }
    if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType")) {
      char **s;
      *type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
      s = soap_in_wsa5__FaultCodesOpenEnumType(soap, NULL, NULL, NULL);
      return s ? *s : NULL;
    }
    if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum")) {
      char **s;
      *type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
      s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, NULL, NULL, NULL);
      return s ? *s : NULL;
    }
    if (!soap_match_tag(soap, t, "xsd:QName")) {
      char **s;
      *type = SOAP_TYPE__QName;
      s = soap_in__QName(soap, NULL, NULL, NULL);
      return s ? *s : NULL;
    }
    if (!soap_match_tag(soap, t, "xsd:string")) {
      char **s;
      *type = SOAP_TYPE_string;
      s = soap_in_string(soap, NULL, NULL, NULL);
      return s ? *s : NULL;
    }
    t = soap->tag;
    if (!soap_match_tag(soap, t, "wsa5:RetryAfter")) {
      *type = SOAP_TYPE__wsa5__RetryAfter;
      return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:ResumeSubscriptionResponse")) {
      *type = SOAP_TYPE__ns3__ResumeSubscriptionResponse;
      return soap_in__ns3__ResumeSubscriptionResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:ResumeSubscription")) {
      *type = SOAP_TYPE__ns3__ResumeSubscription;
      return soap_in__ns3__ResumeSubscription(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:PauseSubscriptionResponse")) {
      *type = SOAP_TYPE__ns3__PauseSubscriptionResponse;
      return soap_in__ns3__PauseSubscriptionResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:PauseSubscription")) {
      *type = SOAP_TYPE__ns3__PauseSubscription;
      return soap_in__ns3__PauseSubscription(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:UnsubscribeResponse")) {
      *type = SOAP_TYPE__ns3__UnsubscribeResponse;
      return soap_in__ns3__UnsubscribeResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:Unsubscribe")) {
      *type = SOAP_TYPE__ns3__Unsubscribe;
      return soap_in__ns3__Unsubscribe(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:RenewResponse")) {
      *type = SOAP_TYPE__ns3__RenewResponse;
      return soap_in__ns3__RenewResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:Renew")) {
      *type = SOAP_TYPE__ns3__Renew;
      return soap_in__ns3__Renew(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:CreatePullPointResponse")) {
      *type = SOAP_TYPE__ns3__CreatePullPointResponse;
      return soap_in__ns3__CreatePullPointResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:CreatePullPoint")) {
      *type = SOAP_TYPE__ns3__CreatePullPoint;
      return soap_in__ns3__CreatePullPoint(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:DestroyPullPointResponse")) {
      *type = SOAP_TYPE__ns3__DestroyPullPointResponse;
      return soap_in__ns3__DestroyPullPointResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:DestroyPullPoint")) {
      *type = SOAP_TYPE__ns3__DestroyPullPoint;
      return soap_in__ns3__DestroyPullPoint(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:GetMessagesResponse")) {
      *type = SOAP_TYPE__ns3__GetMessagesResponse;
      return soap_in__ns3__GetMessagesResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:GetMessages")) {
      *type = SOAP_TYPE__ns3__GetMessages;
      return soap_in__ns3__GetMessages(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:GetCurrentMessageResponse")) {
      *type = SOAP_TYPE__ns3__GetCurrentMessageResponse;
      return soap_in__ns3__GetCurrentMessageResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:GetCurrentMessage")) {
      *type = SOAP_TYPE__ns3__GetCurrentMessage;
      return soap_in__ns3__GetCurrentMessage(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:SubscribeResponse")) {
      *type = SOAP_TYPE__ns3__SubscribeResponse;
      return soap_in__ns3__SubscribeResponse(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:Subscribe-SubscriptionPolicy")) {
      *type = SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy;
      return soap_in__ns3__Subscribe_SubscriptionPolicy(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:Subscribe")) {
      *type = SOAP_TYPE__ns3__Subscribe;
      return soap_in__ns3__Subscribe(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:UseRaw")) {
      *type = SOAP_TYPE__ns3__UseRaw;
      return soap_in__ns3__UseRaw(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:Notify")) {
      *type = SOAP_TYPE__ns3__Notify;
      return soap_in__ns3__Notify(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns3:SubscriptionManagerRP")) {
      *type = SOAP_TYPE__ns3__SubscriptionManagerRP;
      return soap_in__ns3__SubscriptionManagerRP(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ns2:OSCARSFault")) {
      *type = SOAP_TYPE__ns2__OSCARSFault;
      return soap_in__ns2__OSCARSFault(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsse:Security")) {
      *type = SOAP_TYPE__wsse__Security;
      return soap_in__wsse__Security(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsse:KeyIdentifier")) {
      *type = SOAP_TYPE__wsse__KeyIdentifier;
      return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsse:Embedded")) {
      *type = SOAP_TYPE__wsse__Embedded;
      return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsse:Reference")) {
      *type = SOAP_TYPE__wsse__Reference;
      return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken")) {
      *type = SOAP_TYPE__wsse__BinarySecurityToken;
      return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsse:Password")) {
      *type = SOAP_TYPE__wsse__Password;
      return soap_in__wsse__Password(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsse:UsernameToken")) {
      *type = SOAP_TYPE__wsse__UsernameToken;
      return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsu:Timestamp")) {
      *type = SOAP_TYPE__wsu__Timestamp;
      return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:ProblemAction")) {
      *type = SOAP_TYPE__wsa5__ProblemAction;
      return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:FaultTo")) {
      *type = SOAP_TYPE__wsa5__FaultTo;
      return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:From")) {
      *type = SOAP_TYPE__wsa5__From;
      return soap_in__wsa5__From(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:ReplyTo")) {
      *type = SOAP_TYPE__wsa5__ReplyTo;
      return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:RelatesTo")) {
      *type = SOAP_TYPE__wsa5__RelatesTo;
      return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:Metadata")) {
      *type = SOAP_TYPE__wsa5__Metadata;
      return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters")) {
      *type = SOAP_TYPE__wsa5__ReferenceParameters;
      return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:EndpointReference")) {
      *type = SOAP_TYPE__wsa5__EndpointReference;
      return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:EncryptionProperty")) {
      *type = SOAP_TYPE__xenc__EncryptionProperty;
      return soap_in__xenc__EncryptionProperty(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:EncryptionProperties")) {
      *type = SOAP_TYPE__xenc__EncryptionProperties;
      return soap_in__xenc__EncryptionProperties(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:AgreementMethod")) {
      *type = SOAP_TYPE__xenc__AgreementMethod;
      return soap_in__xenc__AgreementMethod(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:EncryptedKey")) {
      *type = SOAP_TYPE__xenc__EncryptedKey;
      return soap_in__xenc__EncryptedKey(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:EncryptedData")) {
      *type = SOAP_TYPE__xenc__EncryptedData;
      return soap_in__xenc__EncryptedData(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:CipherReference")) {
      *type = SOAP_TYPE__xenc__CipherReference;
      return soap_in__xenc__CipherReference(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:CipherData")) {
      *type = SOAP_TYPE__xenc__CipherData;
      return soap_in__xenc__CipherData(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "xenc:ReferenceList")) {
      *type = SOAP_TYPE__xenc__ReferenceList;
      return soap_in__xenc__ReferenceList(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:KeyInfo")) {
      *type = SOAP_TYPE__ds__KeyInfo;
      return soap_in__ds__KeyInfo(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference")) {
      *type = SOAP_TYPE__wsse__SecurityTokenReference;
      return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:Transform")) {
      *type = SOAP_TYPE__ds__Transform;
      return soap_in__ds__Transform(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces")) {
      *type = SOAP_TYPE__c14n__InclusiveNamespaces;
      return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "ds:Signature")) {
      *type = SOAP_TYPE__ds__Signature;
      return soap_in__ds__Signature(soap, NULL, NULL, NULL);
    }
    if (!soap_match_tag(soap, t, "wsa5:ProblemIRI")) {
      char **s;
      *type = SOAP_TYPE__wsa5__ProblemIRI;
      s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
      return s ? *s : NULL;
    }
    if (!soap_match_tag(soap, t, "wsa5:Action")) {
      char **s;
      *type = SOAP_TYPE__wsa5__Action;
      s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
      return s ? *s : NULL;
    }
    if (!soap_match_tag(soap, t, "wsa5:To")) {
      char **s;
      *type = SOAP_TYPE__wsa5__To;
      s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
      return s ? *s : NULL;
    }
    if (!soap_match_tag(soap, t, "wsa5:MessageID")) {
      char **s;
      *type = SOAP_TYPE__wsa5__MessageID;
      s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
      return s ? *s : NULL;
    }
  }
  }
  soap->error = SOAP_TAG_MISMATCH;
  return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap) {
  if (!soap_peek_element(soap)) {
    int t;
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
    if (soap->mustUnderstand && !soap->other)
      return soap->error = SOAP_MUSTUNDERSTAND;
    if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:")) {
      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
      return soap->error = SOAP_TAG_MISMATCH;
    }
    if (!*soap->id || !soap_getelement(soap, &t)) {
      soap->peeked = 0;
      if (soap->fignore)
        soap->error = soap->fignore(soap, soap->tag);
      else
        soap->error = SOAP_OK;
      DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
      if (!soap->error && soap->body) {
        soap->level++;
        while (!soap_ignore_element(soap))
          ;
        if (soap->error == SOAP_NO_TAG)
          soap->error = soap_element_end_in(soap, NULL);
      }
    }
  }
  return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap) {
  int i;
  struct soap_plist *pp;
  if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
    for (i = 0; i < SOAP_PTRHASH; i++)
      for (pp = soap->pht[i]; pp; pp = pp->next)
        if (pp->mark1 == 2 || pp->mark2 == 2)
          if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
            return soap->error;
  return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type) {
  switch (type) {
  case SOAP_TYPE_byte:
    return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
  case SOAP_TYPE_int:
    return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
  case SOAP_TYPE_LONG64:
    return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
  case SOAP_TYPE_unsignedInt:
    return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
  case SOAP_TYPE__wsa5__RetryAfter:
    return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, NULL);
  case SOAP_TYPE_unsignedLONG64:
    return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
  case SOAP_TYPE_time:
    return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
  case SOAP_TYPE_ns8__DecisionType:
    return soap_out_ns8__DecisionType(soap, tag, id, (const enum ns8__DecisionType *)ptr, "ns8:DecisionType");
  case SOAP_TYPE_xsd__boolean_:
    return soap_out_xsd__boolean_(soap, tag, id, (const enum xsd__boolean_ *)ptr, "xsd:boolean");
  case SOAP_TYPE_wsse__FaultcodeEnum:
    return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
  case SOAP_TYPE_wsu__tTimestampFault:
    return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
  case SOAP_TYPE__wsa5__IsReferenceParameter:
    return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
  case SOAP_TYPE_wsa5__FaultCodesType:
    return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
  case SOAP_TYPE_wsa5__RelationshipType:
    return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
  case SOAP_TYPE_ns8__KeyInfoConfirmationDataType:
    return soap_out_ns8__KeyInfoConfirmationDataType(soap, tag, id, (const struct ns8__KeyInfoConfirmationDataType *)ptr, "ns8:KeyInfoConfirmationDataType");
  case SOAP_TYPE_ns8__ActionType:
    return soap_out_ns8__ActionType(soap, tag, id, (const struct ns8__ActionType *)ptr, "ns8:ActionType");
  case SOAP_TYPE_ns4__ResourceUnavailableFaultType:
    return soap_out_ns4__ResourceUnavailableFaultType(soap, tag, id, (const struct ns4__ResourceUnavailableFaultType *)ptr, "ns4:ResourceUnavailableFaultType");
  case SOAP_TYPE_ns4__ResourceUnknownFaultType:
    return soap_out_ns4__ResourceUnknownFaultType(soap, tag, id, (const struct ns4__ResourceUnknownFaultType *)ptr, "ns4:ResourceUnknownFaultType");
  case SOAP_TYPE_ns3__ResumeFailedFaultType:
    return soap_out_ns3__ResumeFailedFaultType(soap, tag, id, (const struct ns3__ResumeFailedFaultType *)ptr, "ns3:ResumeFailedFaultType");
  case SOAP_TYPE_ns3__PauseFailedFaultType:
    return soap_out_ns3__PauseFailedFaultType(soap, tag, id, (const struct ns3__PauseFailedFaultType *)ptr, "ns3:PauseFailedFaultType");
  case SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType:
    return soap_out_ns3__UnableToDestroySubscriptionFaultType(soap, tag, id, (const struct ns3__UnableToDestroySubscriptionFaultType *)ptr, "ns3:UnableToDestroySubscriptionFaultType");
  case SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType:
    return soap_out_ns3__UnacceptableTerminationTimeFaultType(soap, tag, id, (const struct ns3__UnacceptableTerminationTimeFaultType *)ptr, "ns3:UnacceptableTerminationTimeFaultType");
  case SOAP_TYPE_ns3__UnableToCreatePullPointFaultType:
    return soap_out_ns3__UnableToCreatePullPointFaultType(soap, tag, id, (const struct ns3__UnableToCreatePullPointFaultType *)ptr, "ns3:UnableToCreatePullPointFaultType");
  case SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType:
    return soap_out_ns3__UnableToDestroyPullPointFaultType(soap, tag, id, (const struct ns3__UnableToDestroyPullPointFaultType *)ptr, "ns3:UnableToDestroyPullPointFaultType");
  case SOAP_TYPE_ns3__UnableToGetMessagesFaultType:
    return soap_out_ns3__UnableToGetMessagesFaultType(soap, tag, id, (const struct ns3__UnableToGetMessagesFaultType *)ptr, "ns3:UnableToGetMessagesFaultType");
  case SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType:
    return soap_out_ns3__NoCurrentMessageOnTopicFaultType(soap, tag, id, (const struct ns3__NoCurrentMessageOnTopicFaultType *)ptr, "ns3:NoCurrentMessageOnTopicFaultType");
  case SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType:
    return soap_out_ns3__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, (const struct ns3__UnacceptableInitialTerminationTimeFaultType *)ptr, "ns3:UnacceptableInitialTerminationTimeFaultType");
  case SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType:
    return soap_out_ns3__NotifyMessageNotSupportedFaultType(soap, tag, id, (const struct ns3__NotifyMessageNotSupportedFaultType *)ptr, "ns3:NotifyMessageNotSupportedFaultType");
  case SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType:
    return soap_out_ns3__UnsupportedPolicyRequestFaultType(soap, tag, id, (const struct ns3__UnsupportedPolicyRequestFaultType *)ptr, "ns3:UnsupportedPolicyRequestFaultType");
  case SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType:
    return soap_out_ns3__UnrecognizedPolicyRequestFaultType(soap, tag, id, (const struct ns3__UnrecognizedPolicyRequestFaultType *)ptr, "ns3:UnrecognizedPolicyRequestFaultType");
  case SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType:
    return soap_out_ns3__InvalidMessageContentExpressionFaultType(soap, tag, id, (const struct ns3__InvalidMessageContentExpressionFaultType *)ptr, "ns3:InvalidMessageContentExpressionFaultType");
  case SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType:
    return soap_out_ns3__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, (const struct ns3__InvalidProducerPropertiesExpressionFaultType *)ptr, "ns3:InvalidProducerPropertiesExpressionFaultType");
  case SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType:
    return soap_out_ns3__MultipleTopicsSpecifiedFaultType(soap, tag, id, (const struct ns3__MultipleTopicsSpecifiedFaultType *)ptr, "ns3:MultipleTopicsSpecifiedFaultType");
  case SOAP_TYPE_ns3__TopicNotSupportedFaultType:
    return soap_out_ns3__TopicNotSupportedFaultType(soap, tag, id, (const struct ns3__TopicNotSupportedFaultType *)ptr, "ns3:TopicNotSupportedFaultType");
  case SOAP_TYPE_ns3__InvalidTopicExpressionFaultType:
    return soap_out_ns3__InvalidTopicExpressionFaultType(soap, tag, id, (const struct ns3__InvalidTopicExpressionFaultType *)ptr, "ns3:InvalidTopicExpressionFaultType");
  case SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType:
    return soap_out_ns3__TopicExpressionDialectUnknownFaultType(soap, tag, id, (const struct ns3__TopicExpressionDialectUnknownFaultType *)ptr, "ns3:TopicExpressionDialectUnknownFaultType");
  case SOAP_TYPE_ns3__InvalidFilterFaultType:
    return soap_out_ns3__InvalidFilterFaultType(soap, tag, id, (const struct ns3__InvalidFilterFaultType *)ptr, "ns3:InvalidFilterFaultType");
  case SOAP_TYPE_ns3__SubscribeCreationFailedFaultType:
    return soap_out_ns3__SubscribeCreationFailedFaultType(soap, tag, id, (const struct ns3__SubscribeCreationFailedFaultType *)ptr, "ns3:SubscribeCreationFailedFaultType");
  case SOAP_TYPE_ns1__reservationResourceType:
    return soap_out_ns1__reservationResourceType(soap, tag, id, (const struct ns1__reservationResourceType *)ptr, "ns1:reservationResourceType");
  case SOAP_TYPE_ns8__EvidenceType:
    return soap_out_ns8__EvidenceType(soap, tag, id, (const struct ns8__EvidenceType *)ptr, "ns8:EvidenceType");
  case SOAP_TYPE_ns8__AuthnContextType:
    return soap_out_ns8__AuthnContextType(soap, tag, id, (const struct ns8__AuthnContextType *)ptr, "ns8:AuthnContextType");
  case SOAP_TYPE_ns8__SubjectLocalityType:
    return soap_out_ns8__SubjectLocalityType(soap, tag, id, (const struct ns8__SubjectLocalityType *)ptr, "ns8:SubjectLocalityType");
  case SOAP_TYPE_ns8__ProxyRestrictionType:
    return soap_out_ns8__ProxyRestrictionType(soap, tag, id, (const struct ns8__ProxyRestrictionType *)ptr, "ns8:ProxyRestrictionType");
  case SOAP_TYPE_ns8__OneTimeUseType:
    return soap_out_ns8__OneTimeUseType(soap, tag, id, (const struct ns8__OneTimeUseType *)ptr, "ns8:OneTimeUseType");
  case SOAP_TYPE_ns8__AudienceRestrictionType:
    return soap_out_ns8__AudienceRestrictionType(soap, tag, id, (const struct ns8__AudienceRestrictionType *)ptr, "ns8:AudienceRestrictionType");
  case SOAP_TYPE_ns8__ConditionAbstractType:
    return soap_out_ns8__ConditionAbstractType(soap, tag, id, (const struct ns8__ConditionAbstractType *)ptr, "ns8:ConditionAbstractType");
  case SOAP_TYPE_ns8__SubjectConfirmationDataType:
    return soap_out_ns8__SubjectConfirmationDataType(soap, tag, id, (const struct ns8__SubjectConfirmationDataType *)ptr, "ns8:SubjectConfirmationDataType");
  case SOAP_TYPE_ns8__SubjectConfirmationType:
    return soap_out_ns8__SubjectConfirmationType(soap, tag, id, (const struct ns8__SubjectConfirmationType *)ptr, "ns8:SubjectConfirmationType");
  case SOAP_TYPE_ns8__AttributeStatementType:
    return soap_out_ns8__AttributeStatementType(soap, tag, id, (const struct ns8__AttributeStatementType *)ptr, "ns8:AttributeStatementType");
  case SOAP_TYPE_ns8__AuthzDecisionStatementType:
    return soap_out_ns8__AuthzDecisionStatementType(soap, tag, id, (const struct ns8__AuthzDecisionStatementType *)ptr, "ns8:AuthzDecisionStatementType");
  case SOAP_TYPE_ns8__AuthnStatementType:
    return soap_out_ns8__AuthnStatementType(soap, tag, id, (const struct ns8__AuthnStatementType *)ptr, "ns8:AuthnStatementType");
  case SOAP_TYPE_ns8__StatementAbstractType:
    return soap_out_ns8__StatementAbstractType(soap, tag, id, (const struct ns8__StatementAbstractType *)ptr, "ns8:StatementAbstractType");
  case SOAP_TYPE_ns8__AdviceType:
    return soap_out_ns8__AdviceType(soap, tag, id, (const struct ns8__AdviceType *)ptr, "ns8:AdviceType");
  case SOAP_TYPE_ns8__ConditionsType:
    return soap_out_ns8__ConditionsType(soap, tag, id, (const struct ns8__ConditionsType *)ptr, "ns8:ConditionsType");
  case SOAP_TYPE_ns8__SubjectType:
    return soap_out_ns8__SubjectType(soap, tag, id, (const struct ns8__SubjectType *)ptr, "ns8:SubjectType");
  case SOAP_TYPE_ns8__NameIDType:
    return soap_out_ns8__NameIDType(soap, tag, id, (const struct ns8__NameIDType *)ptr, "ns8:NameIDType");
  case SOAP_TYPE_ns8__AssertionType:
    return soap_out_ns8__AssertionType(soap, tag, id, (const struct ns8__AssertionType *)ptr, "ns8:AssertionType");
  case SOAP_TYPE_ns8__EncryptedElementType:
    return soap_out_ns8__EncryptedElementType(soap, tag, id, (const struct ns8__EncryptedElementType *)ptr, "ns8:EncryptedElementType");
  case SOAP_TYPE_ns8__BaseIDAbstractType:
    return soap_out_ns8__BaseIDAbstractType(soap, tag, id, (const struct ns8__BaseIDAbstractType *)ptr, "ns8:BaseIDAbstractType");
  case SOAP_TYPE_ns7__FaultCauseType:
    return soap_out_ns7__FaultCauseType(soap, tag, id, (const struct ns7__FaultCauseType *)ptr, "ns7:FaultCauseType");
  case SOAP_TYPE_ns7__ErrorCodeType:
    return soap_out_ns7__ErrorCodeType(soap, tag, id, (const struct ns7__ErrorCodeType *)ptr, "ns7:ErrorCodeType");
  case SOAP_TYPE_ns7__BaseFaultType:
    return soap_out_ns7__BaseFaultType(soap, tag, id, (const struct ns7__BaseFaultType *)ptr, "ns7:BaseFaultType");
  case SOAP_TYPE_ns6__authConditionType:
    return soap_out_ns6__authConditionType(soap, tag, id, (const struct ns6__authConditionType *)ptr, "ns6:authConditionType");
  case SOAP_TYPE_ns6__authConditions:
    return soap_out_ns6__authConditions(soap, tag, id, (const struct ns6__authConditions *)ptr, "ns6:authConditions");
  case SOAP_TYPE_ns8__AttributeType:
    return soap_out_ns8__AttributeType(soap, tag, id, (const struct ns8__AttributeType *)ptr, "ns8:AttributeType");
  case SOAP_TYPE_ns6__subjectAttributes:
    return soap_out_ns6__subjectAttributes(soap, tag, id, (const struct ns6__subjectAttributes *)ptr, "ns6:subjectAttributes");
  case SOAP_TYPE_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo:
    return soap_out_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag, id, (const struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *)ptr, "ns5:CtrlPlaneSwitchingCapabilitySpecificInfo");
  case SOAP_TYPE_ns5__Duration:
    return soap_out_ns5__Duration(soap, tag, id, (const struct ns5__Duration *)ptr, "ns5:Duration");
  case SOAP_TYPE_ns5__TimeContent:
    return soap_out_ns5__TimeContent(soap, tag, id, (const struct ns5__TimeContent *)ptr, "ns5:TimeContent");
  case SOAP_TYPE_ns5__CtrlPlaneNextHopContent:
    return soap_out_ns5__CtrlPlaneNextHopContent(soap, tag, id, (const struct ns5__CtrlPlaneNextHopContent *)ptr, "ns5:CtrlPlaneNextHopContent");
  case SOAP_TYPE_ns5__CtrlPlaneHopContent:
    return soap_out_ns5__CtrlPlaneHopContent(soap, tag, id, (const struct ns5__CtrlPlaneHopContent *)ptr, "ns5:CtrlPlaneHopContent");
  case SOAP_TYPE_ns5__CtrlPlaneSwcapContent:
    return soap_out_ns5__CtrlPlaneSwcapContent(soap, tag, id, (const struct ns5__CtrlPlaneSwcapContent *)ptr, "ns5:CtrlPlaneSwcapContent");
  case SOAP_TYPE_ns5__CtrlPlaneAdministrativeGroup:
    return soap_out_ns5__CtrlPlaneAdministrativeGroup(soap, tag, id, (const struct ns5__CtrlPlaneAdministrativeGroup *)ptr, "ns5:CtrlPlaneAdministrativeGroup");
  case SOAP_TYPE_ns5__CtrlPlaneAddressContent:
    return soap_out_ns5__CtrlPlaneAddressContent(soap, tag, id, (const struct ns5__CtrlPlaneAddressContent *)ptr, "ns5:CtrlPlaneAddressContent");
  case SOAP_TYPE_ns5__CtrlPlaneLinkContent:
    return soap_out_ns5__CtrlPlaneLinkContent(soap, tag, id, (const struct ns5__CtrlPlaneLinkContent *)ptr, "ns5:CtrlPlaneLinkContent");
  case SOAP_TYPE_ns5__CtrlPlanePortContent:
    return soap_out_ns5__CtrlPlanePortContent(soap, tag, id, (const struct ns5__CtrlPlanePortContent *)ptr, "ns5:CtrlPlanePortContent");
  case SOAP_TYPE_ns5__CtrlPlaneNodeContent:
    return soap_out_ns5__CtrlPlaneNodeContent(soap, tag, id, (const struct ns5__CtrlPlaneNodeContent *)ptr, "ns5:CtrlPlaneNodeContent");
  case SOAP_TYPE_ns5__Lifetime:
    return soap_out_ns5__Lifetime(soap, tag, id, (const struct ns5__Lifetime *)ptr, "ns5:Lifetime");
  case SOAP_TYPE_ns5__CtrlPlaneDomainSignatureContent:
    return soap_out_ns5__CtrlPlaneDomainSignatureContent(soap, tag, id, (const struct ns5__CtrlPlaneDomainSignatureContent *)ptr, "ns5:CtrlPlaneDomainSignatureContent");
  case SOAP_TYPE_ns5__CtrlPlaneDomainContent:
    return soap_out_ns5__CtrlPlaneDomainContent(soap, tag, id, (const struct ns5__CtrlPlaneDomainContent *)ptr, "ns5:CtrlPlaneDomainContent");
  case SOAP_TYPE__ns3__ResumeSubscriptionResponse:
    return soap_out__ns3__ResumeSubscriptionResponse(soap, "ns3:ResumeSubscriptionResponse", id, (const struct _ns3__ResumeSubscriptionResponse *)ptr, NULL);
  case SOAP_TYPE__ns3__ResumeSubscription:
    return soap_out__ns3__ResumeSubscription(soap, "ns3:ResumeSubscription", id, (const struct _ns3__ResumeSubscription *)ptr, NULL);
  case SOAP_TYPE__ns3__PauseSubscriptionResponse:
    return soap_out__ns3__PauseSubscriptionResponse(soap, "ns3:PauseSubscriptionResponse", id, (const struct _ns3__PauseSubscriptionResponse *)ptr, NULL);
  case SOAP_TYPE__ns3__PauseSubscription:
    return soap_out__ns3__PauseSubscription(soap, "ns3:PauseSubscription", id, (const struct _ns3__PauseSubscription *)ptr, NULL);
  case SOAP_TYPE__ns3__UnsubscribeResponse:
    return soap_out__ns3__UnsubscribeResponse(soap, "ns3:UnsubscribeResponse", id, (const struct _ns3__UnsubscribeResponse *)ptr, NULL);
  case SOAP_TYPE__ns3__Unsubscribe:
    return soap_out__ns3__Unsubscribe(soap, "ns3:Unsubscribe", id, (const struct _ns3__Unsubscribe *)ptr, NULL);
  case SOAP_TYPE__ns3__RenewResponse:
    return soap_out__ns3__RenewResponse(soap, "ns3:RenewResponse", id, (const struct _ns3__RenewResponse *)ptr, NULL);
  case SOAP_TYPE__ns3__Renew:
    return soap_out__ns3__Renew(soap, "ns3:Renew", id, (const struct _ns3__Renew *)ptr, NULL);
  case SOAP_TYPE__ns3__CreatePullPointResponse:
    return soap_out__ns3__CreatePullPointResponse(soap, "ns3:CreatePullPointResponse", id, (const struct _ns3__CreatePullPointResponse *)ptr, NULL);
  case SOAP_TYPE__ns3__CreatePullPoint:
    return soap_out__ns3__CreatePullPoint(soap, "ns3:CreatePullPoint", id, (const struct _ns3__CreatePullPoint *)ptr, NULL);
  case SOAP_TYPE__ns3__DestroyPullPointResponse:
    return soap_out__ns3__DestroyPullPointResponse(soap, "ns3:DestroyPullPointResponse", id, (const struct _ns3__DestroyPullPointResponse *)ptr, NULL);
  case SOAP_TYPE__ns3__DestroyPullPoint:
    return soap_out__ns3__DestroyPullPoint(soap, "ns3:DestroyPullPoint", id, (const struct _ns3__DestroyPullPoint *)ptr, NULL);
  case SOAP_TYPE__ns3__GetMessagesResponse:
    return soap_out__ns3__GetMessagesResponse(soap, "ns3:GetMessagesResponse", id, (const struct _ns3__GetMessagesResponse *)ptr, NULL);
  case SOAP_TYPE__ns3__GetMessages:
    return soap_out__ns3__GetMessages(soap, "ns3:GetMessages", id, (const struct _ns3__GetMessages *)ptr, NULL);
  case SOAP_TYPE__ns3__GetCurrentMessageResponse:
    return soap_out__ns3__GetCurrentMessageResponse(soap, "ns3:GetCurrentMessageResponse", id, (const struct _ns3__GetCurrentMessageResponse *)ptr, NULL);
  case SOAP_TYPE__ns3__GetCurrentMessage:
    return soap_out__ns3__GetCurrentMessage(soap, "ns3:GetCurrentMessage", id, (const struct _ns3__GetCurrentMessage *)ptr, NULL);
  case SOAP_TYPE__ns3__SubscribeResponse:
    return soap_out__ns3__SubscribeResponse(soap, "ns3:SubscribeResponse", id, (const struct _ns3__SubscribeResponse *)ptr, NULL);
  case SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy:
    return soap_out__ns3__Subscribe_SubscriptionPolicy(soap, "ns3:Subscribe-SubscriptionPolicy", id, (const struct _ns3__Subscribe_SubscriptionPolicy *)ptr, NULL);
  case SOAP_TYPE__ns3__Subscribe:
    return soap_out__ns3__Subscribe(soap, "ns3:Subscribe", id, (const struct _ns3__Subscribe *)ptr, NULL);
  case SOAP_TYPE__ns3__UseRaw:
    return soap_out__ns3__UseRaw(soap, "ns3:UseRaw", id, (const struct _ns3__UseRaw *)ptr, NULL);
  case SOAP_TYPE__ns3__Notify:
    return soap_out__ns3__Notify(soap, "ns3:Notify", id, (const struct _ns3__Notify *)ptr, NULL);
  case SOAP_TYPE__ns3__SubscriptionManagerRP:
    return soap_out__ns3__SubscriptionManagerRP(soap, "ns3:SubscriptionManagerRP", id, (const struct _ns3__SubscriptionManagerRP *)ptr, NULL);
  case SOAP_TYPE_ns3__MessageType:
    return soap_out_ns3__MessageType(soap, tag, id, (const struct ns3__MessageType *)ptr, "ns3:MessageType");
  case SOAP_TYPE_ns3__NotificationMessageHolderType:
    return soap_out_ns3__NotificationMessageHolderType(soap, tag, id, (const struct ns3__NotificationMessageHolderType *)ptr, "ns3:NotificationMessageHolderType");
  case SOAP_TYPE_ns3__SubscriptionPolicyType:
    return soap_out_ns3__SubscriptionPolicyType(soap, tag, id, (const struct ns3__SubscriptionPolicyType *)ptr, "ns3:SubscriptionPolicyType");
  case SOAP_TYPE_ns3__QueryExpressionType:
    return soap_out_ns3__QueryExpressionType(soap, tag, id, (const struct ns3__QueryExpressionType *)ptr, "ns3:QueryExpressionType");
  case SOAP_TYPE_ns3__TopicExpressionType:
    return soap_out_ns3__TopicExpressionType(soap, tag, id, (const struct ns3__TopicExpressionType *)ptr, "ns3:TopicExpressionType");
  case SOAP_TYPE_ns3__FilterType:
    return soap_out_ns3__FilterType(soap, tag, id, (const struct ns3__FilterType *)ptr, "ns3:FilterType");
  case SOAP_TYPE__ns2__OSCARSFault:
    return soap_out__ns2__OSCARSFault(soap, "ns2:OSCARSFault", id, (const struct _ns2__OSCARSFault *)ptr, NULL);
  case SOAP_TYPE_ns2__emptyArg:
    return soap_out_ns2__emptyArg(soap, tag, id, (const struct ns2__emptyArg *)ptr, "ns2:emptyArg");
  case SOAP_TYPE_ns1__optionalConstraintValue:
    return soap_out_ns1__optionalConstraintValue(soap, tag, id, (const struct ns1__optionalConstraintValue *)ptr, "ns1:optionalConstraintValue");
  case SOAP_TYPE_ns1__globalReservationId:
    return soap_out_ns1__globalReservationId(soap, tag, id, (const struct ns1__globalReservationId *)ptr, "ns1:globalReservationId");
  case SOAP_TYPE_ns1__localDetails:
    return soap_out_ns1__localDetails(soap, tag, id, (const struct ns1__localDetails *)ptr, "ns1:localDetails");
  case SOAP_TYPE_ns1__eventContent:
    return soap_out_ns1__eventContent(soap, tag, id, (const struct ns1__eventContent *)ptr, "ns1:eventContent");
  case SOAP_TYPE_ns1__interDomainEventContent:
    return soap_out_ns1__interDomainEventContent(soap, tag, id, (const struct ns1__interDomainEventContent *)ptr, "ns1:interDomainEventContent");
  case SOAP_TYPE_ns1__mplsInfo:
    return soap_out_ns1__mplsInfo(soap, tag, id, (const struct ns1__mplsInfo *)ptr, "ns1:mplsInfo");
  case SOAP_TYPE_ns1__layer3Info:
    return soap_out_ns1__layer3Info(soap, tag, id, (const struct ns1__layer3Info *)ptr, "ns1:layer3Info");
  case SOAP_TYPE_ns1__layer2Info:
    return soap_out_ns1__layer2Info(soap, tag, id, (const struct ns1__layer2Info *)ptr, "ns1:layer2Info");
  case SOAP_TYPE_ns5__CtrlPlanePathContent:
    return soap_out_ns5__CtrlPlanePathContent(soap, tag, id, (const struct ns5__CtrlPlanePathContent *)ptr, "ns5:CtrlPlanePathContent");
  case SOAP_TYPE_ns1__pathInfo:
    return soap_out_ns1__pathInfo(soap, tag, id, (const struct ns1__pathInfo *)ptr, "ns1:pathInfo");
  case SOAP_TYPE_ns1__listReply:
    return soap_out_ns1__listReply(soap, tag, id, (const struct ns1__listReply *)ptr, "ns1:listReply");
  case SOAP_TYPE_ns1__vlanTag:
    return soap_out_ns1__vlanTag(soap, tag, id, (const struct ns1__vlanTag *)ptr, "ns1:vlanTag");
  case SOAP_TYPE_ns1__listRequest:
    return soap_out_ns1__listRequest(soap, tag, id, (const struct ns1__listRequest *)ptr, "ns1:listRequest");
  case SOAP_TYPE_ns1__teardownPathResponseContent:
    return soap_out_ns1__teardownPathResponseContent(soap, tag, id, (const struct ns1__teardownPathResponseContent *)ptr, "ns1:teardownPathResponseContent");
  case SOAP_TYPE_ns1__teardownPathContent:
    return soap_out_ns1__teardownPathContent(soap, tag, id, (const struct ns1__teardownPathContent *)ptr, "ns1:teardownPathContent");
  case SOAP_TYPE_ns1__refreshPathResponseContent:
    return soap_out_ns1__refreshPathResponseContent(soap, tag, id, (const struct ns1__refreshPathResponseContent *)ptr, "ns1:refreshPathResponseContent");
  case SOAP_TYPE_ns1__refreshPathContent:
    return soap_out_ns1__refreshPathContent(soap, tag, id, (const struct ns1__refreshPathContent *)ptr, "ns1:refreshPathContent");
  case SOAP_TYPE_ns1__createPathResponseContent:
    return soap_out_ns1__createPathResponseContent(soap, tag, id, (const struct ns1__createPathResponseContent *)ptr, "ns1:createPathResponseContent");
  case SOAP_TYPE_ns1__createPathContent:
    return soap_out_ns1__createPathContent(soap, tag, id, (const struct ns1__createPathContent *)ptr, "ns1:createPathContent");
  case SOAP_TYPE_ns5__CtrlPlaneTopologyContent:
    return soap_out_ns5__CtrlPlaneTopologyContent(soap, tag, id, (const struct ns5__CtrlPlaneTopologyContent *)ptr, "ns5:CtrlPlaneTopologyContent");
  case SOAP_TYPE_ns1__getTopologyResponseContent:
    return soap_out_ns1__getTopologyResponseContent(soap, tag, id, (const struct ns1__getTopologyResponseContent *)ptr, "ns1:getTopologyResponseContent");
  case SOAP_TYPE_ns1__getTopologyContent:
    return soap_out_ns1__getTopologyContent(soap, tag, id, (const struct ns1__getTopologyContent *)ptr, "ns1:getTopologyContent");
  case SOAP_TYPE_ns1__modifyResReply:
    return soap_out_ns1__modifyResReply(soap, tag, id, (const struct ns1__modifyResReply *)ptr, "ns1:modifyResReply");
  case SOAP_TYPE_ns1__modifyResContent:
    return soap_out_ns1__modifyResContent(soap, tag, id, (const struct ns1__modifyResContent *)ptr, "ns1:modifyResContent");
  case SOAP_TYPE_ns1__resDetails:
    return soap_out_ns1__resDetails(soap, tag, id, (const struct ns1__resDetails *)ptr, "ns1:resDetails");
  case SOAP_TYPE_ns1__queryResReply:
    return soap_out_ns1__queryResReply(soap, tag, id, (const struct ns1__queryResReply *)ptr, "ns1:queryResReply");
  case SOAP_TYPE_ns1__queryResContent:
    return soap_out_ns1__queryResContent(soap, tag, id, (const struct ns1__queryResContent *)ptr, "ns1:queryResContent");
  case SOAP_TYPE_ns1__cancelResReply:
    return soap_out_ns1__cancelResReply(soap, tag, id, (const struct ns1__cancelResReply *)ptr, "ns1:cancelResReply");
  case SOAP_TYPE_ns1__cancelResContent:
    return soap_out_ns1__cancelResContent(soap, tag, id, (const struct ns1__cancelResContent *)ptr, "ns1:cancelResContent");
  case SOAP_TYPE_ns1__createReply:
    return soap_out_ns1__createReply(soap, tag, id, (const struct ns1__createReply *)ptr, "ns1:createReply");
  case SOAP_TYPE_ns1__optionalConstraintType:
    return soap_out_ns1__optionalConstraintType(soap, tag, id, (const struct ns1__optionalConstraintType *)ptr, "ns1:optionalConstraintType");
  case SOAP_TYPE_ns1__reservedConstraintType:
    return soap_out_ns1__reservedConstraintType(soap, tag, id, (const struct ns1__reservedConstraintType *)ptr, "ns1:reservedConstraintType");
  case SOAP_TYPE_ns1__userRequestConstraintType:
    return soap_out_ns1__userRequestConstraintType(soap, tag, id, (const struct ns1__userRequestConstraintType *)ptr, "ns1:userRequestConstraintType");
  case SOAP_TYPE_ns6__messagePropertiesType:
    return soap_out_ns6__messagePropertiesType(soap, tag, id, (const struct ns6__messagePropertiesType *)ptr, "ns6:messagePropertiesType");
  case SOAP_TYPE_ns1__resCreateContent:
    return soap_out_ns1__resCreateContent(soap, tag, id, (const struct ns1__resCreateContent *)ptr, "ns1:resCreateContent");
  case SOAP_TYPE__wsse__Security:
    return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, NULL);
  case SOAP_TYPE__wsse__KeyIdentifier:
    return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, NULL);
  case SOAP_TYPE__wsse__Embedded:
    return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, NULL);
  case SOAP_TYPE__wsse__Reference:
    return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, NULL);
  case SOAP_TYPE__wsse__BinarySecurityToken:
    return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, NULL);
  case SOAP_TYPE__wsse__Password:
    return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, NULL);
  case SOAP_TYPE__wsse__UsernameToken:
    return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, NULL);
  case SOAP_TYPE__wsu__Timestamp:
    return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, NULL);
  case SOAP_TYPE__wsa5__ProblemAction:
    return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, NULL);
  case SOAP_TYPE__wsa5__FaultTo:
    return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
  case SOAP_TYPE__wsa5__From:
    return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
  case SOAP_TYPE__wsa5__ReplyTo:
    return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
  case SOAP_TYPE__wsa5__RelatesTo:
    return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, NULL);
  case SOAP_TYPE__wsa5__Metadata:
    return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, NULL);
  case SOAP_TYPE__wsa5__ReferenceParameters:
    return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, NULL);
  case SOAP_TYPE__wsa5__EndpointReference:
    return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
  case SOAP_TYPE_wsa5__ProblemActionType:
    return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
  case SOAP_TYPE_wsa5__RelatesToType:
    return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
  case SOAP_TYPE_wsa5__MetadataType:
    return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
  case SOAP_TYPE_wsa5__ReferenceParametersType:
    return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
  case SOAP_TYPE_wsa5__EndpointReferenceType:
    return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
  case SOAP_TYPE__xenc__EncryptionProperty:
    return soap_out__xenc__EncryptionProperty(soap, "xenc:EncryptionProperty", id, (const struct xenc__EncryptionPropertyType *)ptr, NULL);
  case SOAP_TYPE__xenc__EncryptionProperties:
    return soap_out__xenc__EncryptionProperties(soap, "xenc:EncryptionProperties", id, (const struct xenc__EncryptionPropertiesType *)ptr, NULL);
  case SOAP_TYPE__xenc__AgreementMethod:
    return soap_out__xenc__AgreementMethod(soap, "xenc:AgreementMethod", id, (const struct xenc__AgreementMethodType *)ptr, NULL);
  case SOAP_TYPE__xenc__EncryptedKey:
    return soap_out__xenc__EncryptedKey(soap, "xenc:EncryptedKey", id, (const struct xenc__EncryptedKeyType *)ptr, NULL);
  case SOAP_TYPE__xenc__EncryptedData:
    return soap_out__xenc__EncryptedData(soap, "xenc:EncryptedData", id, (const struct xenc__EncryptedDataType *)ptr, NULL);
  case SOAP_TYPE__xenc__CipherReference:
    return soap_out__xenc__CipherReference(soap, "xenc:CipherReference", id, (const struct xenc__CipherReferenceType *)ptr, NULL);
  case SOAP_TYPE__xenc__CipherData:
    return soap_out__xenc__CipherData(soap, "xenc:CipherData", id, (const struct xenc__CipherDataType *)ptr, NULL);
  case SOAP_TYPE__xenc__ReferenceList:
    return soap_out__xenc__ReferenceList(soap, "xenc:ReferenceList", id, (const struct _xenc__ReferenceList *)ptr, NULL);
  case SOAP_TYPE_xenc__EncryptionPropertyType:
    return soap_out_xenc__EncryptionPropertyType(soap, tag, id, (const struct xenc__EncryptionPropertyType *)ptr, "xenc:EncryptionPropertyType");
  case SOAP_TYPE_xenc__EncryptionPropertiesType:
    return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, (const struct xenc__EncryptionPropertiesType *)ptr, "xenc:EncryptionPropertiesType");
  case SOAP_TYPE_xenc__ReferenceType:
    return soap_out_xenc__ReferenceType(soap, tag, id, (const struct xenc__ReferenceType *)ptr, "xenc:ReferenceType");
  case SOAP_TYPE_xenc__AgreementMethodType:
    return soap_out_xenc__AgreementMethodType(soap, tag, id, (const struct xenc__AgreementMethodType *)ptr, "xenc:AgreementMethodType");
  case SOAP_TYPE_xenc__EncryptedKeyType:
    return soap_out_xenc__EncryptedKeyType(soap, tag, id, (const struct xenc__EncryptedKeyType *)ptr, "xenc:EncryptedKeyType");
  case SOAP_TYPE_xenc__EncryptedDataType:
    return soap_out_xenc__EncryptedDataType(soap, tag, id, (const struct xenc__EncryptedDataType *)ptr, "xenc:EncryptedDataType");
  case SOAP_TYPE_xenc__TransformsType:
    return soap_out_xenc__TransformsType(soap, tag, id, (const struct xenc__TransformsType *)ptr, "xenc:TransformsType");
  case SOAP_TYPE_xenc__CipherReferenceType:
    return soap_out_xenc__CipherReferenceType(soap, tag, id, (const struct xenc__CipherReferenceType *)ptr, "xenc:CipherReferenceType");
  case SOAP_TYPE_xenc__CipherDataType:
    return soap_out_xenc__CipherDataType(soap, tag, id, (const struct xenc__CipherDataType *)ptr, "xenc:CipherDataType");
  case SOAP_TYPE_xenc__EncryptionMethodType:
    return soap_out_xenc__EncryptionMethodType(soap, tag, id, (const struct xenc__EncryptionMethodType *)ptr, "xenc:EncryptionMethodType");
  case SOAP_TYPE_xenc__EncryptedType:
    return soap_out_xenc__EncryptedType(soap, tag, id, (const struct xenc__EncryptedType *)ptr, "xenc:EncryptedType");
  case SOAP_TYPE_ds__RSAKeyValueType:
    return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
  case SOAP_TYPE_ds__DSAKeyValueType:
    return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
  case SOAP_TYPE_ds__X509IssuerSerialType:
    return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
  case SOAP_TYPE__ds__KeyInfo:
    return soap_out__ds__KeyInfo(soap, "ds:KeyInfo", id, (const struct ds__KeyInfoType *)ptr, NULL);
  case SOAP_TYPE__wsse__SecurityTokenReference:
    return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, NULL);
  case SOAP_TYPE_ds__X509DataType:
    return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
  case SOAP_TYPE_ds__RetrievalMethodType:
    return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
  case SOAP_TYPE_ds__KeyValueType:
    return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
  case SOAP_TYPE_ds__DigestMethodType:
    return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
  case SOAP_TYPE__ds__Transform:
    return soap_out__ds__Transform(soap, "ds:Transform", id, (const struct ds__TransformType *)ptr, NULL);
  case SOAP_TYPE_ds__TransformType:
    return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
  case SOAP_TYPE__c14n__InclusiveNamespaces:
    return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, NULL);
  case SOAP_TYPE_ds__TransformsType:
    return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
  case SOAP_TYPE_ds__ReferenceType:
    return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
  case SOAP_TYPE_ds__SignatureMethodType:
    return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
  case SOAP_TYPE_ds__CanonicalizationMethodType:
    return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
  case SOAP_TYPE__ds__Signature:
    return soap_out__ds__Signature(soap, "ds:Signature", id, (const struct ds__SignatureType *)ptr, NULL);
  case SOAP_TYPE_ds__KeyInfoType:
    return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
  case SOAP_TYPE_ds__SignedInfoType:
    return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
  case SOAP_TYPE_ds__SignatureType:
    return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
  case SOAP_TYPE_PointerTons1__interDomainEventContent:
    return soap_out_PointerTons1__interDomainEventContent(soap, tag, id, (struct ns1__interDomainEventContent *const*)ptr, "ns1:interDomainEventContent");
  case SOAP_TYPE_PointerTons1__teardownPathResponseContent:
    return soap_out_PointerTons1__teardownPathResponseContent(soap, tag, id, (struct ns1__teardownPathResponseContent *const*)ptr, "ns1:teardownPathResponseContent");
  case SOAP_TYPE_PointerTons1__teardownPathContent:
    return soap_out_PointerTons1__teardownPathContent(soap, tag, id, (struct ns1__teardownPathContent *const*)ptr, "ns1:teardownPathContent");
  case SOAP_TYPE_PointerTons1__refreshPathResponseContent:
    return soap_out_PointerTons1__refreshPathResponseContent(soap, tag, id, (struct ns1__refreshPathResponseContent *const*)ptr, "ns1:refreshPathResponseContent");
  case SOAP_TYPE_PointerTons1__refreshPathContent:
    return soap_out_PointerTons1__refreshPathContent(soap, tag, id, (struct ns1__refreshPathContent *const*)ptr, "ns1:refreshPathContent");
  case SOAP_TYPE_PointerTons1__createPathResponseContent:
    return soap_out_PointerTons1__createPathResponseContent(soap, tag, id, (struct ns1__createPathResponseContent *const*)ptr, "ns1:createPathResponseContent");
  case SOAP_TYPE_PointerTons1__createPathContent:
    return soap_out_PointerTons1__createPathContent(soap, tag, id, (struct ns1__createPathContent *const*)ptr, "ns1:createPathContent");
  case SOAP_TYPE_PointerTons1__getTopologyResponseContent:
    return soap_out_PointerTons1__getTopologyResponseContent(soap, tag, id, (struct ns1__getTopologyResponseContent *const*)ptr, "ns1:getTopologyResponseContent");
  case SOAP_TYPE_PointerTons1__getTopologyContent:
    return soap_out_PointerTons1__getTopologyContent(soap, tag, id, (struct ns1__getTopologyContent *const*)ptr, "ns1:getTopologyContent");
  case SOAP_TYPE_PointerTons1__modifyResReply:
    return soap_out_PointerTons1__modifyResReply(soap, tag, id, (struct ns1__modifyResReply *const*)ptr, "ns1:modifyResReply");
  case SOAP_TYPE_PointerTons1__modifyResContent:
    return soap_out_PointerTons1__modifyResContent(soap, tag, id, (struct ns1__modifyResContent *const*)ptr, "ns1:modifyResContent");
  case SOAP_TYPE_PointerTons1__cancelResReply:
    return soap_out_PointerTons1__cancelResReply(soap, tag, id, (struct ns1__cancelResReply *const*)ptr, "ns1:cancelResReply");
  case SOAP_TYPE_PointerTons1__cancelResContent:
    return soap_out_PointerTons1__cancelResContent(soap, tag, id, (struct ns1__cancelResContent *const*)ptr, "ns1:cancelResContent");
  case SOAP_TYPE_PointerTons1__listReply:
    return soap_out_PointerTons1__listReply(soap, tag, id, (struct ns1__listReply *const*)ptr, "ns1:listReply");
  case SOAP_TYPE_PointerTons1__listRequest:
    return soap_out_PointerTons1__listRequest(soap, tag, id, (struct ns1__listRequest *const*)ptr, "ns1:listRequest");
  case SOAP_TYPE_PointerTons1__queryResReply:
    return soap_out_PointerTons1__queryResReply(soap, tag, id, (struct ns1__queryResReply *const*)ptr, "ns1:queryResReply");
  case SOAP_TYPE_PointerTons1__queryResContent:
    return soap_out_PointerTons1__queryResContent(soap, tag, id, (struct ns1__queryResContent *const*)ptr, "ns1:queryResContent");
  case SOAP_TYPE_PointerTons1__createReply:
    return soap_out_PointerTons1__createReply(soap, tag, id, (struct ns1__createReply *const*)ptr, "ns1:createReply");
  case SOAP_TYPE_PointerTons1__resCreateContent:
    return soap_out_PointerTons1__resCreateContent(soap, tag, id, (struct ns1__resCreateContent *const*)ptr, "ns1:resCreateContent");
  case SOAP_TYPE_PointerTo_ns2__OSCARSFault:
    return soap_out_PointerTo_ns2__OSCARSFault(soap, tag, id, (struct _ns2__OSCARSFault *const*)ptr, "ns2:OSCARSFault");
  case SOAP_TYPE_PointerTons8__EvidenceType:
    return soap_out_PointerTons8__EvidenceType(soap, tag, id, (struct ns8__EvidenceType *const*)ptr, "ns8:EvidenceType");
  case SOAP_TYPE_PointerToPointerTons8__ActionType:
    return soap_out_PointerToPointerTons8__ActionType(soap, tag, id, (struct ns8__ActionType **const*)ptr, "ns8:ActionType");
  case SOAP_TYPE_PointerTons8__ActionType:
    return soap_out_PointerTons8__ActionType(soap, tag, id, (struct ns8__ActionType *const*)ptr, "ns8:ActionType");
  case SOAP_TYPE_PointerTons8__AuthnContextType:
    return soap_out_PointerTons8__AuthnContextType(soap, tag, id, (struct ns8__AuthnContextType *const*)ptr, "ns8:AuthnContextType");
  case SOAP_TYPE_PointerTons8__SubjectLocalityType:
    return soap_out_PointerTons8__SubjectLocalityType(soap, tag, id, (struct ns8__SubjectLocalityType *const*)ptr, "ns8:SubjectLocalityType");
  case SOAP_TYPE_PointerTo_QName:
    return soap_out_PointerTo_QName(soap, tag, id, (char **const*)ptr, "xsd:QName");
  case SOAP_TYPE_PointerTons8__AssertionType:
    return soap_out_PointerTons8__AssertionType(soap, tag, id, (struct ns8__AssertionType *const*)ptr, "ns8:AssertionType");
  case SOAP_TYPE_PointerTons8__ProxyRestrictionType:
    return soap_out_PointerTons8__ProxyRestrictionType(soap, tag, id, (struct ns8__ProxyRestrictionType *const*)ptr, "ns8:ProxyRestrictionType");
  case SOAP_TYPE_PointerTons8__OneTimeUseType:
    return soap_out_PointerTons8__OneTimeUseType(soap, tag, id, (struct ns8__OneTimeUseType *const*)ptr, "ns8:OneTimeUseType");
  case SOAP_TYPE_PointerTons8__AudienceRestrictionType:
    return soap_out_PointerTons8__AudienceRestrictionType(soap, tag, id, (struct ns8__AudienceRestrictionType *const*)ptr, "ns8:AudienceRestrictionType");
  case SOAP_TYPE_PointerTons8__ConditionAbstractType:
    return soap_out_PointerTons8__ConditionAbstractType(soap, tag, id, (struct ns8__ConditionAbstractType *const*)ptr, "ns8:ConditionAbstractType");
  case SOAP_TYPE_PointerTons8__SubjectConfirmationDataType:
    return soap_out_PointerTons8__SubjectConfirmationDataType(soap, tag, id, (struct ns8__SubjectConfirmationDataType *const*)ptr, "ns8:SubjectConfirmationDataType");
  case SOAP_TYPE_PointerToPointerTons8__SubjectConfirmationType:
    return soap_out_PointerToPointerTons8__SubjectConfirmationType(soap, tag, id, (struct ns8__SubjectConfirmationType **const*)ptr, "ns8:SubjectConfirmationType");
  case SOAP_TYPE_PointerTons8__SubjectConfirmationType:
    return soap_out_PointerTons8__SubjectConfirmationType(soap, tag, id, (struct ns8__SubjectConfirmationType *const*)ptr, "ns8:SubjectConfirmationType");
  case SOAP_TYPE_PointerTons8__EncryptedElementType:
    return soap_out_PointerTons8__EncryptedElementType(soap, tag, id, (struct ns8__EncryptedElementType *const*)ptr, "ns8:EncryptedElementType");
  case SOAP_TYPE_PointerTons8__BaseIDAbstractType:
    return soap_out_PointerTons8__BaseIDAbstractType(soap, tag, id, (struct ns8__BaseIDAbstractType *const*)ptr, "ns8:BaseIDAbstractType");
  case SOAP_TYPE_PointerTons8__AttributeStatementType:
    return soap_out_PointerTons8__AttributeStatementType(soap, tag, id, (struct ns8__AttributeStatementType *const*)ptr, "ns8:AttributeStatementType");
  case SOAP_TYPE_PointerTons8__AuthzDecisionStatementType:
    return soap_out_PointerTons8__AuthzDecisionStatementType(soap, tag, id, (struct ns8__AuthzDecisionStatementType *const*)ptr, "ns8:AuthzDecisionStatementType");
  case SOAP_TYPE_PointerTons8__AuthnStatementType:
    return soap_out_PointerTons8__AuthnStatementType(soap, tag, id, (struct ns8__AuthnStatementType *const*)ptr, "ns8:AuthnStatementType");
  case SOAP_TYPE_PointerTons8__StatementAbstractType:
    return soap_out_PointerTons8__StatementAbstractType(soap, tag, id, (struct ns8__StatementAbstractType *const*)ptr, "ns8:StatementAbstractType");
  case SOAP_TYPE_PointerTons8__AdviceType:
    return soap_out_PointerTons8__AdviceType(soap, tag, id, (struct ns8__AdviceType *const*)ptr, "ns8:AdviceType");
  case SOAP_TYPE_PointerTons8__ConditionsType:
    return soap_out_PointerTons8__ConditionsType(soap, tag, id, (struct ns8__ConditionsType *const*)ptr, "ns8:ConditionsType");
  case SOAP_TYPE_PointerTons8__SubjectType:
    return soap_out_PointerTons8__SubjectType(soap, tag, id, (struct ns8__SubjectType *const*)ptr, "ns8:SubjectType");
  case SOAP_TYPE_PointerTo_ds__Signature:
    return soap_out_PointerTo_ds__Signature(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:Signature");
  case SOAP_TYPE_PointerTons8__NameIDType:
    return soap_out_PointerTons8__NameIDType(soap, tag, id, (struct ns8__NameIDType *const*)ptr, "ns8:NameIDType");
  case SOAP_TYPE_PointerTo_xenc__EncryptedKey:
    return soap_out_PointerTo_xenc__EncryptedKey(soap, tag, id, (struct xenc__EncryptedKeyType *const*)ptr, "xenc:EncryptedKey");
  case SOAP_TYPE_PointerTons7__FaultCauseType:
    return soap_out_PointerTons7__FaultCauseType(soap, tag, id, (struct ns7__FaultCauseType *const*)ptr, "ns7:FaultCauseType");
  case SOAP_TYPE_PointerTons7__ErrorCodeType:
    return soap_out_PointerTons7__ErrorCodeType(soap, tag, id, (struct ns7__ErrorCodeType *const*)ptr, "ns7:ErrorCodeType");
  case SOAP_TYPE_PointerToPointerTons6__authConditionType:
    return soap_out_PointerToPointerTons6__authConditionType(soap, tag, id, (struct ns6__authConditionType **const*)ptr, "ns6:authConditionType");
  case SOAP_TYPE_PointerTons6__authConditionType:
    return soap_out_PointerTons6__authConditionType(soap, tag, id, (struct ns6__authConditionType *const*)ptr, "ns6:authConditionType");
  case SOAP_TYPE_PointerToPointerTons8__AttributeType:
    return soap_out_PointerToPointerTons8__AttributeType(soap, tag, id, (struct ns8__AttributeType **const*)ptr, "ns8:AttributeType");
  case SOAP_TYPE_PointerTons8__AttributeType:
    return soap_out_PointerTons8__AttributeType(soap, tag, id, (struct ns8__AttributeType *const*)ptr, "ns8:AttributeType");
  case SOAP_TYPE_PointerTons6__subjectAttributes:
    return soap_out_PointerTons6__subjectAttributes(soap, tag, id, (struct ns6__subjectAttributes *const*)ptr, "ns6:subjectAttributes");
  case SOAP_TYPE_PointerToxsd__boolean_:
    return soap_out_PointerToxsd__boolean_(soap, tag, id, (enum xsd__boolean_ *const*)ptr, "xsd:boolean");
  case SOAP_TYPE_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo:
    return soap_out_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag, id, (struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *const*)ptr, "ns5:CtrlPlaneSwitchingCapabilitySpecificInfo");
  case SOAP_TYPE_PointerTons5__Duration:
    return soap_out_PointerTons5__Duration(soap, tag, id, (struct ns5__Duration *const*)ptr, "ns5:Duration");
  case SOAP_TYPE_PointerTons5__TimeContent:
    return soap_out_PointerTons5__TimeContent(soap, tag, id, (struct ns5__TimeContent *const*)ptr, "ns5:TimeContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneNextHopContent:
    return soap_out_PointerToPointerTons5__CtrlPlaneNextHopContent(soap, tag, id, (struct ns5__CtrlPlaneNextHopContent **const*)ptr, "ns5:CtrlPlaneNextHopContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneNextHopContent:
    return soap_out_PointerTons5__CtrlPlaneNextHopContent(soap, tag, id, (struct ns5__CtrlPlaneNextHopContent *const*)ptr, "ns5:CtrlPlaneNextHopContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneHopContent:
    return soap_out_PointerToPointerTons5__CtrlPlaneHopContent(soap, tag, id, (struct ns5__CtrlPlaneHopContent **const*)ptr, "ns5:CtrlPlaneHopContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneHopContent:
    return soap_out_PointerTons5__CtrlPlaneHopContent(soap, tag, id, (struct ns5__CtrlPlaneHopContent *const*)ptr, "ns5:CtrlPlaneHopContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneSwcapContent:
    return soap_out_PointerTons5__CtrlPlaneSwcapContent(soap, tag, id, (struct ns5__CtrlPlaneSwcapContent *const*)ptr, "ns5:CtrlPlaneSwcapContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneAdministrativeGroup:
    return soap_out_PointerToPointerTons5__CtrlPlaneAdministrativeGroup(soap, tag, id, (struct ns5__CtrlPlaneAdministrativeGroup **const*)ptr, "ns5:CtrlPlaneAdministrativeGroup");
  case SOAP_TYPE_PointerTons5__CtrlPlaneAdministrativeGroup:
    return soap_out_PointerTons5__CtrlPlaneAdministrativeGroup(soap, tag, id, (struct ns5__CtrlPlaneAdministrativeGroup *const*)ptr, "ns5:CtrlPlaneAdministrativeGroup");
  case SOAP_TYPE_PointerTons5__CtrlPlaneAddressContent:
    return soap_out_PointerTons5__CtrlPlaneAddressContent(soap, tag, id, (struct ns5__CtrlPlaneAddressContent *const*)ptr, "ns5:CtrlPlaneAddressContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneLinkContent:
    return soap_out_PointerToPointerTons5__CtrlPlaneLinkContent(soap, tag, id, (struct ns5__CtrlPlaneLinkContent **const*)ptr, "ns5:CtrlPlaneLinkContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneLinkContent:
    return soap_out_PointerTons5__CtrlPlaneLinkContent(soap, tag, id, (struct ns5__CtrlPlaneLinkContent *const*)ptr, "ns5:CtrlPlaneLinkContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlanePortContent:
    return soap_out_PointerToPointerTons5__CtrlPlanePortContent(soap, tag, id, (struct ns5__CtrlPlanePortContent **const*)ptr, "ns5:CtrlPlanePortContent");
  case SOAP_TYPE_PointerTons5__CtrlPlanePortContent:
    return soap_out_PointerTons5__CtrlPlanePortContent(soap, tag, id, (struct ns5__CtrlPlanePortContent *const*)ptr, "ns5:CtrlPlanePortContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneNodeContent:
    return soap_out_PointerToPointerTons5__CtrlPlaneNodeContent(soap, tag, id, (struct ns5__CtrlPlaneNodeContent **const*)ptr, "ns5:CtrlPlaneNodeContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneNodeContent:
    return soap_out_PointerTons5__CtrlPlaneNodeContent(soap, tag, id, (struct ns5__CtrlPlaneNodeContent *const*)ptr, "ns5:CtrlPlaneNodeContent");
  case SOAP_TYPE_PointerTons5__Lifetime:
    return soap_out_PointerTons5__Lifetime(soap, tag, id, (struct ns5__Lifetime *const*)ptr, "ns5:Lifetime");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneDomainSignatureContent:
    return soap_out_PointerToPointerTons5__CtrlPlaneDomainSignatureContent(soap, tag, id, (struct ns5__CtrlPlaneDomainSignatureContent **const*)ptr, "ns5:CtrlPlaneDomainSignatureContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneDomainSignatureContent:
    return soap_out_PointerTons5__CtrlPlaneDomainSignatureContent(soap, tag, id, (struct ns5__CtrlPlaneDomainSignatureContent *const*)ptr, "ns5:CtrlPlaneDomainSignatureContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneDomainContent:
    return soap_out_PointerToPointerTons5__CtrlPlaneDomainContent(soap, tag, id, (struct ns5__CtrlPlaneDomainContent **const*)ptr, "ns5:CtrlPlaneDomainContent");
  case SOAP_TYPE_PointerTons5__CtrlPlaneDomainContent:
    return soap_out_PointerTons5__CtrlPlaneDomainContent(soap, tag, id, (struct ns5__CtrlPlaneDomainContent *const*)ptr, "ns5:CtrlPlaneDomainContent");
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlanePathContent:
    return soap_out_PointerToPointerTons5__CtrlPlanePathContent(soap, tag, id, (struct ns5__CtrlPlanePathContent **const*)ptr, "ns5:CtrlPlanePathContent");
  case SOAP_TYPE_PointerTounsignedInt:
    return soap_out_PointerTounsignedInt(soap, tag, id, (unsigned int *const*)ptr, "xsd:unsignedInt");
  case SOAP_TYPE_PointerTo_ns3__Subscribe_SubscriptionPolicy:
    return soap_out_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, tag, id, (struct _ns3__Subscribe_SubscriptionPolicy *const*)ptr, "ns3:Subscribe-SubscriptionPolicy");
  case SOAP_TYPE_PointerToPointerTons3__NotificationMessageHolderType:
    return soap_out_PointerToPointerTons3__NotificationMessageHolderType(soap, tag, id, (struct ns3__NotificationMessageHolderType **const*)ptr, "ns3:NotificationMessageHolderType");
  case SOAP_TYPE_PointerTons3__NotificationMessageHolderType:
    return soap_out_PointerTons3__NotificationMessageHolderType(soap, tag, id, (struct ns3__NotificationMessageHolderType *const*)ptr, "ns3:NotificationMessageHolderType");
  case SOAP_TYPE_PointerTotime:
    return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
  case SOAP_TYPE_PointerTons3__SubscriptionPolicyType:
    return soap_out_PointerTons3__SubscriptionPolicyType(soap, tag, id, (struct ns3__SubscriptionPolicyType *const*)ptr, "ns3:SubscriptionPolicyType");
  case SOAP_TYPE_PointerTons3__FilterType:
    return soap_out_PointerTons3__FilterType(soap, tag, id, (struct ns3__FilterType *const*)ptr, "ns3:FilterType");
  case SOAP_TYPE_PointerTons3__MessageType:
    return soap_out_PointerTons3__MessageType(soap, tag, id, (struct ns3__MessageType *const*)ptr, "ns3:MessageType");
  case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
    return soap_out_PointerTowsa5__EndpointReferenceType(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:EndpointReferenceType");
  case SOAP_TYPE_PointerToPointerTons3__QueryExpressionType:
    return soap_out_PointerToPointerTons3__QueryExpressionType(soap, tag, id, (struct ns3__QueryExpressionType **const*)ptr, "ns3:QueryExpressionType");
  case SOAP_TYPE_PointerTons3__QueryExpressionType:
    return soap_out_PointerTons3__QueryExpressionType(soap, tag, id, (struct ns3__QueryExpressionType *const*)ptr, "ns3:QueryExpressionType");
  case SOAP_TYPE_PointerToPointerTons3__TopicExpressionType:
    return soap_out_PointerToPointerTons3__TopicExpressionType(soap, tag, id, (struct ns3__TopicExpressionType **const*)ptr, "ns3:TopicExpressionType");
  case SOAP_TYPE_PointerTons3__TopicExpressionType:
    return soap_out_PointerTons3__TopicExpressionType(soap, tag, id, (struct ns3__TopicExpressionType *const*)ptr, "ns3:TopicExpressionType");
  case SOAP_TYPE_PointerTons1__pathInfo:
    return soap_out_PointerTons1__pathInfo(soap, tag, id, (struct ns1__pathInfo *const*)ptr, "ns1:pathInfo");
  case SOAP_TYPE_PointerTons1__optionalConstraintValue:
    return soap_out_PointerTons1__optionalConstraintValue(soap, tag, id, (struct ns1__optionalConstraintValue *const*)ptr, "ns1:optionalConstraintValue");
  case SOAP_TYPE_PointerTons1__localDetails:
    return soap_out_PointerTons1__localDetails(soap, tag, id, (struct ns1__localDetails *const*)ptr, "ns1:localDetails");
  case SOAP_TYPE_PointerTons1__mplsInfo:
    return soap_out_PointerTons1__mplsInfo(soap, tag, id, (struct ns1__mplsInfo *const*)ptr, "ns1:mplsInfo");
  case SOAP_TYPE_PointerTons1__layer3Info:
    return soap_out_PointerTons1__layer3Info(soap, tag, id, (struct ns1__layer3Info *const*)ptr, "ns1:layer3Info");
  case SOAP_TYPE_PointerTons1__layer2Info:
    return soap_out_PointerTons1__layer2Info(soap, tag, id, (struct ns1__layer2Info *const*)ptr, "ns1:layer2Info");
  case SOAP_TYPE_PointerTons5__CtrlPlanePathContent:
    return soap_out_PointerTons5__CtrlPlanePathContent(soap, tag, id, (struct ns5__CtrlPlanePathContent *const*)ptr, "ns5:CtrlPlanePathContent");
  case SOAP_TYPE_PointerToPointerTons1__resDetails:
    return soap_out_PointerToPointerTons1__resDetails(soap, tag, id, (struct ns1__resDetails **const*)ptr, "ns1:resDetails");
  case SOAP_TYPE_PointerToPointerTons1__vlanTag:
    return soap_out_PointerToPointerTons1__vlanTag(soap, tag, id, (struct ns1__vlanTag **const*)ptr, "ns1:vlanTag");
  case SOAP_TYPE_PointerTons1__vlanTag:
    return soap_out_PointerTons1__vlanTag(soap, tag, id, (struct ns1__vlanTag *const*)ptr, "ns1:vlanTag");
  case SOAP_TYPE_PointerTostring:
    return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
  case SOAP_TYPE_PointerTons5__CtrlPlaneTopologyContent:
    return soap_out_PointerTons5__CtrlPlaneTopologyContent(soap, tag, id, (struct ns5__CtrlPlaneTopologyContent *const*)ptr, "ns5:CtrlPlaneTopologyContent");
  case SOAP_TYPE_PointerTons1__resDetails:
    return soap_out_PointerTons1__resDetails(soap, tag, id, (struct ns1__resDetails *const*)ptr, "ns1:resDetails");
  case SOAP_TYPE_PointerToPointerTons1__optionalConstraintType:
    return soap_out_PointerToPointerTons1__optionalConstraintType(soap, tag, id, (struct ns1__optionalConstraintType **const*)ptr, "ns1:optionalConstraintType");
  case SOAP_TYPE_PointerTons1__optionalConstraintType:
    return soap_out_PointerTons1__optionalConstraintType(soap, tag, id, (struct ns1__optionalConstraintType *const*)ptr, "ns1:optionalConstraintType");
  case SOAP_TYPE_PointerTons1__reservedConstraintType:
    return soap_out_PointerTons1__reservedConstraintType(soap, tag, id, (struct ns1__reservedConstraintType *const*)ptr, "ns1:reservedConstraintType");
  case SOAP_TYPE_PointerTons1__userRequestConstraintType:
    return soap_out_PointerTons1__userRequestConstraintType(soap, tag, id, (struct ns1__userRequestConstraintType *const*)ptr, "ns1:userRequestConstraintType");
  case SOAP_TYPE_PointerTons6__messagePropertiesType:
    return soap_out_PointerTons6__messagePropertiesType(soap, tag, id, (struct ns6__messagePropertiesType *const*)ptr, "ns6:messagePropertiesType");
  case SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType:
    return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns3:AbsoluteOrRelativeTimeType");
  case SOAP_TYPE_PointerTo_wsse__Security:
    return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
  case SOAP_TYPE_PointerTods__SignatureType:
    return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
  case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
    return soap_out_PointerToxenc__EncryptedKeyType(soap, tag, id, (struct xenc__EncryptedKeyType *const*)ptr, "xenc:EncryptedKeyType");
  case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
    return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
  case SOAP_TYPE_PointerTo_wsse__UsernameToken:
    return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
  case SOAP_TYPE_PointerTo_wsu__Timestamp:
    return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
  case SOAP_TYPE_PointerTo_wsse__Embedded:
    return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
  case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
    return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
  case SOAP_TYPE_PointerTo_wsse__Reference:
    return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
  case SOAP_TYPE_PointerTo_wsse__Password:
    return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
  case SOAP_TYPE_PointerTo_wsa5__FaultTo:
    return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
  case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
    return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
  case SOAP_TYPE_PointerTo_wsa5__From:
    return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
  case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
    return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
  case SOAP_TYPE__wsa5__ProblemIRI:
    return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)&ptr, NULL);
  case SOAP_TYPE__wsa5__ProblemHeaderQName:
    return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
  case SOAP_TYPE__wsa5__Action:
    return soap_out_string(soap, "wsa5:Action", id, (char*const*)&ptr, NULL);
  case SOAP_TYPE__wsa5__To:
    return soap_out_string(soap, "wsa5:To", id, (char*const*)&ptr, NULL);
  case SOAP_TYPE__wsa5__MessageID:
    return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)&ptr, NULL);
  case SOAP_TYPE_PointerTowsa5__MetadataType:
    return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
  case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
    return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
  case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
    return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa5:FaultCodesOpenEnumType");
  case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
    return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa5:RelationshipTypeOpenEnum");
  case SOAP_TYPE_PointerTo_xenc__ReferenceList:
    return soap_out_PointerTo_xenc__ReferenceList(soap, tag, id, (struct _xenc__ReferenceList *const*)ptr, "xenc:ReferenceList");
  case SOAP_TYPE_PointerToxenc__ReferenceType:
    return soap_out_PointerToxenc__ReferenceType(soap, tag, id, (struct xenc__ReferenceType *const*)ptr, "xenc:ReferenceType");
  case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
    return soap_out_PointerToxenc__EncryptionPropertyType(soap, tag, id, (struct xenc__EncryptionPropertyType *const*)ptr, "xenc:EncryptionPropertyType");
  case SOAP_TYPE_PointerToxenc__TransformsType:
    return soap_out_PointerToxenc__TransformsType(soap, tag, id, (struct xenc__TransformsType *const*)ptr, "xenc:TransformsType");
  case SOAP_TYPE_PointerToxenc__CipherReferenceType:
    return soap_out_PointerToxenc__CipherReferenceType(soap, tag, id, (struct xenc__CipherReferenceType *const*)ptr, "xenc:CipherReferenceType");
  case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
    return soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag, id, (struct xenc__EncryptionPropertiesType *const*)ptr, "xenc:EncryptionPropertiesType");
  case SOAP_TYPE_PointerToxenc__CipherDataType:
    return soap_out_PointerToxenc__CipherDataType(soap, tag, id, (struct xenc__CipherDataType *const*)ptr, "xenc:CipherDataType");
  case SOAP_TYPE_PointerTo_ds__KeyInfo:
    return soap_out_PointerTo_ds__KeyInfo(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfo");
  case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
    return soap_out_PointerToxenc__EncryptionMethodType(soap, tag, id, (struct xenc__EncryptionMethodType *const*)ptr, "xenc:EncryptionMethodType");
  case SOAP_TYPE_PointerTods__X509IssuerSerialType:
    return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
  case SOAP_TYPE_PointerTods__RSAKeyValueType:
    return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
  case SOAP_TYPE_PointerTods__DSAKeyValueType:
    return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
  case SOAP_TYPE_PointerTods__TransformType:
    return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
  case SOAP_TYPE_PointerTods__DigestMethodType:
    return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
  case SOAP_TYPE_PointerTods__TransformsType:
    return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
  case SOAP_TYPE_PointerToint:
    return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
  case SOAP_TYPE_PointerToPointerTods__ReferenceType:
    return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
  case SOAP_TYPE_PointerTods__ReferenceType:
    return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
  case SOAP_TYPE_PointerTods__SignatureMethodType:
    return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
  case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
    return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
  case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
    return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
  case SOAP_TYPE_PointerTods__X509DataType:
    return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
  case SOAP_TYPE_PointerTods__RetrievalMethodType:
    return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
  case SOAP_TYPE_PointerTods__KeyValueType:
    return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
  case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
    return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
  case SOAP_TYPE_PointerTods__KeyInfoType:
    return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
  case SOAP_TYPE_PointerTods__SignedInfoType:
    return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
  case SOAP_TYPE__QName:
    return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
  case SOAP_TYPE_string:
    return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
  }
  return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type) {
  (void)soap;
  (void)ptr;
  (void)type; /* appease -Wall -Werror */
  switch (type) {
  case SOAP_TYPE___ns1__interDomainEvent:
    soap_serialize___ns1__interDomainEvent(soap, (const struct __ns1__interDomainEvent *)ptr);
    break;
  case SOAP_TYPE___ns1__teardownPath:
    soap_serialize___ns1__teardownPath(soap, (const struct __ns1__teardownPath *)ptr);
    break;
  case SOAP_TYPE___ns1__refreshPath:
    soap_serialize___ns1__refreshPath(soap, (const struct __ns1__refreshPath *)ptr);
    break;
  case SOAP_TYPE___ns1__createPath:
    soap_serialize___ns1__createPath(soap, (const struct __ns1__createPath *)ptr);
    break;
  case SOAP_TYPE___ns1__getNetworkTopology:
    soap_serialize___ns1__getNetworkTopology(soap, (const struct __ns1__getNetworkTopology *)ptr);
    break;
  case SOAP_TYPE___ns1__modifyReservation:
    soap_serialize___ns1__modifyReservation(soap, (const struct __ns1__modifyReservation *)ptr);
    break;
  case SOAP_TYPE___ns1__cancelReservation:
    soap_serialize___ns1__cancelReservation(soap, (const struct __ns1__cancelReservation *)ptr);
    break;
  case SOAP_TYPE___ns1__listReservations:
    soap_serialize___ns1__listReservations(soap, (const struct __ns1__listReservations *)ptr);
    break;
  case SOAP_TYPE___ns1__queryReservation:
    soap_serialize___ns1__queryReservation(soap, (const struct __ns1__queryReservation *)ptr);
    break;
  case SOAP_TYPE___ns1__createReservation:
    soap_serialize___ns1__createReservation(soap, (const struct __ns1__createReservation *)ptr);
    break;
  case SOAP_TYPE_ns8__KeyInfoConfirmationDataType:
    soap_serialize_ns8__KeyInfoConfirmationDataType(soap, (const struct ns8__KeyInfoConfirmationDataType *)ptr);
    break;
  case SOAP_TYPE___ns8__union_AttributeStatementType:
    soap_serialize___ns8__union_AttributeStatementType(soap, (const struct __ns8__union_AttributeStatementType *)ptr);
    break;
  case SOAP_TYPE_ns8__ActionType:
    soap_serialize_ns8__ActionType(soap, (const struct ns8__ActionType *)ptr);
    break;
  case SOAP_TYPE_ns4__ResourceUnavailableFaultType:
    soap_serialize_ns4__ResourceUnavailableFaultType(soap, (const struct ns4__ResourceUnavailableFaultType *)ptr);
    break;
  case SOAP_TYPE_ns4__ResourceUnknownFaultType:
    soap_serialize_ns4__ResourceUnknownFaultType(soap, (const struct ns4__ResourceUnknownFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__ResumeFailedFaultType:
    soap_serialize_ns3__ResumeFailedFaultType(soap, (const struct ns3__ResumeFailedFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__PauseFailedFaultType:
    soap_serialize_ns3__PauseFailedFaultType(soap, (const struct ns3__PauseFailedFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType:
    soap_serialize_ns3__UnableToDestroySubscriptionFaultType(soap, (const struct ns3__UnableToDestroySubscriptionFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType:
    soap_serialize_ns3__UnacceptableTerminationTimeFaultType(soap, (const struct ns3__UnacceptableTerminationTimeFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__UnableToCreatePullPointFaultType:
    soap_serialize_ns3__UnableToCreatePullPointFaultType(soap, (const struct ns3__UnableToCreatePullPointFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType:
    soap_serialize_ns3__UnableToDestroyPullPointFaultType(soap, (const struct ns3__UnableToDestroyPullPointFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__UnableToGetMessagesFaultType:
    soap_serialize_ns3__UnableToGetMessagesFaultType(soap, (const struct ns3__UnableToGetMessagesFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType:
    soap_serialize_ns3__NoCurrentMessageOnTopicFaultType(soap, (const struct ns3__NoCurrentMessageOnTopicFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType:
    soap_serialize_ns3__UnacceptableInitialTerminationTimeFaultType(soap, (const struct ns3__UnacceptableInitialTerminationTimeFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType:
    soap_serialize_ns3__NotifyMessageNotSupportedFaultType(soap, (const struct ns3__NotifyMessageNotSupportedFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType:
    soap_serialize_ns3__UnsupportedPolicyRequestFaultType(soap, (const struct ns3__UnsupportedPolicyRequestFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType:
    soap_serialize_ns3__UnrecognizedPolicyRequestFaultType(soap, (const struct ns3__UnrecognizedPolicyRequestFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType:
    soap_serialize_ns3__InvalidMessageContentExpressionFaultType(soap, (const struct ns3__InvalidMessageContentExpressionFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType:
    soap_serialize_ns3__InvalidProducerPropertiesExpressionFaultType(soap, (const struct ns3__InvalidProducerPropertiesExpressionFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType:
    soap_serialize_ns3__MultipleTopicsSpecifiedFaultType(soap, (const struct ns3__MultipleTopicsSpecifiedFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__TopicNotSupportedFaultType:
    soap_serialize_ns3__TopicNotSupportedFaultType(soap, (const struct ns3__TopicNotSupportedFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__InvalidTopicExpressionFaultType:
    soap_serialize_ns3__InvalidTopicExpressionFaultType(soap, (const struct ns3__InvalidTopicExpressionFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType:
    soap_serialize_ns3__TopicExpressionDialectUnknownFaultType(soap, (const struct ns3__TopicExpressionDialectUnknownFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__InvalidFilterFaultType:
    soap_serialize_ns3__InvalidFilterFaultType(soap, (const struct ns3__InvalidFilterFaultType *)ptr);
    break;
  case SOAP_TYPE_ns3__SubscribeCreationFailedFaultType:
    soap_serialize_ns3__SubscribeCreationFailedFaultType(soap, (const struct ns3__SubscribeCreationFailedFaultType *)ptr);
    break;
  case SOAP_TYPE___ns1__reservationResourceType_sequence:
    soap_serialize___ns1__reservationResourceType_sequence(soap, (const struct __ns1__reservationResourceType_sequence *)ptr);
    break;
  case SOAP_TYPE_ns1__reservationResourceType:
    soap_serialize_ns1__reservationResourceType(soap, (const struct ns1__reservationResourceType *)ptr);
    break;
  case SOAP_TYPE___ns8__union_EvidenceType:
    soap_serialize___ns8__union_EvidenceType(soap, (const struct __ns8__union_EvidenceType *)ptr);
    break;
  case SOAP_TYPE_ns8__EvidenceType:
    soap_serialize_ns8__EvidenceType(soap, (const struct ns8__EvidenceType *)ptr);
    break;
  case SOAP_TYPE_ns8__AuthnContextType:
    soap_serialize_ns8__AuthnContextType(soap, (const struct ns8__AuthnContextType *)ptr);
    break;
  case SOAP_TYPE_ns8__SubjectLocalityType:
    soap_serialize_ns8__SubjectLocalityType(soap, (const struct ns8__SubjectLocalityType *)ptr);
    break;
  case SOAP_TYPE___ns8__union_AdviceType:
    soap_serialize___ns8__union_AdviceType(soap, (const struct __ns8__union_AdviceType *)ptr);
    break;
  case SOAP_TYPE_ns8__ProxyRestrictionType:
    soap_serialize_ns8__ProxyRestrictionType(soap, (const struct ns8__ProxyRestrictionType *)ptr);
    break;
  case SOAP_TYPE_ns8__OneTimeUseType:
    soap_serialize_ns8__OneTimeUseType(soap, (const struct ns8__OneTimeUseType *)ptr);
    break;
  case SOAP_TYPE_ns8__AudienceRestrictionType:
    soap_serialize_ns8__AudienceRestrictionType(soap, (const struct ns8__AudienceRestrictionType *)ptr);
    break;
  case SOAP_TYPE_ns8__ConditionAbstractType:
    soap_serialize_ns8__ConditionAbstractType(soap, (const struct ns8__ConditionAbstractType *)ptr);
    break;
  case SOAP_TYPE___ns8__union_ConditionsType:
    soap_serialize___ns8__union_ConditionsType(soap, (const struct __ns8__union_ConditionsType *)ptr);
    break;
  case SOAP_TYPE_ns8__SubjectConfirmationDataType:
    soap_serialize_ns8__SubjectConfirmationDataType(soap, (const struct ns8__SubjectConfirmationDataType *)ptr);
    break;
  case SOAP_TYPE_ns8__SubjectConfirmationType:
    soap_serialize_ns8__SubjectConfirmationType(soap, (const struct ns8__SubjectConfirmationType *)ptr);
    break;
  case SOAP_TYPE_ns8__AttributeStatementType:
    soap_serialize_ns8__AttributeStatementType(soap, (const struct ns8__AttributeStatementType *)ptr);
    break;
  case SOAP_TYPE_ns8__AuthzDecisionStatementType:
    soap_serialize_ns8__AuthzDecisionStatementType(soap, (const struct ns8__AuthzDecisionStatementType *)ptr);
    break;
  case SOAP_TYPE_ns8__AuthnStatementType:
    soap_serialize_ns8__AuthnStatementType(soap, (const struct ns8__AuthnStatementType *)ptr);
    break;
  case SOAP_TYPE_ns8__StatementAbstractType:
    soap_serialize_ns8__StatementAbstractType(soap, (const struct ns8__StatementAbstractType *)ptr);
    break;
  case SOAP_TYPE___ns8__union_AssertionType:
    soap_serialize___ns8__union_AssertionType(soap, (const struct __ns8__union_AssertionType *)ptr);
    break;
  case SOAP_TYPE_ns8__AdviceType:
    soap_serialize_ns8__AdviceType(soap, (const struct ns8__AdviceType *)ptr);
    break;
  case SOAP_TYPE_ns8__ConditionsType:
    soap_serialize_ns8__ConditionsType(soap, (const struct ns8__ConditionsType *)ptr);
    break;
  case SOAP_TYPE_ns8__SubjectType:
    soap_serialize_ns8__SubjectType(soap, (const struct ns8__SubjectType *)ptr);
    break;
  case SOAP_TYPE_ns8__NameIDType:
    soap_serialize_ns8__NameIDType(soap, (const struct ns8__NameIDType *)ptr);
    break;
  case SOAP_TYPE_ns8__AssertionType:
    soap_serialize_ns8__AssertionType(soap, (const struct ns8__AssertionType *)ptr);
    break;
  case SOAP_TYPE_ns8__EncryptedElementType:
    soap_serialize_ns8__EncryptedElementType(soap, (const struct ns8__EncryptedElementType *)ptr);
    break;
  case SOAP_TYPE_ns8__BaseIDAbstractType:
    soap_serialize_ns8__BaseIDAbstractType(soap, (const struct ns8__BaseIDAbstractType *)ptr);
    break;
  case SOAP_TYPE_ns7__FaultCauseType:
    soap_serialize_ns7__FaultCauseType(soap, (const struct ns7__FaultCauseType *)ptr);
    break;
  case SOAP_TYPE_ns7__ErrorCodeType:
    soap_serialize_ns7__ErrorCodeType(soap, (const struct ns7__ErrorCodeType *)ptr);
    break;
  case SOAP_TYPE_ns7__BaseFaultType:
    soap_serialize_ns7__BaseFaultType(soap, (const struct ns7__BaseFaultType *)ptr);
    break;
  case SOAP_TYPE_ns6__authConditionType:
    soap_serialize_ns6__authConditionType(soap, (const struct ns6__authConditionType *)ptr);
    break;
  case SOAP_TYPE_ns6__authConditions:
    soap_serialize_ns6__authConditions(soap, (const struct ns6__authConditions *)ptr);
    break;
  case SOAP_TYPE_ns8__AttributeType:
    soap_serialize_ns8__AttributeType(soap, (const struct ns8__AttributeType *)ptr);
    break;
  case SOAP_TYPE_ns6__subjectAttributes:
    soap_serialize_ns6__subjectAttributes(soap, (const struct ns6__subjectAttributes *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo:
    soap_serialize_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, (const struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *)ptr);
    break;
  case SOAP_TYPE_ns5__Duration:
    soap_serialize_ns5__Duration(soap, (const struct ns5__Duration *)ptr);
    break;
  case SOAP_TYPE_ns5__TimeContent:
    soap_serialize_ns5__TimeContent(soap, (const struct ns5__TimeContent *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlaneNextHopContent:
    soap_serialize_ns5__CtrlPlaneNextHopContent(soap, (const struct ns5__CtrlPlaneNextHopContent *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlaneHopContent:
    soap_serialize_ns5__CtrlPlaneHopContent(soap, (const struct ns5__CtrlPlaneHopContent *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlaneSwcapContent:
    soap_serialize_ns5__CtrlPlaneSwcapContent(soap, (const struct ns5__CtrlPlaneSwcapContent *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlaneAdministrativeGroup:
    soap_serialize_ns5__CtrlPlaneAdministrativeGroup(soap, (const struct ns5__CtrlPlaneAdministrativeGroup *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlaneAddressContent:
    soap_serialize_ns5__CtrlPlaneAddressContent(soap, (const struct ns5__CtrlPlaneAddressContent *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlaneLinkContent:
    soap_serialize_ns5__CtrlPlaneLinkContent(soap, (const struct ns5__CtrlPlaneLinkContent *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlanePortContent:
    soap_serialize_ns5__CtrlPlanePortContent(soap, (const struct ns5__CtrlPlanePortContent *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlaneNodeContent:
    soap_serialize_ns5__CtrlPlaneNodeContent(soap, (const struct ns5__CtrlPlaneNodeContent *)ptr);
    break;
  case SOAP_TYPE_ns5__Lifetime:
    soap_serialize_ns5__Lifetime(soap, (const struct ns5__Lifetime *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlaneDomainSignatureContent:
    soap_serialize_ns5__CtrlPlaneDomainSignatureContent(soap, (const struct ns5__CtrlPlaneDomainSignatureContent *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlaneDomainContent:
    soap_serialize_ns5__CtrlPlaneDomainContent(soap, (const struct ns5__CtrlPlaneDomainContent *)ptr);
    break;
  case SOAP_TYPE__ns3__ResumeSubscriptionResponse:
    soap_serialize__ns3__ResumeSubscriptionResponse(soap, (const struct _ns3__ResumeSubscriptionResponse *)ptr);
    break;
  case SOAP_TYPE__ns3__ResumeSubscription:
    soap_serialize__ns3__ResumeSubscription(soap, (const struct _ns3__ResumeSubscription *)ptr);
    break;
  case SOAP_TYPE__ns3__PauseSubscriptionResponse:
    soap_serialize__ns3__PauseSubscriptionResponse(soap, (const struct _ns3__PauseSubscriptionResponse *)ptr);
    break;
  case SOAP_TYPE__ns3__PauseSubscription:
    soap_serialize__ns3__PauseSubscription(soap, (const struct _ns3__PauseSubscription *)ptr);
    break;
  case SOAP_TYPE__ns3__UnsubscribeResponse:
    soap_serialize__ns3__UnsubscribeResponse(soap, (const struct _ns3__UnsubscribeResponse *)ptr);
    break;
  case SOAP_TYPE__ns3__Unsubscribe:
    soap_serialize__ns3__Unsubscribe(soap, (const struct _ns3__Unsubscribe *)ptr);
    break;
  case SOAP_TYPE__ns3__RenewResponse:
    soap_serialize__ns3__RenewResponse(soap, (const struct _ns3__RenewResponse *)ptr);
    break;
  case SOAP_TYPE__ns3__Renew:
    soap_serialize__ns3__Renew(soap, (const struct _ns3__Renew *)ptr);
    break;
  case SOAP_TYPE__ns3__CreatePullPointResponse:
    soap_serialize__ns3__CreatePullPointResponse(soap, (const struct _ns3__CreatePullPointResponse *)ptr);
    break;
  case SOAP_TYPE__ns3__CreatePullPoint:
    soap_serialize__ns3__CreatePullPoint(soap, (const struct _ns3__CreatePullPoint *)ptr);
    break;
  case SOAP_TYPE__ns3__DestroyPullPointResponse:
    soap_serialize__ns3__DestroyPullPointResponse(soap, (const struct _ns3__DestroyPullPointResponse *)ptr);
    break;
  case SOAP_TYPE__ns3__DestroyPullPoint:
    soap_serialize__ns3__DestroyPullPoint(soap, (const struct _ns3__DestroyPullPoint *)ptr);
    break;
  case SOAP_TYPE__ns3__GetMessagesResponse:
    soap_serialize__ns3__GetMessagesResponse(soap, (const struct _ns3__GetMessagesResponse *)ptr);
    break;
  case SOAP_TYPE__ns3__GetMessages:
    soap_serialize__ns3__GetMessages(soap, (const struct _ns3__GetMessages *)ptr);
    break;
  case SOAP_TYPE__ns3__GetCurrentMessageResponse:
    soap_serialize__ns3__GetCurrentMessageResponse(soap, (const struct _ns3__GetCurrentMessageResponse *)ptr);
    break;
  case SOAP_TYPE__ns3__GetCurrentMessage:
    soap_serialize__ns3__GetCurrentMessage(soap, (const struct _ns3__GetCurrentMessage *)ptr);
    break;
  case SOAP_TYPE__ns3__SubscribeResponse:
    soap_serialize__ns3__SubscribeResponse(soap, (const struct _ns3__SubscribeResponse *)ptr);
    break;
  case SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy:
    soap_serialize__ns3__Subscribe_SubscriptionPolicy(soap, (const struct _ns3__Subscribe_SubscriptionPolicy *)ptr);
    break;
  case SOAP_TYPE__ns3__Subscribe:
    soap_serialize__ns3__Subscribe(soap, (const struct _ns3__Subscribe *)ptr);
    break;
  case SOAP_TYPE__ns3__UseRaw:
    soap_serialize__ns3__UseRaw(soap, (const struct _ns3__UseRaw *)ptr);
    break;
  case SOAP_TYPE__ns3__Notify:
    soap_serialize__ns3__Notify(soap, (const struct _ns3__Notify *)ptr);
    break;
  case SOAP_TYPE__ns3__SubscriptionManagerRP:
    soap_serialize__ns3__SubscriptionManagerRP(soap, (const struct _ns3__SubscriptionManagerRP *)ptr);
    break;
  case SOAP_TYPE_ns3__MessageType:
    soap_serialize_ns3__MessageType(soap, (const struct ns3__MessageType *)ptr);
    break;
  case SOAP_TYPE_ns3__NotificationMessageHolderType:
    soap_serialize_ns3__NotificationMessageHolderType(soap, (const struct ns3__NotificationMessageHolderType *)ptr);
    break;
  case SOAP_TYPE_ns3__SubscriptionPolicyType:
    soap_serialize_ns3__SubscriptionPolicyType(soap, (const struct ns3__SubscriptionPolicyType *)ptr);
    break;
  case SOAP_TYPE_ns3__QueryExpressionType:
    soap_serialize_ns3__QueryExpressionType(soap, (const struct ns3__QueryExpressionType *)ptr);
    break;
  case SOAP_TYPE_ns3__TopicExpressionType:
    soap_serialize_ns3__TopicExpressionType(soap, (const struct ns3__TopicExpressionType *)ptr);
    break;
  case SOAP_TYPE_ns3__FilterType:
    soap_serialize_ns3__FilterType(soap, (const struct ns3__FilterType *)ptr);
    break;
  case SOAP_TYPE__ns2__OSCARSFault:
    soap_serialize__ns2__OSCARSFault(soap, (const struct _ns2__OSCARSFault *)ptr);
    break;
  case SOAP_TYPE_ns2__emptyArg:
    soap_serialize_ns2__emptyArg(soap, (const struct ns2__emptyArg *)ptr);
    break;
  case SOAP_TYPE_ns1__optionalConstraintValue:
    soap_serialize_ns1__optionalConstraintValue(soap, (const struct ns1__optionalConstraintValue *)ptr);
    break;
  case SOAP_TYPE_ns1__globalReservationId:
    soap_serialize_ns1__globalReservationId(soap, (const struct ns1__globalReservationId *)ptr);
    break;
  case SOAP_TYPE_ns1__localDetails:
    soap_serialize_ns1__localDetails(soap, (const struct ns1__localDetails *)ptr);
    break;
  case SOAP_TYPE_ns1__eventContent:
    soap_serialize_ns1__eventContent(soap, (const struct ns1__eventContent *)ptr);
    break;
  case SOAP_TYPE_ns1__interDomainEventContent:
    soap_serialize_ns1__interDomainEventContent(soap, (const struct ns1__interDomainEventContent *)ptr);
    break;
  case SOAP_TYPE_ns1__mplsInfo:
    soap_serialize_ns1__mplsInfo(soap, (const struct ns1__mplsInfo *)ptr);
    break;
  case SOAP_TYPE_ns1__layer3Info:
    soap_serialize_ns1__layer3Info(soap, (const struct ns1__layer3Info *)ptr);
    break;
  case SOAP_TYPE_ns1__layer2Info:
    soap_serialize_ns1__layer2Info(soap, (const struct ns1__layer2Info *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlanePathContent:
    soap_serialize_ns5__CtrlPlanePathContent(soap, (const struct ns5__CtrlPlanePathContent *)ptr);
    break;
  case SOAP_TYPE_ns1__pathInfo:
    soap_serialize_ns1__pathInfo(soap, (const struct ns1__pathInfo *)ptr);
    break;
  case SOAP_TYPE_ns1__listReply:
    soap_serialize_ns1__listReply(soap, (const struct ns1__listReply *)ptr);
    break;
  case SOAP_TYPE_ns1__vlanTag:
    soap_serialize_ns1__vlanTag(soap, (const struct ns1__vlanTag *)ptr);
    break;
  case SOAP_TYPE___ns1__listRequest_sequence:
    soap_serialize___ns1__listRequest_sequence(soap, (const struct __ns1__listRequest_sequence *)ptr);
    break;
  case SOAP_TYPE_ns1__listRequest:
    soap_serialize_ns1__listRequest(soap, (const struct ns1__listRequest *)ptr);
    break;
  case SOAP_TYPE_ns1__teardownPathResponseContent:
    soap_serialize_ns1__teardownPathResponseContent(soap, (const struct ns1__teardownPathResponseContent *)ptr);
    break;
  case SOAP_TYPE_ns1__teardownPathContent:
    soap_serialize_ns1__teardownPathContent(soap, (const struct ns1__teardownPathContent *)ptr);
    break;
  case SOAP_TYPE_ns1__refreshPathResponseContent:
    soap_serialize_ns1__refreshPathResponseContent(soap, (const struct ns1__refreshPathResponseContent *)ptr);
    break;
  case SOAP_TYPE_ns1__refreshPathContent:
    soap_serialize_ns1__refreshPathContent(soap, (const struct ns1__refreshPathContent *)ptr);
    break;
  case SOAP_TYPE_ns1__createPathResponseContent:
    soap_serialize_ns1__createPathResponseContent(soap, (const struct ns1__createPathResponseContent *)ptr);
    break;
  case SOAP_TYPE_ns1__createPathContent:
    soap_serialize_ns1__createPathContent(soap, (const struct ns1__createPathContent *)ptr);
    break;
  case SOAP_TYPE_ns5__CtrlPlaneTopologyContent:
    soap_serialize_ns5__CtrlPlaneTopologyContent(soap, (const struct ns5__CtrlPlaneTopologyContent *)ptr);
    break;
  case SOAP_TYPE_ns1__getTopologyResponseContent:
    soap_serialize_ns1__getTopologyResponseContent(soap, (const struct ns1__getTopologyResponseContent *)ptr);
    break;
  case SOAP_TYPE_ns1__getTopologyContent:
    soap_serialize_ns1__getTopologyContent(soap, (const struct ns1__getTopologyContent *)ptr);
    break;
  case SOAP_TYPE_ns1__modifyResReply:
    soap_serialize_ns1__modifyResReply(soap, (const struct ns1__modifyResReply *)ptr);
    break;
  case SOAP_TYPE_ns1__modifyResContent:
    soap_serialize_ns1__modifyResContent(soap, (const struct ns1__modifyResContent *)ptr);
    break;
  case SOAP_TYPE_ns1__resDetails:
    soap_serialize_ns1__resDetails(soap, (const struct ns1__resDetails *)ptr);
    break;
  case SOAP_TYPE_ns1__queryResReply:
    soap_serialize_ns1__queryResReply(soap, (const struct ns1__queryResReply *)ptr);
    break;
  case SOAP_TYPE_ns1__queryResContent:
    soap_serialize_ns1__queryResContent(soap, (const struct ns1__queryResContent *)ptr);
    break;
  case SOAP_TYPE_ns1__cancelResReply:
    soap_serialize_ns1__cancelResReply(soap, (const struct ns1__cancelResReply *)ptr);
    break;
  case SOAP_TYPE_ns1__cancelResContent:
    soap_serialize_ns1__cancelResContent(soap, (const struct ns1__cancelResContent *)ptr);
    break;
  case SOAP_TYPE_ns1__createReply:
    soap_serialize_ns1__createReply(soap, (const struct ns1__createReply *)ptr);
    break;
  case SOAP_TYPE_ns1__optionalConstraintType:
    soap_serialize_ns1__optionalConstraintType(soap, (const struct ns1__optionalConstraintType *)ptr);
    break;
  case SOAP_TYPE_ns1__reservedConstraintType:
    soap_serialize_ns1__reservedConstraintType(soap, (const struct ns1__reservedConstraintType *)ptr);
    break;
  case SOAP_TYPE_ns1__userRequestConstraintType:
    soap_serialize_ns1__userRequestConstraintType(soap, (const struct ns1__userRequestConstraintType *)ptr);
    break;
  case SOAP_TYPE_ns6__messagePropertiesType:
    soap_serialize_ns6__messagePropertiesType(soap, (const struct ns6__messagePropertiesType *)ptr);
    break;
  case SOAP_TYPE_ns1__resCreateContent:
    soap_serialize_ns1__resCreateContent(soap, (const struct ns1__resCreateContent *)ptr);
    break;
  case SOAP_TYPE__wsse__Security:
    soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
    break;
  case SOAP_TYPE__wsse__KeyIdentifier:
    soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
    break;
  case SOAP_TYPE__wsse__Embedded:
    soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
    break;
  case SOAP_TYPE__wsse__Reference:
    soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
    break;
  case SOAP_TYPE__wsse__BinarySecurityToken:
    soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
    break;
  case SOAP_TYPE__wsse__Password:
    soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
    break;
  case SOAP_TYPE__wsse__UsernameToken:
    soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
    break;
  case SOAP_TYPE__wsu__Timestamp:
    soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
    break;
  case SOAP_TYPE__wsa5__ProblemAction:
    soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
    break;
  case SOAP_TYPE__wsa5__FaultTo:
    soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
    break;
  case SOAP_TYPE__wsa5__From:
    soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
    break;
  case SOAP_TYPE__wsa5__ReplyTo:
    soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
    break;
  case SOAP_TYPE__wsa5__RelatesTo:
    soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
    break;
  case SOAP_TYPE__wsa5__Metadata:
    soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
    break;
  case SOAP_TYPE__wsa5__ReferenceParameters:
    soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
    break;
  case SOAP_TYPE__wsa5__EndpointReference:
    soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
    break;
  case SOAP_TYPE_wsa5__ProblemActionType:
    soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
    break;
  case SOAP_TYPE_wsa5__RelatesToType:
    soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
    break;
  case SOAP_TYPE_wsa5__MetadataType:
    soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
    break;
  case SOAP_TYPE_wsa5__ReferenceParametersType:
    soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
    break;
  case SOAP_TYPE_wsa5__EndpointReferenceType:
    soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
    break;
  case SOAP_TYPE__xenc__EncryptionProperty:
    soap_serialize__xenc__EncryptionProperty(soap, (const struct xenc__EncryptionPropertyType *)ptr);
    break;
  case SOAP_TYPE__xenc__EncryptionProperties:
    soap_serialize__xenc__EncryptionProperties(soap, (const struct xenc__EncryptionPropertiesType *)ptr);
    break;
  case SOAP_TYPE__xenc__AgreementMethod:
    soap_serialize__xenc__AgreementMethod(soap, (const struct xenc__AgreementMethodType *)ptr);
    break;
  case SOAP_TYPE__xenc__EncryptedKey:
    soap_serialize__xenc__EncryptedKey(soap, (const struct xenc__EncryptedKeyType *)ptr);
    break;
  case SOAP_TYPE__xenc__EncryptedData:
    soap_serialize__xenc__EncryptedData(soap, (const struct xenc__EncryptedDataType *)ptr);
    break;
  case SOAP_TYPE__xenc__CipherReference:
    soap_serialize__xenc__CipherReference(soap, (const struct xenc__CipherReferenceType *)ptr);
    break;
  case SOAP_TYPE__xenc__CipherData:
    soap_serialize__xenc__CipherData(soap, (const struct xenc__CipherDataType *)ptr);
    break;
  case SOAP_TYPE___xenc__union_ReferenceList:
    soap_serialize___xenc__union_ReferenceList(soap, (const struct __xenc__union_ReferenceList *)ptr);
    break;
  case SOAP_TYPE__xenc__ReferenceList:
    soap_serialize__xenc__ReferenceList(soap, (const struct _xenc__ReferenceList *)ptr);
    break;
  case SOAP_TYPE_xenc__EncryptionPropertyType:
    soap_serialize_xenc__EncryptionPropertyType(soap, (const struct xenc__EncryptionPropertyType *)ptr);
    break;
  case SOAP_TYPE_xenc__EncryptionPropertiesType:
    soap_serialize_xenc__EncryptionPropertiesType(soap, (const struct xenc__EncryptionPropertiesType *)ptr);
    break;
  case SOAP_TYPE_xenc__ReferenceType:
    soap_serialize_xenc__ReferenceType(soap, (const struct xenc__ReferenceType *)ptr);
    break;
  case SOAP_TYPE_xenc__AgreementMethodType:
    soap_serialize_xenc__AgreementMethodType(soap, (const struct xenc__AgreementMethodType *)ptr);
    break;
  case SOAP_TYPE_xenc__EncryptedKeyType:
    soap_serialize_xenc__EncryptedKeyType(soap, (const struct xenc__EncryptedKeyType *)ptr);
    break;
  case SOAP_TYPE_xenc__EncryptedDataType:
    soap_serialize_xenc__EncryptedDataType(soap, (const struct xenc__EncryptedDataType *)ptr);
    break;
  case SOAP_TYPE_xenc__TransformsType:
    soap_serialize_xenc__TransformsType(soap, (const struct xenc__TransformsType *)ptr);
    break;
  case SOAP_TYPE_xenc__CipherReferenceType:
    soap_serialize_xenc__CipherReferenceType(soap, (const struct xenc__CipherReferenceType *)ptr);
    break;
  case SOAP_TYPE_xenc__CipherDataType:
    soap_serialize_xenc__CipherDataType(soap, (const struct xenc__CipherDataType *)ptr);
    break;
  case SOAP_TYPE_xenc__EncryptionMethodType:
    soap_serialize_xenc__EncryptionMethodType(soap, (const struct xenc__EncryptionMethodType *)ptr);
    break;
  case SOAP_TYPE_xenc__EncryptedType:
    soap_serialize_xenc__EncryptedType(soap, (const struct xenc__EncryptedType *)ptr);
    break;
  case SOAP_TYPE_ds__RSAKeyValueType:
    soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
    break;
  case SOAP_TYPE_ds__DSAKeyValueType:
    soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
    break;
  case SOAP_TYPE_ds__X509IssuerSerialType:
    soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
    break;
  case SOAP_TYPE__ds__KeyInfo:
    soap_serialize__ds__KeyInfo(soap, (const struct ds__KeyInfoType *)ptr);
    break;
  case SOAP_TYPE__wsse__SecurityTokenReference:
    soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
    break;
  case SOAP_TYPE_ds__X509DataType:
    soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
    break;
  case SOAP_TYPE_ds__RetrievalMethodType:
    soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
    break;
  case SOAP_TYPE_ds__KeyValueType:
    soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
    break;
  case SOAP_TYPE_ds__DigestMethodType:
    soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
    break;
  case SOAP_TYPE__ds__Transform:
    soap_serialize__ds__Transform(soap, (const struct ds__TransformType *)ptr);
    break;
  case SOAP_TYPE_ds__TransformType:
    soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
    break;
  case SOAP_TYPE__c14n__InclusiveNamespaces:
    soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
    break;
  case SOAP_TYPE_ds__TransformsType:
    soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
    break;
  case SOAP_TYPE_ds__ReferenceType:
    soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
    break;
  case SOAP_TYPE_ds__SignatureMethodType:
    soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
    break;
  case SOAP_TYPE_ds__CanonicalizationMethodType:
    soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
    break;
  case SOAP_TYPE__ds__Signature:
    soap_serialize__ds__Signature(soap, (const struct ds__SignatureType *)ptr);
    break;
  case SOAP_TYPE_ds__KeyInfoType:
    soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
    break;
  case SOAP_TYPE_ds__SignedInfoType:
    soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
    break;
  case SOAP_TYPE_ds__SignatureType:
    soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
    break;
  case SOAP_TYPE_PointerTons1__interDomainEventContent:
    soap_serialize_PointerTons1__interDomainEventContent(soap, (struct ns1__interDomainEventContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__teardownPathResponseContent:
    soap_serialize_PointerTons1__teardownPathResponseContent(soap, (struct ns1__teardownPathResponseContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__teardownPathContent:
    soap_serialize_PointerTons1__teardownPathContent(soap, (struct ns1__teardownPathContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__refreshPathResponseContent:
    soap_serialize_PointerTons1__refreshPathResponseContent(soap, (struct ns1__refreshPathResponseContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__refreshPathContent:
    soap_serialize_PointerTons1__refreshPathContent(soap, (struct ns1__refreshPathContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__createPathResponseContent:
    soap_serialize_PointerTons1__createPathResponseContent(soap, (struct ns1__createPathResponseContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__createPathContent:
    soap_serialize_PointerTons1__createPathContent(soap, (struct ns1__createPathContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__getTopologyResponseContent:
    soap_serialize_PointerTons1__getTopologyResponseContent(soap, (struct ns1__getTopologyResponseContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__getTopologyContent:
    soap_serialize_PointerTons1__getTopologyContent(soap, (struct ns1__getTopologyContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__modifyResReply:
    soap_serialize_PointerTons1__modifyResReply(soap, (struct ns1__modifyResReply *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__modifyResContent:
    soap_serialize_PointerTons1__modifyResContent(soap, (struct ns1__modifyResContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__cancelResReply:
    soap_serialize_PointerTons1__cancelResReply(soap, (struct ns1__cancelResReply *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__cancelResContent:
    soap_serialize_PointerTons1__cancelResContent(soap, (struct ns1__cancelResContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__listReply:
    soap_serialize_PointerTons1__listReply(soap, (struct ns1__listReply *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__listRequest:
    soap_serialize_PointerTons1__listRequest(soap, (struct ns1__listRequest *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__queryResReply:
    soap_serialize_PointerTons1__queryResReply(soap, (struct ns1__queryResReply *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__queryResContent:
    soap_serialize_PointerTons1__queryResContent(soap, (struct ns1__queryResContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__createReply:
    soap_serialize_PointerTons1__createReply(soap, (struct ns1__createReply *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__resCreateContent:
    soap_serialize_PointerTons1__resCreateContent(soap, (struct ns1__resCreateContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_ns2__OSCARSFault:
    soap_serialize_PointerTo_ns2__OSCARSFault(soap, (struct _ns2__OSCARSFault *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo__ns8__union_AttributeStatementType:
    soap_serialize_PointerTo__ns8__union_AttributeStatementType(soap, (struct __ns8__union_AttributeStatementType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__EvidenceType:
    soap_serialize_PointerTons8__EvidenceType(soap, (struct ns8__EvidenceType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons8__ActionType:
    soap_serialize_PointerToPointerTons8__ActionType(soap, (struct ns8__ActionType **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__ActionType:
    soap_serialize_PointerTons8__ActionType(soap, (struct ns8__ActionType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__AuthnContextType:
    soap_serialize_PointerTons8__AuthnContextType(soap, (struct ns8__AuthnContextType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__SubjectLocalityType:
    soap_serialize_PointerTons8__SubjectLocalityType(soap, (struct ns8__SubjectLocalityType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_QName:
    soap_serialize_PointerTo_QName(soap, (char **const*)ptr);
    break;
  case SOAP_TYPE_PointerTo__ns1__reservationResourceType_sequence:
    soap_serialize_PointerTo__ns1__reservationResourceType_sequence(soap, (struct __ns1__reservationResourceType_sequence *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo__ns8__union_EvidenceType:
    soap_serialize_PointerTo__ns8__union_EvidenceType(soap, (struct __ns8__union_EvidenceType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo__ns8__union_AdviceType:
    soap_serialize_PointerTo__ns8__union_AdviceType(soap, (struct __ns8__union_AdviceType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__AssertionType:
    soap_serialize_PointerTons8__AssertionType(soap, (struct ns8__AssertionType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo__ns8__union_ConditionsType:
    soap_serialize_PointerTo__ns8__union_ConditionsType(soap, (struct __ns8__union_ConditionsType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__ProxyRestrictionType:
    soap_serialize_PointerTons8__ProxyRestrictionType(soap, (struct ns8__ProxyRestrictionType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__OneTimeUseType:
    soap_serialize_PointerTons8__OneTimeUseType(soap, (struct ns8__OneTimeUseType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__AudienceRestrictionType:
    soap_serialize_PointerTons8__AudienceRestrictionType(soap, (struct ns8__AudienceRestrictionType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__ConditionAbstractType:
    soap_serialize_PointerTons8__ConditionAbstractType(soap, (struct ns8__ConditionAbstractType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__SubjectConfirmationDataType:
    soap_serialize_PointerTons8__SubjectConfirmationDataType(soap, (struct ns8__SubjectConfirmationDataType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons8__SubjectConfirmationType:
    soap_serialize_PointerToPointerTons8__SubjectConfirmationType(soap, (struct ns8__SubjectConfirmationType **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__SubjectConfirmationType:
    soap_serialize_PointerTons8__SubjectConfirmationType(soap, (struct ns8__SubjectConfirmationType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__EncryptedElementType:
    soap_serialize_PointerTons8__EncryptedElementType(soap, (struct ns8__EncryptedElementType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__BaseIDAbstractType:
    soap_serialize_PointerTons8__BaseIDAbstractType(soap, (struct ns8__BaseIDAbstractType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo__ns8__union_AssertionType:
    soap_serialize_PointerTo__ns8__union_AssertionType(soap, (struct __ns8__union_AssertionType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__AttributeStatementType:
    soap_serialize_PointerTons8__AttributeStatementType(soap, (struct ns8__AttributeStatementType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__AuthzDecisionStatementType:
    soap_serialize_PointerTons8__AuthzDecisionStatementType(soap, (struct ns8__AuthzDecisionStatementType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__AuthnStatementType:
    soap_serialize_PointerTons8__AuthnStatementType(soap, (struct ns8__AuthnStatementType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__StatementAbstractType:
    soap_serialize_PointerTons8__StatementAbstractType(soap, (struct ns8__StatementAbstractType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__AdviceType:
    soap_serialize_PointerTons8__AdviceType(soap, (struct ns8__AdviceType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__ConditionsType:
    soap_serialize_PointerTons8__ConditionsType(soap, (struct ns8__ConditionsType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__SubjectType:
    soap_serialize_PointerTons8__SubjectType(soap, (struct ns8__SubjectType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_ds__Signature:
    soap_serialize_PointerTo_ds__Signature(soap, (struct ds__SignatureType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__NameIDType:
    soap_serialize_PointerTons8__NameIDType(soap, (struct ns8__NameIDType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_xenc__EncryptedKey:
    soap_serialize_PointerTo_xenc__EncryptedKey(soap, (struct xenc__EncryptedKeyType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons7__FaultCauseType:
    soap_serialize_PointerTons7__FaultCauseType(soap, (struct ns7__FaultCauseType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons7__ErrorCodeType:
    soap_serialize_PointerTons7__ErrorCodeType(soap, (struct ns7__ErrorCodeType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons6__authConditionType:
    soap_serialize_PointerToPointerTons6__authConditionType(soap, (struct ns6__authConditionType **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons6__authConditionType:
    soap_serialize_PointerTons6__authConditionType(soap, (struct ns6__authConditionType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons8__AttributeType:
    soap_serialize_PointerToPointerTons8__AttributeType(soap, (struct ns8__AttributeType **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons8__AttributeType:
    soap_serialize_PointerTons8__AttributeType(soap, (struct ns8__AttributeType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons6__subjectAttributes:
    soap_serialize_PointerTons6__subjectAttributes(soap, (struct ns6__subjectAttributes *const*)ptr);
    break;
  case SOAP_TYPE_PointerToxsd__boolean_:
    soap_serialize_PointerToxsd__boolean_(soap, (enum xsd__boolean_ *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo:
    soap_serialize_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, (struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__Duration:
    soap_serialize_PointerTons5__Duration(soap, (struct ns5__Duration *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__TimeContent:
    soap_serialize_PointerTons5__TimeContent(soap, (struct ns5__TimeContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneNextHopContent:
    soap_serialize_PointerToPointerTons5__CtrlPlaneNextHopContent(soap, (struct ns5__CtrlPlaneNextHopContent **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlaneNextHopContent:
    soap_serialize_PointerTons5__CtrlPlaneNextHopContent(soap, (struct ns5__CtrlPlaneNextHopContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneHopContent:
    soap_serialize_PointerToPointerTons5__CtrlPlaneHopContent(soap, (struct ns5__CtrlPlaneHopContent **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlaneHopContent:
    soap_serialize_PointerTons5__CtrlPlaneHopContent(soap, (struct ns5__CtrlPlaneHopContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlaneSwcapContent:
    soap_serialize_PointerTons5__CtrlPlaneSwcapContent(soap, (struct ns5__CtrlPlaneSwcapContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneAdministrativeGroup:
    soap_serialize_PointerToPointerTons5__CtrlPlaneAdministrativeGroup(soap, (struct ns5__CtrlPlaneAdministrativeGroup **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlaneAdministrativeGroup:
    soap_serialize_PointerTons5__CtrlPlaneAdministrativeGroup(soap, (struct ns5__CtrlPlaneAdministrativeGroup *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlaneAddressContent:
    soap_serialize_PointerTons5__CtrlPlaneAddressContent(soap, (struct ns5__CtrlPlaneAddressContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneLinkContent:
    soap_serialize_PointerToPointerTons5__CtrlPlaneLinkContent(soap, (struct ns5__CtrlPlaneLinkContent **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlaneLinkContent:
    soap_serialize_PointerTons5__CtrlPlaneLinkContent(soap, (struct ns5__CtrlPlaneLinkContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlanePortContent:
    soap_serialize_PointerToPointerTons5__CtrlPlanePortContent(soap, (struct ns5__CtrlPlanePortContent **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlanePortContent:
    soap_serialize_PointerTons5__CtrlPlanePortContent(soap, (struct ns5__CtrlPlanePortContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneNodeContent:
    soap_serialize_PointerToPointerTons5__CtrlPlaneNodeContent(soap, (struct ns5__CtrlPlaneNodeContent **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlaneNodeContent:
    soap_serialize_PointerTons5__CtrlPlaneNodeContent(soap, (struct ns5__CtrlPlaneNodeContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__Lifetime:
    soap_serialize_PointerTons5__Lifetime(soap, (struct ns5__Lifetime *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneDomainSignatureContent:
    soap_serialize_PointerToPointerTons5__CtrlPlaneDomainSignatureContent(soap, (struct ns5__CtrlPlaneDomainSignatureContent **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlaneDomainSignatureContent:
    soap_serialize_PointerTons5__CtrlPlaneDomainSignatureContent(soap, (struct ns5__CtrlPlaneDomainSignatureContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlaneDomainContent:
    soap_serialize_PointerToPointerTons5__CtrlPlaneDomainContent(soap, (struct ns5__CtrlPlaneDomainContent **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlaneDomainContent:
    soap_serialize_PointerTons5__CtrlPlaneDomainContent(soap, (struct ns5__CtrlPlaneDomainContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons5__CtrlPlanePathContent:
    soap_serialize_PointerToPointerTons5__CtrlPlanePathContent(soap, (struct ns5__CtrlPlanePathContent **const*)ptr);
    break;
  case SOAP_TYPE_PointerTounsignedInt:
    soap_serialize_PointerTounsignedInt(soap, (unsigned int *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_ns3__Subscribe_SubscriptionPolicy:
    soap_serialize_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, (struct _ns3__Subscribe_SubscriptionPolicy *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons3__NotificationMessageHolderType:
    soap_serialize_PointerToPointerTons3__NotificationMessageHolderType(soap, (struct ns3__NotificationMessageHolderType **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons3__NotificationMessageHolderType:
    soap_serialize_PointerTons3__NotificationMessageHolderType(soap, (struct ns3__NotificationMessageHolderType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTotime:
    soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons3__SubscriptionPolicyType:
    soap_serialize_PointerTons3__SubscriptionPolicyType(soap, (struct ns3__SubscriptionPolicyType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons3__FilterType:
    soap_serialize_PointerTons3__FilterType(soap, (struct ns3__FilterType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons3__MessageType:
    soap_serialize_PointerTons3__MessageType(soap, (struct ns3__MessageType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
    soap_serialize_PointerTowsa5__EndpointReferenceType(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons3__QueryExpressionType:
    soap_serialize_PointerToPointerTons3__QueryExpressionType(soap, (struct ns3__QueryExpressionType **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons3__QueryExpressionType:
    soap_serialize_PointerTons3__QueryExpressionType(soap, (struct ns3__QueryExpressionType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons3__TopicExpressionType:
    soap_serialize_PointerToPointerTons3__TopicExpressionType(soap, (struct ns3__TopicExpressionType **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons3__TopicExpressionType:
    soap_serialize_PointerTons3__TopicExpressionType(soap, (struct ns3__TopicExpressionType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__pathInfo:
    soap_serialize_PointerTons1__pathInfo(soap, (struct ns1__pathInfo *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__optionalConstraintValue:
    soap_serialize_PointerTons1__optionalConstraintValue(soap, (struct ns1__optionalConstraintValue *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__localDetails:
    soap_serialize_PointerTons1__localDetails(soap, (struct ns1__localDetails *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__mplsInfo:
    soap_serialize_PointerTons1__mplsInfo(soap, (struct ns1__mplsInfo *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__layer3Info:
    soap_serialize_PointerTons1__layer3Info(soap, (struct ns1__layer3Info *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__layer2Info:
    soap_serialize_PointerTons1__layer2Info(soap, (struct ns1__layer2Info *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlanePathContent:
    soap_serialize_PointerTons5__CtrlPlanePathContent(soap, (struct ns5__CtrlPlanePathContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons1__resDetails:
    soap_serialize_PointerToPointerTons1__resDetails(soap, (struct ns1__resDetails **const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons1__vlanTag:
    soap_serialize_PointerToPointerTons1__vlanTag(soap, (struct ns1__vlanTag **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__vlanTag:
    soap_serialize_PointerTons1__vlanTag(soap, (struct ns1__vlanTag *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo__ns1__listRequest_sequence:
    soap_serialize_PointerTo__ns1__listRequest_sequence(soap, (struct __ns1__listRequest_sequence *const*)ptr);
    break;
  case SOAP_TYPE_PointerTostring:
    soap_serialize_PointerTostring(soap, (char **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons5__CtrlPlaneTopologyContent:
    soap_serialize_PointerTons5__CtrlPlaneTopologyContent(soap, (struct ns5__CtrlPlaneTopologyContent *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__resDetails:
    soap_serialize_PointerTons1__resDetails(soap, (struct ns1__resDetails *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTons1__optionalConstraintType:
    soap_serialize_PointerToPointerTons1__optionalConstraintType(soap, (struct ns1__optionalConstraintType **const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__optionalConstraintType:
    soap_serialize_PointerTons1__optionalConstraintType(soap, (struct ns1__optionalConstraintType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__reservedConstraintType:
    soap_serialize_PointerTons1__reservedConstraintType(soap, (struct ns1__reservedConstraintType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons1__userRequestConstraintType:
    soap_serialize_PointerTons1__userRequestConstraintType(soap, (struct ns1__userRequestConstraintType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTons6__messagePropertiesType:
    soap_serialize_PointerTons6__messagePropertiesType(soap, (struct ns6__messagePropertiesType *const*)ptr);
    break;
  case SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType:
    soap_serialize_string(soap, (char*const*)&ptr);
    break;
  case SOAP_TYPE_PointerTo_wsse__Security:
    soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__SignatureType:
    soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
    soap_serialize_PointerToxenc__EncryptedKeyType(soap, (struct xenc__EncryptedKeyType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
    soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_wsse__UsernameToken:
    soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_wsu__Timestamp:
    soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_wsse__Embedded:
    soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
    soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_wsse__Reference:
    soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_wsse__Password:
    soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_wsa5__FaultTo:
    soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
    soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_wsa5__From:
    soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
    soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
    break;
  case SOAP_TYPE__wsa5__ProblemIRI:
    soap_serialize_string(soap, (char*const*)&ptr);
    break;
  case SOAP_TYPE__wsa5__ProblemHeaderQName:
    soap_serialize_string(soap, (char*const*)&ptr);
    break;
  case SOAP_TYPE__wsa5__Action:
    soap_serialize_string(soap, (char*const*)&ptr);
    break;
  case SOAP_TYPE__wsa5__To:
    soap_serialize_string(soap, (char*const*)&ptr);
    break;
  case SOAP_TYPE__wsa5__MessageID:
    soap_serialize_string(soap, (char*const*)&ptr);
    break;
  case SOAP_TYPE_PointerTowsa5__MetadataType:
    soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
    soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
    break;
  case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
    soap_serialize_string(soap, (char*const*)&ptr);
    break;
  case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
    soap_serialize_string(soap, (char*const*)&ptr);
    break;
  case SOAP_TYPE_PointerTo_xenc__ReferenceList:
    soap_serialize_PointerTo_xenc__ReferenceList(soap, (struct _xenc__ReferenceList *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo__xenc__union_ReferenceList:
    soap_serialize_PointerTo__xenc__union_ReferenceList(soap, (struct __xenc__union_ReferenceList *const*)ptr);
    break;
  case SOAP_TYPE_PointerToxenc__ReferenceType:
    soap_serialize_PointerToxenc__ReferenceType(soap, (struct xenc__ReferenceType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
    soap_serialize_PointerToxenc__EncryptionPropertyType(soap, (struct xenc__EncryptionPropertyType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToxenc__TransformsType:
    soap_serialize_PointerToxenc__TransformsType(soap, (struct xenc__TransformsType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToxenc__CipherReferenceType:
    soap_serialize_PointerToxenc__CipherReferenceType(soap, (struct xenc__CipherReferenceType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
    soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, (struct xenc__EncryptionPropertiesType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToxenc__CipherDataType:
    soap_serialize_PointerToxenc__CipherDataType(soap, (struct xenc__CipherDataType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_ds__KeyInfo:
    soap_serialize_PointerTo_ds__KeyInfo(soap, (struct ds__KeyInfoType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
    soap_serialize_PointerToxenc__EncryptionMethodType(soap, (struct xenc__EncryptionMethodType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__X509IssuerSerialType:
    soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__RSAKeyValueType:
    soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__DSAKeyValueType:
    soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__TransformType:
    soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__DigestMethodType:
    soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__TransformsType:
    soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
    break;
  case SOAP_TYPE_PointerToint:
    soap_serialize_PointerToint(soap, (int *const*)ptr);
    break;
  case SOAP_TYPE_PointerToPointerTods__ReferenceType:
    soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__ReferenceType:
    soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__SignatureMethodType:
    soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
    soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
    soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__X509DataType:
    soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__RetrievalMethodType:
    soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__KeyValueType:
    soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
    soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__KeyInfoType:
    soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
    break;
  case SOAP_TYPE_PointerTods__SignedInfoType:
    soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
    break;
  case SOAP_TYPE__QName:
    soap_serialize_string(soap, (char*const*)&ptr);
    break;
  case SOAP_TYPE_string:
    soap_serialize_string(soap, (char*const*)&ptr);
    break;
  }
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
  *a = SOAP_DEFAULT_byte;
#else
  *a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type) {
  return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type) {
  char *p;
  p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
  if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type) {
  if ((p = soap_in_byte(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
  *a = SOAP_DEFAULT_int;
#else
  *a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type) {
  return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type) {
  int *p;
  p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
  if (soap_out_int(soap, tag?tag:"int", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type) {
  if ((p = soap_in_int(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
  *a = SOAP_DEFAULT_LONG64;
#else
  *a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type) {
  return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type) {
  LONG64 *p;
  p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
  if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type) {
  if ((p = soap_in_LONG64(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
  *a = SOAP_DEFAULT_unsignedInt;
#else
  *a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type) {
  return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type) {
  unsigned int *p;
  p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
  if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type) {
  if ((p = soap_in_unsignedInt(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
  *a = SOAP_DEFAULT_unsignedLONG64;
#else
  *a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type) {
  return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type) {
  ULONG64 *p;
  p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
  if (soap_out_unsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type) {
  if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
  *a = SOAP_DEFAULT_time;
#else
  *a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type) {
  return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type) {
  time_t *p;
  p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
  if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type) {
  if ((p = soap_in_time(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__DecisionType(struct soap *soap, enum ns8__DecisionType *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns8__DecisionType
  *a = SOAP_DEFAULT_ns8__DecisionType;
#else
  *a = (enum ns8__DecisionType)0;
#endif
}

static const struct soap_code_map soap_codes_ns8__DecisionType[] = {
  { (long)ns8__DecisionType__Permit, "Permit" },
  { (long)ns8__DecisionType__Deny, "Deny" },
  { (long)ns8__DecisionType__Indeterminate, "Indeterminate" },
  { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns8__DecisionType2s(struct soap *soap, enum ns8__DecisionType n) {
  const char *s = soap_code_str(soap_codes_ns8__DecisionType, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__DecisionType(struct soap *soap, const char *tag, int id, const enum ns8__DecisionType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__DecisionType), type) || soap_send(soap, soap_ns8__DecisionType2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns8__DecisionType(struct soap *soap, const char *s, enum ns8__DecisionType *a) {
  const struct soap_code_map *map;
  if (!s)
    return soap->error;
  map = soap_code(soap_codes_ns8__DecisionType, s);
  if (map)
    *a = (enum ns8__DecisionType)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
      return soap->error = SOAP_TYPE;
    *a = (enum ns8__DecisionType)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum ns8__DecisionType * SOAP_FMAC4 soap_in_ns8__DecisionType(struct soap *soap, const char *tag, enum ns8__DecisionType *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (enum ns8__DecisionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__DecisionType, sizeof(enum ns8__DecisionType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2ns8__DecisionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (enum ns8__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__DecisionType, 0, sizeof(enum ns8__DecisionType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__DecisionType(struct soap *soap, const enum ns8__DecisionType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__DecisionType);
  if (soap_out_ns8__DecisionType(soap, tag?tag:"ns8:DecisionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns8__DecisionType * SOAP_FMAC4 soap_get_ns8__DecisionType(struct soap *soap, enum ns8__DecisionType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__DecisionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean_(struct soap *soap, enum xsd__boolean_ *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean_
  *a = SOAP_DEFAULT_xsd__boolean_;
#else
  *a = (enum xsd__boolean_)0;
#endif
}

static const struct soap_code_map soap_codes_xsd__boolean_[] = {
  { (long)_false, "false" },
  { (long)_true, "true" },
  { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean_2s(struct soap *soap, enum xsd__boolean_ n) {
  const char *s = soap_code_str(soap_codes_xsd__boolean_, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean_(struct soap *soap, const char *tag, int id, const enum xsd__boolean_ *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean_), type) || soap_send(soap, soap_xsd__boolean_2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean_(struct soap *soap, const char *s, enum xsd__boolean_ *a) {
  const struct soap_code_map *map;
  if (!s)
    return soap->error;
  map = soap_code(soap_codes_xsd__boolean_, s);
  if (map)
    *a = (enum xsd__boolean_)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
      return soap->error = SOAP_TYPE;
    *a = (enum xsd__boolean_)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean_ * SOAP_FMAC4 soap_in_xsd__boolean_(struct soap *soap, const char *tag, enum xsd__boolean_ *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (enum xsd__boolean_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean_, sizeof(enum xsd__boolean_), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2xsd__boolean_(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (enum xsd__boolean_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean_, 0, sizeof(enum xsd__boolean_), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean_(struct soap *soap, const enum xsd__boolean_ *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean_);
  if (soap_out_xsd__boolean_(soap, tag?tag:"xsd:boolean", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean_ * SOAP_FMAC4 soap_get_xsd__boolean_(struct soap *soap, enum xsd__boolean_ *p, const char *tag, const char *type) {
  if ((p = soap_in_xsd__boolean_(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsse__FaultcodeEnum
  *a = SOAP_DEFAULT_wsse__FaultcodeEnum;
#else
  *a = (enum wsse__FaultcodeEnum)0;
#endif
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] = {
  { (long)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
  { (long)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
  { (long)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
  { (long)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
  { (long)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
  { (long)wsse__FailedCheck, "wsse:FailedCheck" },
  { (long)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
  { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n) {
  const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a) {
  const struct soap_code_map *map;
  char *t;
  if (!s)
    return soap->error;
  soap_s2QName(soap, s, &t, -1, -1);
  map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
  if (map)
    *a = (enum wsse__FaultcodeEnum)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
      return soap->error = SOAP_TYPE;
    *a = (enum wsse__FaultcodeEnum)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (enum wsse__FaultcodeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, 0, sizeof(enum wsse__FaultcodeEnum), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsse__FaultcodeEnum);
  if (soap_out_wsse__FaultcodeEnum(soap, tag?tag:"wsse:FaultcodeEnum", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type) {
  if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsu__tTimestampFault
  *a = SOAP_DEFAULT_wsu__tTimestampFault;
#else
  *a = (enum wsu__tTimestampFault)0;
#endif
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] = {
  { (long)wsu__MessageExpired, "wsu:MessageExpired" },
  { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n) {
  const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a) {
  const struct soap_code_map *map;
  char *t;
  if (!s)
    return soap->error;
  soap_s2QName(soap, s, &t, -1, -1);
  map = soap_code(soap_codes_wsu__tTimestampFault, t);
  if (map)
    *a = (enum wsu__tTimestampFault)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
      return soap->error = SOAP_TYPE;
    *a = (enum wsu__tTimestampFault)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (enum wsu__tTimestampFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2wsu__tTimestampFault(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, 0, sizeof(enum wsu__tTimestampFault), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsu__tTimestampFault);
  if (soap_out_wsu__tTimestampFault(soap, tag?tag:"wsu:tTimestampFault", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type) {
  if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__wsa5__IsReferenceParameter
  *a = SOAP_DEFAULT__wsa5__IsReferenceParameter;
#else
  *a = (enum _wsa5__IsReferenceParameter)0;
#endif
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] = {
  { (long)wsa5__false, "wsa5:false" },
  { (long)wsa5__true, "wsa5:true" },
  { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n) {
  const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a) {
  const struct soap_code_map *map;
  char *t;
  if (!s)
    return soap->error;
  soap_s2QName(soap, s, &t, -1, -1);
  map = soap_code(soap_codes__wsa5__IsReferenceParameter, t);
  if (map)
    *a = (enum _wsa5__IsReferenceParameter)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
      return soap->error = SOAP_TYPE;
    *a = (enum _wsa5__IsReferenceParameter)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (enum _wsa5__IsReferenceParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, 0, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa5__IsReferenceParameter);
  if (soap_out__wsa5__IsReferenceParameter(soap, tag?tag:"wsa5:IsReferenceParameter", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type) {
  if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__FaultCodesType
  *a = SOAP_DEFAULT_wsa5__FaultCodesType;
#else
  *a = (enum wsa5__FaultCodesType)0;
#endif
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] = {
  { (long)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
  { (long)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
  { (long)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
  { (long)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
  { (long)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
  { (long)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
  { (long)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
  { (long)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
  { (long)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
  { (long)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
  { (long)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
  { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n) {
  const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a) {
  const struct soap_code_map *map;
  char *t;
  if (!s)
    return soap->error;
  soap_s2QName(soap, s, &t, -1, -1);
  map = soap_code(soap_codes_wsa5__FaultCodesType, t);
  if (map)
    *a = (enum wsa5__FaultCodesType)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
      return soap->error = SOAP_TYPE;
    *a = (enum wsa5__FaultCodesType)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (enum wsa5__FaultCodesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, 0, sizeof(enum wsa5__FaultCodesType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__FaultCodesType);
  if (soap_out_wsa5__FaultCodesType(soap, tag?tag:"wsa5:FaultCodesType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type) {
  if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__RelationshipType
  *a = SOAP_DEFAULT_wsa5__RelationshipType;
#else
  *a = (enum wsa5__RelationshipType)0;
#endif
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] = {
  { (long)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
  { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n) {
  const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
  if (s)
    return s;
  return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a) {
  const struct soap_code_map *map;
  if (!s)
    return soap->error;
  map = soap_code(soap_codes_wsa5__RelationshipType, s);
  if (map)
    *a = (enum wsa5__RelationshipType)map->code;
  else {
    long n;
    if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
      return soap->error = SOAP_TYPE;
    *a = (enum wsa5__RelationshipType)n;
  }
  return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (enum wsa5__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  if (soap->body && !*soap->href) {
    if (!a || soap_s2wsa5__RelationshipType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, 0, sizeof(enum wsa5__RelationshipType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelationshipType);
  if (soap_out_wsa5__RelationshipType(soap, tag?tag:"wsa5:RelationshipType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type) {
  if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default__QName(soap, &a->faultcode);
  soap_default_string(soap, &a->faultstring);
  soap_default_string(soap, &a->faultactor);
  a->detail = NULL;
  a->SOAP_ENV__Code = NULL;
  a->SOAP_ENV__Reason = NULL;
  soap_default_string(soap, &a->SOAP_ENV__Node);
  soap_default_string(soap, &a->SOAP_ENV__Role);
  a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__QName(soap, &a->faultcode);
  soap_serialize_string(soap, &a->faultstring);
  soap_serialize_string(soap, &a->faultactor);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
  soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
  soap_serialize_string(soap, &a->SOAP_ENV__Node);
  soap_serialize_string(soap, &a->SOAP_ENV__Role);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type) {
  const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
    return soap->error;
  if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
    return soap->error;
  if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
    return soap->error;
  if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
    return soap->error;
  if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
    return soap->error;
  if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type) {
  size_t soap_flag_faultcode = 1;
  size_t soap_flag_faultstring = 1;
  size_t soap_flag_faultactor = 1;
  size_t soap_flag_detail = 1;
  size_t soap_flag_SOAP_ENV__Code = 1;
  size_t soap_flag_SOAP_ENV__Reason = 1;
  size_t soap_flag_SOAP_ENV__Node = 1;
  size_t soap_flag_SOAP_ENV__Role = 1;
  size_t soap_flag_SOAP_ENV__Detail = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Fault(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in__QName(soap, "faultcode", &a->faultcode, "")) {
          soap_flag_faultcode--;
          continue;
        }
      if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string")) {
          soap_flag_faultstring--;
          continue;
        }
      if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string")) {
          soap_flag_faultactor--;
          continue;
        }
      if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, "")) {
          soap_flag_detail--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, "")) {
          soap_flag_SOAP_ENV__Code--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, "")) {
          soap_flag_SOAP_ENV__Reason--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string")) {
          soap_flag_SOAP_ENV__Node--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string")) {
          soap_flag_SOAP_ENV__Role--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, "")) {
          soap_flag_SOAP_ENV__Detail--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
  if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
    return soap->error;
  if (soap->lang)
    soap_set_attr(soap, "xml:lang", soap->lang, 1);
  if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type) {
  size_t soap_flag_SOAP_ENV__Text = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Reason(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string")) {
          soap_flag_SOAP_ENV__Text--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
  if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default__QName(soap, &a->SOAP_ENV__Value);
  a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__QName(soap, &a->SOAP_ENV__Value);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type) {
  const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
    return soap->error;
  if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type) {
  size_t soap_flag_SOAP_ENV__Value = 1;
  size_t soap_flag_SOAP_ENV__Subcode = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Code(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, "")) {
          soap_flag_SOAP_ENV__Value--;
          continue;
        }
      if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, "")) {
          soap_flag_SOAP_ENV__Subcode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
  if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__interDomainEvent(struct soap *soap, struct __ns1__interDomainEvent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__interDomainEvent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__interDomainEvent(struct soap *soap, const struct __ns1__interDomainEvent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__interDomainEventContent(soap, &a->ns1__interDomainEvent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__interDomainEvent(struct soap *soap, const char *tag, int id, const struct __ns1__interDomainEvent *a, const char *type) {
  if (soap_out_PointerTons1__interDomainEventContent(soap, "ns1:interDomainEvent", -1, &a->ns1__interDomainEvent, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__interDomainEvent * SOAP_FMAC4 soap_in___ns1__interDomainEvent(struct soap *soap, const char *tag, struct __ns1__interDomainEvent *a, const char *type) {
  size_t soap_flag_ns1__interDomainEvent = 1;
  short soap_flag;
  a = (struct __ns1__interDomainEvent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__interDomainEvent, sizeof(struct __ns1__interDomainEvent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns1__interDomainEvent(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__interDomainEvent && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__interDomainEventContent(soap, "ns1:interDomainEvent", &a->ns1__interDomainEvent, "ns1:interDomainEventContent")) {
        soap_flag_ns1__interDomainEvent--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__interDomainEvent(struct soap *soap, const struct __ns1__interDomainEvent *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns1__interDomainEvent(soap, tag?tag:"-ns1:interDomainEvent", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__interDomainEvent * SOAP_FMAC4 soap_get___ns1__interDomainEvent(struct soap *soap, struct __ns1__interDomainEvent *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__interDomainEvent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__teardownPath(struct soap *soap, struct __ns1__teardownPath *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__teardownPath = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__teardownPath(struct soap *soap, const struct __ns1__teardownPath *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__teardownPathContent(soap, &a->ns1__teardownPath);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__teardownPath(struct soap *soap, const char *tag, int id, const struct __ns1__teardownPath *a, const char *type) {
  if (soap_out_PointerTons1__teardownPathContent(soap, "ns1:teardownPath", -1, &a->ns1__teardownPath, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__teardownPath * SOAP_FMAC4 soap_in___ns1__teardownPath(struct soap *soap, const char *tag, struct __ns1__teardownPath *a, const char *type) {
  size_t soap_flag_ns1__teardownPath = 1;
  short soap_flag;
  a = (struct __ns1__teardownPath *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__teardownPath, sizeof(struct __ns1__teardownPath), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns1__teardownPath(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__teardownPath && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__teardownPathContent(soap, "ns1:teardownPath", &a->ns1__teardownPath, "ns1:teardownPathContent")) {
        soap_flag_ns1__teardownPath--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__teardownPath(struct soap *soap, const struct __ns1__teardownPath *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns1__teardownPath(soap, tag?tag:"-ns1:teardownPath", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__teardownPath * SOAP_FMAC4 soap_get___ns1__teardownPath(struct soap *soap, struct __ns1__teardownPath *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__teardownPath(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__refreshPath(struct soap *soap, struct __ns1__refreshPath *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__refreshPath = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__refreshPath(struct soap *soap, const struct __ns1__refreshPath *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__refreshPathContent(soap, &a->ns1__refreshPath);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__refreshPath(struct soap *soap, const char *tag, int id, const struct __ns1__refreshPath *a, const char *type) {
  if (soap_out_PointerTons1__refreshPathContent(soap, "ns1:refreshPath", -1, &a->ns1__refreshPath, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__refreshPath * SOAP_FMAC4 soap_in___ns1__refreshPath(struct soap *soap, const char *tag, struct __ns1__refreshPath *a, const char *type) {
  size_t soap_flag_ns1__refreshPath = 1;
  short soap_flag;
  a = (struct __ns1__refreshPath *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__refreshPath, sizeof(struct __ns1__refreshPath), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns1__refreshPath(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__refreshPath && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__refreshPathContent(soap, "ns1:refreshPath", &a->ns1__refreshPath, "ns1:refreshPathContent")) {
        soap_flag_ns1__refreshPath--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__refreshPath(struct soap *soap, const struct __ns1__refreshPath *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns1__refreshPath(soap, tag?tag:"-ns1:refreshPath", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__refreshPath * SOAP_FMAC4 soap_get___ns1__refreshPath(struct soap *soap, struct __ns1__refreshPath *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__refreshPath(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createPath(struct soap *soap, struct __ns1__createPath *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__createPath = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createPath(struct soap *soap, const struct __ns1__createPath *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__createPathContent(soap, &a->ns1__createPath);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createPath(struct soap *soap, const char *tag, int id, const struct __ns1__createPath *a, const char *type) {
  if (soap_out_PointerTons1__createPathContent(soap, "ns1:createPath", -1, &a->ns1__createPath, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createPath * SOAP_FMAC4 soap_in___ns1__createPath(struct soap *soap, const char *tag, struct __ns1__createPath *a, const char *type) {
  size_t soap_flag_ns1__createPath = 1;
  short soap_flag;
  a = (struct __ns1__createPath *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createPath, sizeof(struct __ns1__createPath), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns1__createPath(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__createPath && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__createPathContent(soap, "ns1:createPath", &a->ns1__createPath, "ns1:createPathContent")) {
        soap_flag_ns1__createPath--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createPath(struct soap *soap, const struct __ns1__createPath *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns1__createPath(soap, tag?tag:"-ns1:createPath", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createPath * SOAP_FMAC4 soap_get___ns1__createPath(struct soap *soap, struct __ns1__createPath *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__createPath(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getNetworkTopology(struct soap *soap, struct __ns1__getNetworkTopology *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__getNetworkTopology = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getNetworkTopology(struct soap *soap, const struct __ns1__getNetworkTopology *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__getTopologyContent(soap, &a->ns1__getNetworkTopology);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getNetworkTopology(struct soap *soap, const char *tag, int id, const struct __ns1__getNetworkTopology *a, const char *type) {
  if (soap_out_PointerTons1__getTopologyContent(soap, "ns1:getNetworkTopology", -1, &a->ns1__getNetworkTopology, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNetworkTopology * SOAP_FMAC4 soap_in___ns1__getNetworkTopology(struct soap *soap, const char *tag, struct __ns1__getNetworkTopology *a, const char *type) {
  size_t soap_flag_ns1__getNetworkTopology = 1;
  short soap_flag;
  a = (struct __ns1__getNetworkTopology *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getNetworkTopology, sizeof(struct __ns1__getNetworkTopology), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns1__getNetworkTopology(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__getNetworkTopology && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__getTopologyContent(soap, "ns1:getNetworkTopology", &a->ns1__getNetworkTopology, "ns1:getTopologyContent")) {
        soap_flag_ns1__getNetworkTopology--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getNetworkTopology(struct soap *soap, const struct __ns1__getNetworkTopology *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns1__getNetworkTopology(soap, tag?tag:"-ns1:getNetworkTopology", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNetworkTopology * SOAP_FMAC4 soap_get___ns1__getNetworkTopology(struct soap *soap, struct __ns1__getNetworkTopology *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__getNetworkTopology(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__modifyReservation(struct soap *soap, struct __ns1__modifyReservation *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__modifyReservation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__modifyReservation(struct soap *soap, const struct __ns1__modifyReservation *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__modifyResContent(soap, &a->ns1__modifyReservation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__modifyReservation(struct soap *soap, const char *tag, int id, const struct __ns1__modifyReservation *a, const char *type) {
  if (soap_out_PointerTons1__modifyResContent(soap, "ns1:modifyReservation", -1, &a->ns1__modifyReservation, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyReservation * SOAP_FMAC4 soap_in___ns1__modifyReservation(struct soap *soap, const char *tag, struct __ns1__modifyReservation *a, const char *type) {
  size_t soap_flag_ns1__modifyReservation = 1;
  short soap_flag;
  a = (struct __ns1__modifyReservation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__modifyReservation, sizeof(struct __ns1__modifyReservation), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns1__modifyReservation(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__modifyReservation && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__modifyResContent(soap, "ns1:modifyReservation", &a->ns1__modifyReservation, "ns1:modifyResContent")) {
        soap_flag_ns1__modifyReservation--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__modifyReservation(struct soap *soap, const struct __ns1__modifyReservation *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns1__modifyReservation(soap, tag?tag:"-ns1:modifyReservation", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__modifyReservation * SOAP_FMAC4 soap_get___ns1__modifyReservation(struct soap *soap, struct __ns1__modifyReservation *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__modifyReservation(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cancelReservation(struct soap *soap, struct __ns1__cancelReservation *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__cancelReservation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cancelReservation(struct soap *soap, const struct __ns1__cancelReservation *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__cancelResContent(soap, &a->ns1__cancelReservation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cancelReservation(struct soap *soap, const char *tag, int id, const struct __ns1__cancelReservation *a, const char *type) {
  if (soap_out_PointerTons1__cancelResContent(soap, "ns1:cancelReservation", -1, &a->ns1__cancelReservation, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cancelReservation * SOAP_FMAC4 soap_in___ns1__cancelReservation(struct soap *soap, const char *tag, struct __ns1__cancelReservation *a, const char *type) {
  size_t soap_flag_ns1__cancelReservation = 1;
  short soap_flag;
  a = (struct __ns1__cancelReservation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cancelReservation, sizeof(struct __ns1__cancelReservation), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns1__cancelReservation(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__cancelReservation && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__cancelResContent(soap, "ns1:cancelReservation", &a->ns1__cancelReservation, "ns1:cancelResContent")) {
        soap_flag_ns1__cancelReservation--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cancelReservation(struct soap *soap, const struct __ns1__cancelReservation *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns1__cancelReservation(soap, tag?tag:"-ns1:cancelReservation", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cancelReservation * SOAP_FMAC4 soap_get___ns1__cancelReservation(struct soap *soap, struct __ns1__cancelReservation *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__cancelReservation(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listReservations(struct soap *soap, struct __ns1__listReservations *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__listReservations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listReservations(struct soap *soap, const struct __ns1__listReservations *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__listRequest(soap, &a->ns1__listReservations);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listReservations(struct soap *soap, const char *tag, int id, const struct __ns1__listReservations *a, const char *type) {
  if (soap_out_PointerTons1__listRequest(soap, "ns1:listReservations", -1, &a->ns1__listReservations, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listReservations * SOAP_FMAC4 soap_in___ns1__listReservations(struct soap *soap, const char *tag, struct __ns1__listReservations *a, const char *type) {
  size_t soap_flag_ns1__listReservations = 1;
  short soap_flag;
  a = (struct __ns1__listReservations *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listReservations, sizeof(struct __ns1__listReservations), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns1__listReservations(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__listReservations && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__listRequest(soap, "ns1:listReservations", &a->ns1__listReservations, "ns1:listRequest")) {
        soap_flag_ns1__listReservations--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listReservations(struct soap *soap, const struct __ns1__listReservations *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns1__listReservations(soap, tag?tag:"-ns1:listReservations", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listReservations * SOAP_FMAC4 soap_get___ns1__listReservations(struct soap *soap, struct __ns1__listReservations *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__listReservations(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryReservation(struct soap *soap, struct __ns1__queryReservation *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__queryReservation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryReservation(struct soap *soap, const struct __ns1__queryReservation *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__queryResContent(soap, &a->ns1__queryReservation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryReservation(struct soap *soap, const char *tag, int id, const struct __ns1__queryReservation *a, const char *type) {
  if (soap_out_PointerTons1__queryResContent(soap, "ns1:queryReservation", -1, &a->ns1__queryReservation, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryReservation * SOAP_FMAC4 soap_in___ns1__queryReservation(struct soap *soap, const char *tag, struct __ns1__queryReservation *a, const char *type) {
  size_t soap_flag_ns1__queryReservation = 1;
  short soap_flag;
  a = (struct __ns1__queryReservation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryReservation, sizeof(struct __ns1__queryReservation), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns1__queryReservation(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__queryReservation && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__queryResContent(soap, "ns1:queryReservation", &a->ns1__queryReservation, "ns1:queryResContent")) {
        soap_flag_ns1__queryReservation--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryReservation(struct soap *soap, const struct __ns1__queryReservation *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns1__queryReservation(soap, tag?tag:"-ns1:queryReservation", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryReservation * SOAP_FMAC4 soap_get___ns1__queryReservation(struct soap *soap, struct __ns1__queryReservation *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__queryReservation(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createReservation(struct soap *soap, struct __ns1__createReservation *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->ns1__createReservation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createReservation(struct soap *soap, const struct __ns1__createReservation *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__resCreateContent(soap, &a->ns1__createReservation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createReservation(struct soap *soap, const char *tag, int id, const struct __ns1__createReservation *a, const char *type) {
  if (soap_out_PointerTons1__resCreateContent(soap, "ns1:createReservation", -1, &a->ns1__createReservation, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createReservation * SOAP_FMAC4 soap_in___ns1__createReservation(struct soap *soap, const char *tag, struct __ns1__createReservation *a, const char *type) {
  size_t soap_flag_ns1__createReservation = 1;
  short soap_flag;
  a = (struct __ns1__createReservation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createReservation, sizeof(struct __ns1__createReservation), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns1__createReservation(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_ns1__createReservation && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__resCreateContent(soap, "ns1:createReservation", &a->ns1__createReservation, "ns1:resCreateContent")) {
        soap_flag_ns1__createReservation--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createReservation(struct soap *soap, const struct __ns1__createReservation *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns1__createReservation(soap, tag?tag:"-ns1:createReservation", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createReservation * SOAP_FMAC4 soap_get___ns1__createReservation(struct soap *soap, struct __ns1__createReservation *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__createReservation(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__any = NULL;
  a->ns2__OSCARSFault = NULL;
  a->__type = 0;
  a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_ns2__OSCARSFault(soap, &a->ns2__OSCARSFault);
  soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
    return soap->error;
  soap_outliteral(soap, "-any", &a->__any, NULL);
  if (soap_out_PointerTo_ns2__OSCARSFault(soap, "ns2:OSCARSFault", -1, &a->ns2__OSCARSFault, ""))
    return soap->error;
  if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type) {
  size_t soap_flag___any = 1;
  size_t soap_flag_ns2__OSCARSFault = 1;
  size_t soap_flag_fault = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Detail(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns2__OSCARSFault && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_ns2__OSCARSFault(soap, "ns2:OSCARSFault", &a->ns2__OSCARSFault, "")) {
          soap_flag_ns2__OSCARSFault--;
          continue;
        }
      if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
        if ((a->fault = soap_getelement(soap, &a->__type))) {
          soap_flag_fault = 0;
          continue;
        }
      if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-any", &a->__any)) {
          soap_flag___any--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
  if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__KeyInfoConfirmationDataType(struct soap *soap, struct ns8__KeyInfoConfirmationDataType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default__ds__KeyInfo(soap, &a->ds__KeyInfo);
  a->NotBefore = NULL;
  a->NotOnOrAfter = NULL;
  soap_default_string(soap, &a->Recipient);
  soap_default_string(soap, &a->InResponseTo);
  soap_default_string(soap, &a->Address);
  a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__KeyInfoConfirmationDataType(struct soap *soap, const struct ns8__KeyInfoConfirmationDataType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ds__KeyInfo, SOAP_TYPE__ds__KeyInfo);
  soap_serialize__ds__KeyInfo(soap, &a->ds__KeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__KeyInfoConfirmationDataType(struct soap *soap, const char *tag, int id, const struct ns8__KeyInfoConfirmationDataType *a, const char *type) {
  if (a->NotBefore)
    soap_set_attr(soap, "NotBefore", soap_dateTime2s(soap, *a->NotBefore), 1);
  if (a->NotOnOrAfter)
    soap_set_attr(soap, "NotOnOrAfter", soap_dateTime2s(soap, *a->NotOnOrAfter), 1);
  if (a->Recipient)
    soap_set_attr(soap, "Recipient", a->Recipient, 1);
  if (a->InResponseTo)
    soap_set_attr(soap, "InResponseTo", a->InResponseTo, 1);
  if (a->Address)
    soap_set_attr(soap, "Address", a->Address, 1);
  if (a->__anyAttribute)
    soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__KeyInfoConfirmationDataType), type))
    return soap->error;
  if (soap_out__ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__KeyInfoConfirmationDataType * SOAP_FMAC4 soap_in_ns8__KeyInfoConfirmationDataType(struct soap *soap, const char *tag, struct ns8__KeyInfoConfirmationDataType *a, const char *type) {
  size_t soap_flag_ds__KeyInfo = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__KeyInfoConfirmationDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__KeyInfoConfirmationDataType, sizeof(struct ns8__KeyInfoConfirmationDataType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__KeyInfoConfirmationDataType(soap, a);
  {
    const char *t = soap_attr_value(soap, "NotBefore", 0);
    if (t) {
      if (!(a->NotBefore = (time_t *)soap_malloc(soap, sizeof(time_t)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2dateTime(soap, t, a->NotBefore))
        return NULL;
    }
    else if (soap->error)
      return NULL;
  }
  {
    const char *t = soap_attr_value(soap, "NotOnOrAfter", 0);
    if (t) {
      if (!(a->NotOnOrAfter = (time_t *)soap_malloc(soap, sizeof(time_t)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2dateTime(soap, t, a->NotOnOrAfter))
        return NULL;
    }
    else if (soap->error)
      return NULL;
  }
  if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 0), &a->Recipient, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "InResponseTo", 0), &a->InResponseTo, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Address", 0), &a->Address, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in__ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, "")) {
          soap_flag_ds__KeyInfo--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__KeyInfoConfirmationDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__KeyInfoConfirmationDataType, 0, sizeof(struct ns8__KeyInfoConfirmationDataType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__KeyInfo > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__KeyInfoConfirmationDataType(struct soap *soap, const struct ns8__KeyInfoConfirmationDataType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__KeyInfoConfirmationDataType);
  if (soap_out_ns8__KeyInfoConfirmationDataType(soap, tag?tag:"ns8:KeyInfoConfirmationDataType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__KeyInfoConfirmationDataType * SOAP_FMAC4 soap_get_ns8__KeyInfoConfirmationDataType(struct soap *soap, struct ns8__KeyInfoConfirmationDataType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__KeyInfoConfirmationDataType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__union_AttributeStatementType(struct soap *soap, struct __ns8__union_AttributeStatementType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__union_AttributeStatementType = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__union_AttributeStatementType(struct soap *soap, const struct __ns8__union_AttributeStatementType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__ns8__union_AttributeStatementType(soap, a->__union_AttributeStatementType, &a->union_AttributeStatementType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__union_AttributeStatementType(struct soap *soap, const char *tag, int id, const struct __ns8__union_AttributeStatementType *a, const char *type) {
  if (soap_out__ns8__union_AttributeStatementType(soap, a->__union_AttributeStatementType, &a->union_AttributeStatementType))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__union_AttributeStatementType * SOAP_FMAC4 soap_in___ns8__union_AttributeStatementType(struct soap *soap, const char *tag, struct __ns8__union_AttributeStatementType *a, const char *type) {
  a = (struct __ns8__union_AttributeStatementType *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__union_AttributeStatementType, sizeof(struct __ns8__union_AttributeStatementType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns8__union_AttributeStatementType(soap, a);
  if (!soap_in__ns8__union_AttributeStatementType(soap, &a->__union_AttributeStatementType, &a->union_AttributeStatementType))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__union_AttributeStatementType(struct soap *soap, const struct __ns8__union_AttributeStatementType *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns8__union_AttributeStatementType(soap, tag?tag:"-ns8:union-AttributeStatementType", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__union_AttributeStatementType * SOAP_FMAC4 soap_get___ns8__union_AttributeStatementType(struct soap *soap, struct __ns8__union_AttributeStatementType *p, const char *tag, const char *type) {
  if ((p = soap_in___ns8__union_AttributeStatementType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__ActionType(struct soap *soap, struct ns8__ActionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_string(soap, &a->Namespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__ActionType(struct soap *soap, const struct ns8__ActionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__ActionType(struct soap *soap, const char *tag, int id, const struct ns8__ActionType *a, const char *type) {
  if (a->Namespace)
    soap_set_attr(soap, "Namespace", a->Namespace, 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns8__ActionType * SOAP_FMAC4 soap_in_ns8__ActionType(struct soap *soap, const char *tag, struct ns8__ActionType *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct ns8__ActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__ActionType, sizeof(struct ns8__ActionType), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default_ns8__ActionType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Namespace", 1), &a->Namespace, -1, -1))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, "ns8:ActionType"))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__ActionType(struct soap *soap, const struct ns8__ActionType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__ActionType);
  if (soap_out_ns8__ActionType(soap, tag?tag:"ns8:ActionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ActionType * SOAP_FMAC4 soap_get_ns8__ActionType(struct soap *soap, struct ns8__ActionType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__ActionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ResourceUnavailableFaultType(struct soap *soap, struct ns4__ResourceUnavailableFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ResourceUnavailableFaultType(struct soap *soap, const struct ns4__ResourceUnavailableFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ResourceUnavailableFaultType(struct soap *soap, const char *tag, int id, const struct ns4__ResourceUnavailableFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ResourceUnavailableFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ResourceUnavailableFaultType * SOAP_FMAC4 soap_in_ns4__ResourceUnavailableFaultType(struct soap *soap, const char *tag, struct ns4__ResourceUnavailableFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns4__ResourceUnavailableFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ResourceUnavailableFaultType, sizeof(struct ns4__ResourceUnavailableFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns4__ResourceUnavailableFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns4__ResourceUnavailableFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ResourceUnavailableFaultType, 0, sizeof(struct ns4__ResourceUnavailableFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ResourceUnavailableFaultType(struct soap *soap, const struct ns4__ResourceUnavailableFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ResourceUnavailableFaultType);
  if (soap_out_ns4__ResourceUnavailableFaultType(soap, tag?tag:"ns4:ResourceUnavailableFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ResourceUnavailableFaultType * SOAP_FMAC4 soap_get_ns4__ResourceUnavailableFaultType(struct soap *soap, struct ns4__ResourceUnavailableFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns4__ResourceUnavailableFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ResourceUnknownFaultType(struct soap *soap, struct ns4__ResourceUnknownFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ResourceUnknownFaultType(struct soap *soap, const struct ns4__ResourceUnknownFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ResourceUnknownFaultType(struct soap *soap, const char *tag, int id, const struct ns4__ResourceUnknownFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ResourceUnknownFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ResourceUnknownFaultType * SOAP_FMAC4 soap_in_ns4__ResourceUnknownFaultType(struct soap *soap, const char *tag, struct ns4__ResourceUnknownFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns4__ResourceUnknownFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ResourceUnknownFaultType, sizeof(struct ns4__ResourceUnknownFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns4__ResourceUnknownFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns4__ResourceUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ResourceUnknownFaultType, 0, sizeof(struct ns4__ResourceUnknownFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ResourceUnknownFaultType(struct soap *soap, const struct ns4__ResourceUnknownFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ResourceUnknownFaultType);
  if (soap_out_ns4__ResourceUnknownFaultType(soap, tag?tag:"ns4:ResourceUnknownFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ResourceUnknownFaultType * SOAP_FMAC4 soap_get_ns4__ResourceUnknownFaultType(struct soap *soap, struct ns4__ResourceUnknownFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns4__ResourceUnknownFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__ResumeFailedFaultType(struct soap *soap, struct ns3__ResumeFailedFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__ResumeFailedFaultType(struct soap *soap, const struct ns3__ResumeFailedFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, const struct ns3__ResumeFailedFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ResumeFailedFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__ResumeFailedFaultType * SOAP_FMAC4 soap_in_ns3__ResumeFailedFaultType(struct soap *soap, const char *tag, struct ns3__ResumeFailedFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__ResumeFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ResumeFailedFaultType, sizeof(struct ns3__ResumeFailedFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__ResumeFailedFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__ResumeFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ResumeFailedFaultType, 0, sizeof(struct ns3__ResumeFailedFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__ResumeFailedFaultType(struct soap *soap, const struct ns3__ResumeFailedFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__ResumeFailedFaultType);
  if (soap_out_ns3__ResumeFailedFaultType(soap, tag?tag:"ns3:ResumeFailedFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__ResumeFailedFaultType * SOAP_FMAC4 soap_get_ns3__ResumeFailedFaultType(struct soap *soap, struct ns3__ResumeFailedFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__ResumeFailedFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__PauseFailedFaultType(struct soap *soap, struct ns3__PauseFailedFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__PauseFailedFaultType(struct soap *soap, const struct ns3__PauseFailedFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__PauseFailedFaultType(struct soap *soap, const char *tag, int id, const struct ns3__PauseFailedFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__PauseFailedFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__PauseFailedFaultType * SOAP_FMAC4 soap_in_ns3__PauseFailedFaultType(struct soap *soap, const char *tag, struct ns3__PauseFailedFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__PauseFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__PauseFailedFaultType, sizeof(struct ns3__PauseFailedFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__PauseFailedFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__PauseFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__PauseFailedFaultType, 0, sizeof(struct ns3__PauseFailedFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__PauseFailedFaultType(struct soap *soap, const struct ns3__PauseFailedFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__PauseFailedFaultType);
  if (soap_out_ns3__PauseFailedFaultType(soap, tag?tag:"ns3:PauseFailedFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__PauseFailedFaultType * SOAP_FMAC4 soap_get_ns3__PauseFailedFaultType(struct soap *soap, struct ns3__PauseFailedFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__PauseFailedFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__UnableToDestroySubscriptionFaultType(struct soap *soap, struct ns3__UnableToDestroySubscriptionFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__UnableToDestroySubscriptionFaultType(struct soap *soap, const struct ns3__UnableToDestroySubscriptionFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, const struct ns3__UnableToDestroySubscriptionFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_in_ns3__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, struct ns3__UnableToDestroySubscriptionFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__UnableToDestroySubscriptionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType, sizeof(struct ns3__UnableToDestroySubscriptionFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__UnableToDestroySubscriptionFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__UnableToDestroySubscriptionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType, 0, sizeof(struct ns3__UnableToDestroySubscriptionFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__UnableToDestroySubscriptionFaultType(struct soap *soap, const struct ns3__UnableToDestroySubscriptionFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType);
  if (soap_out_ns3__UnableToDestroySubscriptionFaultType(soap, tag?tag:"ns3:UnableToDestroySubscriptionFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_get_ns3__UnableToDestroySubscriptionFaultType(struct soap *soap, struct ns3__UnableToDestroySubscriptionFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__UnacceptableTerminationTimeFaultType(struct soap *soap, struct ns3__UnacceptableTerminationTimeFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
  soap_default_time(soap, &a->MinimumTime);
  a->MaximumTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__UnacceptableTerminationTimeFaultType(struct soap *soap, const struct ns3__UnacceptableTerminationTimeFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
  soap_embedded(soap, &a->MinimumTime, SOAP_TYPE_time);
  soap_serialize_PointerTotime(soap, &a->MaximumTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const struct ns3__UnacceptableTerminationTimeFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  if (soap_out_time(soap, "ns3:MinimumTime", -1, &a->MinimumTime, ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "ns3:MaximumTime", -1, &a->MaximumTime, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_in_ns3__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, struct ns3__UnacceptableTerminationTimeFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  size_t soap_flag_MinimumTime = 1;
  size_t soap_flag_MaximumTime = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__UnacceptableTerminationTimeFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType, sizeof(struct ns3__UnacceptableTerminationTimeFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__UnacceptableTerminationTimeFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns3:MinimumTime", &a->MinimumTime, "xsd:dateTime")) {
          soap_flag_MinimumTime--;
          continue;
        }
      if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "ns3:MaximumTime", &a->MaximumTime, "xsd:dateTime")) {
          soap_flag_MaximumTime--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__UnacceptableTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType, 0, sizeof(struct ns3__UnacceptableTerminationTimeFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0 || soap_flag_MinimumTime > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__UnacceptableTerminationTimeFaultType(struct soap *soap, const struct ns3__UnacceptableTerminationTimeFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType);
  if (soap_out_ns3__UnacceptableTerminationTimeFaultType(soap, tag?tag:"ns3:UnacceptableTerminationTimeFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_get_ns3__UnacceptableTerminationTimeFaultType(struct soap *soap, struct ns3__UnacceptableTerminationTimeFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__UnableToCreatePullPointFaultType(struct soap *soap, struct ns3__UnableToCreatePullPointFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__UnableToCreatePullPointFaultType(struct soap *soap, const struct ns3__UnableToCreatePullPointFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, const struct ns3__UnableToCreatePullPointFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnableToCreatePullPointFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_in_ns3__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, struct ns3__UnableToCreatePullPointFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__UnableToCreatePullPointFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnableToCreatePullPointFaultType, sizeof(struct ns3__UnableToCreatePullPointFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__UnableToCreatePullPointFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__UnableToCreatePullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnableToCreatePullPointFaultType, 0, sizeof(struct ns3__UnableToCreatePullPointFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__UnableToCreatePullPointFaultType(struct soap *soap, const struct ns3__UnableToCreatePullPointFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__UnableToCreatePullPointFaultType);
  if (soap_out_ns3__UnableToCreatePullPointFaultType(soap, tag?tag:"ns3:UnableToCreatePullPointFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_get_ns3__UnableToCreatePullPointFaultType(struct soap *soap, struct ns3__UnableToCreatePullPointFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__UnableToCreatePullPointFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__UnableToDestroyPullPointFaultType(struct soap *soap, struct ns3__UnableToDestroyPullPointFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__UnableToDestroyPullPointFaultType(struct soap *soap, const struct ns3__UnableToDestroyPullPointFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, const struct ns3__UnableToDestroyPullPointFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_in_ns3__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, struct ns3__UnableToDestroyPullPointFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__UnableToDestroyPullPointFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType, sizeof(struct ns3__UnableToDestroyPullPointFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__UnableToDestroyPullPointFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__UnableToDestroyPullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType, 0, sizeof(struct ns3__UnableToDestroyPullPointFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__UnableToDestroyPullPointFaultType(struct soap *soap, const struct ns3__UnableToDestroyPullPointFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType);
  if (soap_out_ns3__UnableToDestroyPullPointFaultType(soap, tag?tag:"ns3:UnableToDestroyPullPointFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_get_ns3__UnableToDestroyPullPointFaultType(struct soap *soap, struct ns3__UnableToDestroyPullPointFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__UnableToGetMessagesFaultType(struct soap *soap, struct ns3__UnableToGetMessagesFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__UnableToGetMessagesFaultType(struct soap *soap, const struct ns3__UnableToGetMessagesFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, const struct ns3__UnableToGetMessagesFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnableToGetMessagesFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_in_ns3__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, struct ns3__UnableToGetMessagesFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__UnableToGetMessagesFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnableToGetMessagesFaultType, sizeof(struct ns3__UnableToGetMessagesFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__UnableToGetMessagesFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__UnableToGetMessagesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnableToGetMessagesFaultType, 0, sizeof(struct ns3__UnableToGetMessagesFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__UnableToGetMessagesFaultType(struct soap *soap, const struct ns3__UnableToGetMessagesFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__UnableToGetMessagesFaultType);
  if (soap_out_ns3__UnableToGetMessagesFaultType(soap, tag?tag:"ns3:UnableToGetMessagesFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_get_ns3__UnableToGetMessagesFaultType(struct soap *soap, struct ns3__UnableToGetMessagesFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__UnableToGetMessagesFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct ns3__NoCurrentMessageOnTopicFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__NoCurrentMessageOnTopicFaultType(struct soap *soap, const struct ns3__NoCurrentMessageOnTopicFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, const struct ns3__NoCurrentMessageOnTopicFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_in_ns3__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, struct ns3__NoCurrentMessageOnTopicFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__NoCurrentMessageOnTopicFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType, sizeof(struct ns3__NoCurrentMessageOnTopicFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__NoCurrentMessageOnTopicFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__NoCurrentMessageOnTopicFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType, 0, sizeof(struct ns3__NoCurrentMessageOnTopicFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__NoCurrentMessageOnTopicFaultType(struct soap *soap, const struct ns3__NoCurrentMessageOnTopicFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType);
  if (soap_out_ns3__NoCurrentMessageOnTopicFaultType(soap, tag?tag:"ns3:NoCurrentMessageOnTopicFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_get_ns3__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct ns3__NoCurrentMessageOnTopicFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct ns3__UnacceptableInitialTerminationTimeFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
  soap_default_time(soap, &a->MinimumTime);
  a->MaximumTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const struct ns3__UnacceptableInitialTerminationTimeFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
  soap_embedded(soap, &a->MinimumTime, SOAP_TYPE_time);
  soap_serialize_PointerTotime(soap, &a->MaximumTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const struct ns3__UnacceptableInitialTerminationTimeFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  if (soap_out_time(soap, "ns3:MinimumTime", -1, &a->MinimumTime, ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "ns3:MaximumTime", -1, &a->MaximumTime, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_in_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, struct ns3__UnacceptableInitialTerminationTimeFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  size_t soap_flag_MinimumTime = 1;
  size_t soap_flag_MaximumTime = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__UnacceptableInitialTerminationTimeFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType, sizeof(struct ns3__UnacceptableInitialTerminationTimeFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__UnacceptableInitialTerminationTimeFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns3:MinimumTime", &a->MinimumTime, "xsd:dateTime")) {
          soap_flag_MinimumTime--;
          continue;
        }
      if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "ns3:MaximumTime", &a->MaximumTime, "xsd:dateTime")) {
          soap_flag_MaximumTime--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__UnacceptableInitialTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType, 0, sizeof(struct ns3__UnacceptableInitialTerminationTimeFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0 || soap_flag_MinimumTime > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const struct ns3__UnacceptableInitialTerminationTimeFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType);
  if (soap_out_ns3__UnacceptableInitialTerminationTimeFaultType(soap, tag?tag:"ns3:UnacceptableInitialTerminationTimeFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_get_ns3__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct ns3__UnacceptableInitialTerminationTimeFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__NotifyMessageNotSupportedFaultType(struct soap *soap, struct ns3__NotifyMessageNotSupportedFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__NotifyMessageNotSupportedFaultType(struct soap *soap, const struct ns3__NotifyMessageNotSupportedFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, const struct ns3__NotifyMessageNotSupportedFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_in_ns3__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, struct ns3__NotifyMessageNotSupportedFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__NotifyMessageNotSupportedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType, sizeof(struct ns3__NotifyMessageNotSupportedFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__NotifyMessageNotSupportedFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__NotifyMessageNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType, 0, sizeof(struct ns3__NotifyMessageNotSupportedFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__NotifyMessageNotSupportedFaultType(struct soap *soap, const struct ns3__NotifyMessageNotSupportedFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType);
  if (soap_out_ns3__NotifyMessageNotSupportedFaultType(soap, tag?tag:"ns3:NotifyMessageNotSupportedFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_get_ns3__NotifyMessageNotSupportedFaultType(struct soap *soap, struct ns3__NotifyMessageNotSupportedFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__UnsupportedPolicyRequestFaultType(struct soap *soap, struct ns3__UnsupportedPolicyRequestFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
  a->__sizeUnsupportedPolicy = 0;
  a->UnsupportedPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__UnsupportedPolicyRequestFaultType(struct soap *soap, const struct ns3__UnsupportedPolicyRequestFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
  if (a->UnsupportedPolicy) {
    int i;
    for (i = 0; i < a->__sizeUnsupportedPolicy; i++) {
      soap_serialize__QName(soap, a->UnsupportedPolicy + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const struct ns3__UnsupportedPolicyRequestFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  if (a->UnsupportedPolicy) {
    int i;
    for (i = 0; i < a->__sizeUnsupportedPolicy; i++) {
      const char *soap_tmp_UnsupportedPolicy = soap_QName2s(soap, a->UnsupportedPolicy[i]);
      if (soap_out__QName(soap, "ns3:UnsupportedPolicy", -1, (char*const*)&soap_tmp_UnsupportedPolicy, ""))
        return soap->error;
    }
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_in_ns3__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, struct ns3__UnsupportedPolicyRequestFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  struct soap_blist *soap_blist_UnsupportedPolicy = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__UnsupportedPolicyRequestFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType, sizeof(struct ns3__UnsupportedPolicyRequestFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__UnsupportedPolicyRequestFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:UnsupportedPolicy", 1, NULL)) {
        if (a->UnsupportedPolicy == NULL) {
          if (soap_blist_UnsupportedPolicy == NULL)
            soap_blist_UnsupportedPolicy = soap_new_block(soap);
          a->UnsupportedPolicy = (char **)soap_push_block(soap, soap_blist_UnsupportedPolicy, sizeof(char *));
          if (a->UnsupportedPolicy == NULL)
            return NULL;
          *a->UnsupportedPolicy = NULL;
        }
        soap_revert(soap);
        if (soap_in__QName(soap, "ns3:UnsupportedPolicy", a->UnsupportedPolicy, "")) {
          a->__sizeUnsupportedPolicy++;
          a->UnsupportedPolicy = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (a->UnsupportedPolicy)
      soap_pop_block(soap, soap_blist_UnsupportedPolicy);
    if (a->__sizeUnsupportedPolicy)
      a->UnsupportedPolicy = (char **)soap_save_block(soap, soap_blist_UnsupportedPolicy, NULL, 1);
    else {
      a->UnsupportedPolicy = NULL;
      if (soap_blist_UnsupportedPolicy)
        soap_end_block(soap, soap_blist_UnsupportedPolicy);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__UnsupportedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType, 0, sizeof(struct ns3__UnsupportedPolicyRequestFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__UnsupportedPolicyRequestFaultType(struct soap *soap, const struct ns3__UnsupportedPolicyRequestFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType);
  if (soap_out_ns3__UnsupportedPolicyRequestFaultType(soap, tag?tag:"ns3:UnsupportedPolicyRequestFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_get_ns3__UnsupportedPolicyRequestFaultType(struct soap *soap, struct ns3__UnsupportedPolicyRequestFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct ns3__UnrecognizedPolicyRequestFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
  a->__sizeUnrecognizedPolicy = 0;
  a->UnrecognizedPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__UnrecognizedPolicyRequestFaultType(struct soap *soap, const struct ns3__UnrecognizedPolicyRequestFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
  if (a->UnrecognizedPolicy) {
    int i;
    for (i = 0; i < a->__sizeUnrecognizedPolicy; i++) {
      soap_serialize__QName(soap, a->UnrecognizedPolicy + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const struct ns3__UnrecognizedPolicyRequestFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  if (a->UnrecognizedPolicy) {
    int i;
    for (i = 0; i < a->__sizeUnrecognizedPolicy; i++) {
      const char *soap_tmp_UnrecognizedPolicy = soap_QName2s(soap, a->UnrecognizedPolicy[i]);
      if (soap_out__QName(soap, "ns3:UnrecognizedPolicy", -1, (char*const*)&soap_tmp_UnrecognizedPolicy, ""))
        return soap->error;
    }
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_in_ns3__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, struct ns3__UnrecognizedPolicyRequestFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  struct soap_blist *soap_blist_UnrecognizedPolicy = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__UnrecognizedPolicyRequestFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType, sizeof(struct ns3__UnrecognizedPolicyRequestFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__UnrecognizedPolicyRequestFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:UnrecognizedPolicy", 1, NULL)) {
        if (a->UnrecognizedPolicy == NULL) {
          if (soap_blist_UnrecognizedPolicy == NULL)
            soap_blist_UnrecognizedPolicy = soap_new_block(soap);
          a->UnrecognizedPolicy = (char **)soap_push_block(soap, soap_blist_UnrecognizedPolicy, sizeof(char *));
          if (a->UnrecognizedPolicy == NULL)
            return NULL;
          *a->UnrecognizedPolicy = NULL;
        }
        soap_revert(soap);
        if (soap_in__QName(soap, "ns3:UnrecognizedPolicy", a->UnrecognizedPolicy, "")) {
          a->__sizeUnrecognizedPolicy++;
          a->UnrecognizedPolicy = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (a->UnrecognizedPolicy)
      soap_pop_block(soap, soap_blist_UnrecognizedPolicy);
    if (a->__sizeUnrecognizedPolicy)
      a->UnrecognizedPolicy = (char **)soap_save_block(soap, soap_blist_UnrecognizedPolicy, NULL, 1);
    else {
      a->UnrecognizedPolicy = NULL;
      if (soap_blist_UnrecognizedPolicy)
        soap_end_block(soap, soap_blist_UnrecognizedPolicy);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__UnrecognizedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType, 0, sizeof(struct ns3__UnrecognizedPolicyRequestFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__UnrecognizedPolicyRequestFaultType(struct soap *soap, const struct ns3__UnrecognizedPolicyRequestFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType);
  if (soap_out_ns3__UnrecognizedPolicyRequestFaultType(soap, tag?tag:"ns3:UnrecognizedPolicyRequestFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_get_ns3__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct ns3__UnrecognizedPolicyRequestFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__InvalidMessageContentExpressionFaultType(struct soap *soap, struct ns3__InvalidMessageContentExpressionFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__InvalidMessageContentExpressionFaultType(struct soap *soap, const struct ns3__InvalidMessageContentExpressionFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, const struct ns3__InvalidMessageContentExpressionFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_in_ns3__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, struct ns3__InvalidMessageContentExpressionFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__InvalidMessageContentExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType, sizeof(struct ns3__InvalidMessageContentExpressionFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__InvalidMessageContentExpressionFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__InvalidMessageContentExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType, 0, sizeof(struct ns3__InvalidMessageContentExpressionFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__InvalidMessageContentExpressionFaultType(struct soap *soap, const struct ns3__InvalidMessageContentExpressionFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType);
  if (soap_out_ns3__InvalidMessageContentExpressionFaultType(soap, tag?tag:"ns3:InvalidMessageContentExpressionFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_get_ns3__InvalidMessageContentExpressionFaultType(struct soap *soap, struct ns3__InvalidMessageContentExpressionFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct ns3__InvalidProducerPropertiesExpressionFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const struct ns3__InvalidProducerPropertiesExpressionFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, const struct ns3__InvalidProducerPropertiesExpressionFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_in_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, struct ns3__InvalidProducerPropertiesExpressionFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__InvalidProducerPropertiesExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType, sizeof(struct ns3__InvalidProducerPropertiesExpressionFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__InvalidProducerPropertiesExpressionFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__InvalidProducerPropertiesExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType, 0, sizeof(struct ns3__InvalidProducerPropertiesExpressionFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const struct ns3__InvalidProducerPropertiesExpressionFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType);
  if (soap_out_ns3__InvalidProducerPropertiesExpressionFaultType(soap, tag?tag:"ns3:InvalidProducerPropertiesExpressionFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_get_ns3__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct ns3__InvalidProducerPropertiesExpressionFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct ns3__MultipleTopicsSpecifiedFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__MultipleTopicsSpecifiedFaultType(struct soap *soap, const struct ns3__MultipleTopicsSpecifiedFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, const struct ns3__MultipleTopicsSpecifiedFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_in_ns3__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, struct ns3__MultipleTopicsSpecifiedFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__MultipleTopicsSpecifiedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType, sizeof(struct ns3__MultipleTopicsSpecifiedFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__MultipleTopicsSpecifiedFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__MultipleTopicsSpecifiedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType, 0, sizeof(struct ns3__MultipleTopicsSpecifiedFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__MultipleTopicsSpecifiedFaultType(struct soap *soap, const struct ns3__MultipleTopicsSpecifiedFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType);
  if (soap_out_ns3__MultipleTopicsSpecifiedFaultType(soap, tag?tag:"ns3:MultipleTopicsSpecifiedFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_get_ns3__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct ns3__MultipleTopicsSpecifiedFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__TopicNotSupportedFaultType(struct soap *soap, struct ns3__TopicNotSupportedFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__TopicNotSupportedFaultType(struct soap *soap, const struct ns3__TopicNotSupportedFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, const struct ns3__TopicNotSupportedFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TopicNotSupportedFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__TopicNotSupportedFaultType * SOAP_FMAC4 soap_in_ns3__TopicNotSupportedFaultType(struct soap *soap, const char *tag, struct ns3__TopicNotSupportedFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__TopicNotSupportedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TopicNotSupportedFaultType, sizeof(struct ns3__TopicNotSupportedFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__TopicNotSupportedFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__TopicNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TopicNotSupportedFaultType, 0, sizeof(struct ns3__TopicNotSupportedFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__TopicNotSupportedFaultType(struct soap *soap, const struct ns3__TopicNotSupportedFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__TopicNotSupportedFaultType);
  if (soap_out_ns3__TopicNotSupportedFaultType(soap, tag?tag:"ns3:TopicNotSupportedFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__TopicNotSupportedFaultType * SOAP_FMAC4 soap_get_ns3__TopicNotSupportedFaultType(struct soap *soap, struct ns3__TopicNotSupportedFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__TopicNotSupportedFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__InvalidTopicExpressionFaultType(struct soap *soap, struct ns3__InvalidTopicExpressionFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__InvalidTopicExpressionFaultType(struct soap *soap, const struct ns3__InvalidTopicExpressionFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, const struct ns3__InvalidTopicExpressionFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__InvalidTopicExpressionFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_ns3__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, struct ns3__InvalidTopicExpressionFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__InvalidTopicExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__InvalidTopicExpressionFaultType, sizeof(struct ns3__InvalidTopicExpressionFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__InvalidTopicExpressionFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__InvalidTopicExpressionFaultType, 0, sizeof(struct ns3__InvalidTopicExpressionFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__InvalidTopicExpressionFaultType(struct soap *soap, const struct ns3__InvalidTopicExpressionFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__InvalidTopicExpressionFaultType);
  if (soap_out_ns3__InvalidTopicExpressionFaultType(soap, tag?tag:"ns3:InvalidTopicExpressionFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_ns3__InvalidTopicExpressionFaultType(struct soap *soap, struct ns3__InvalidTopicExpressionFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__InvalidTopicExpressionFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct ns3__TopicExpressionDialectUnknownFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct ns3__TopicExpressionDialectUnknownFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const struct ns3__TopicExpressionDialectUnknownFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_ns3__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, struct ns3__TopicExpressionDialectUnknownFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__TopicExpressionDialectUnknownFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType, sizeof(struct ns3__TopicExpressionDialectUnknownFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__TopicExpressionDialectUnknownFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType, 0, sizeof(struct ns3__TopicExpressionDialectUnknownFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct ns3__TopicExpressionDialectUnknownFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType);
  if (soap_out_ns3__TopicExpressionDialectUnknownFaultType(soap, tag?tag:"ns3:TopicExpressionDialectUnknownFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_ns3__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct ns3__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__InvalidFilterFaultType(struct soap *soap, struct ns3__InvalidFilterFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
  a->__sizeUnknownFilter = 0;
  a->UnknownFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__InvalidFilterFaultType(struct soap *soap, const struct ns3__InvalidFilterFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
  if (a->UnknownFilter) {
    int i;
    for (i = 0; i < a->__sizeUnknownFilter; i++) {
      soap_serialize__QName(soap, a->UnknownFilter + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const struct ns3__InvalidFilterFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__InvalidFilterFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  if (a->UnknownFilter) {
    int i;
    for (i = 0; i < a->__sizeUnknownFilter; i++) {
      const char *soap_tmp_UnknownFilter = soap_QName2s(soap, a->UnknownFilter[i]);
      if (soap_out__QName(soap, "ns3:UnknownFilter", -1, (char*const*)&soap_tmp_UnknownFilter, ""))
        return soap->error;
    }
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__InvalidFilterFaultType * SOAP_FMAC4 soap_in_ns3__InvalidFilterFaultType(struct soap *soap, const char *tag, struct ns3__InvalidFilterFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  struct soap_blist *soap_blist_UnknownFilter = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__InvalidFilterFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__InvalidFilterFaultType, sizeof(struct ns3__InvalidFilterFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__InvalidFilterFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:UnknownFilter", 1, NULL)) {
        if (a->UnknownFilter == NULL) {
          if (soap_blist_UnknownFilter == NULL)
            soap_blist_UnknownFilter = soap_new_block(soap);
          a->UnknownFilter = (char **)soap_push_block(soap, soap_blist_UnknownFilter, sizeof(char *));
          if (a->UnknownFilter == NULL)
            return NULL;
          *a->UnknownFilter = NULL;
        }
        soap_revert(soap);
        if (soap_in__QName(soap, "ns3:UnknownFilter", a->UnknownFilter, "")) {
          a->__sizeUnknownFilter++;
          a->UnknownFilter = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (a->UnknownFilter)
      soap_pop_block(soap, soap_blist_UnknownFilter);
    if (a->__sizeUnknownFilter)
      a->UnknownFilter = (char **)soap_save_block(soap, soap_blist_UnknownFilter, NULL, 1);
    else {
      a->UnknownFilter = NULL;
      if (soap_blist_UnknownFilter)
        soap_end_block(soap, soap_blist_UnknownFilter);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__InvalidFilterFaultType, 0, sizeof(struct ns3__InvalidFilterFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0 || a->__sizeUnknownFilter < 1)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__InvalidFilterFaultType(struct soap *soap, const struct ns3__InvalidFilterFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__InvalidFilterFaultType);
  if (soap_out_ns3__InvalidFilterFaultType(soap, tag?tag:"ns3:InvalidFilterFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__InvalidFilterFaultType * SOAP_FMAC4 soap_get_ns3__InvalidFilterFaultType(struct soap *soap, struct ns3__InvalidFilterFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__InvalidFilterFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__SubscribeCreationFailedFaultType(struct soap *soap, struct ns3__SubscribeCreationFailedFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->ns7__Timestamp);
  a->ns7__Originator = NULL;
  a->ns7__ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->ns7__Description = NULL;
  a->ns7__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__SubscribeCreationFailedFaultType(struct soap *soap, const struct ns3__SubscribeCreationFailedFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ns7__Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ns7__Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ns7__ErrorCode);
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->ns7__Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->ns7__FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const struct ns3__SubscribeCreationFailedFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__SubscribeCreationFailedFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->ns7__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->ns7__Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ns7__ErrorCode, ""))
    return soap->error;
  if (a->ns7__Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->ns7__Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->ns7__FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_ns3__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, struct ns3__SubscribeCreationFailedFaultType *a, const char *type) {
  size_t soap_flag_ns7__Timestamp = 1;
  size_t soap_flag_ns7__Originator = 1;
  size_t soap_flag_ns7__ErrorCode = 1;
  struct soap_blist *soap_blist_ns7__Description = NULL;
  size_t soap_flag_ns7__FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__SubscribeCreationFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__SubscribeCreationFailedFaultType, sizeof(struct ns3__SubscribeCreationFailedFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__SubscribeCreationFailedFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ns7__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->ns7__Timestamp, "xsd:dateTime")) {
          soap_flag_ns7__Timestamp--;
          continue;
        }
      if (soap_flag_ns7__Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->ns7__Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_ns7__Originator--;
          continue;
        }
      if (soap_flag_ns7__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ns7__ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ns7__ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->ns7__Description == NULL) {
          if (soap_blist_ns7__Description == NULL)
            soap_blist_ns7__Description = soap_new_block(soap);
          a->ns7__Description = (char **)soap_push_block(soap, soap_blist_ns7__Description, sizeof(char *));
          if (a->ns7__Description == NULL)
            return NULL;
          *a->ns7__Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->ns7__Description, "xsd:string")) {
          a->__sizeDescription++;
          a->ns7__Description = NULL;
          continue;
        }
      }
      if (soap_flag_ns7__FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->ns7__FaultCause, "ns7:FaultCauseType")) {
          soap_flag_ns7__FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->ns7__Description)
      soap_pop_block(soap, soap_blist_ns7__Description);
    if (a->__sizeDescription)
      a->ns7__Description = (char **)soap_save_block(soap, soap_blist_ns7__Description, NULL, 1);
    else {
      a->ns7__Description = NULL;
      if (soap_blist_ns7__Description)
        soap_end_block(soap, soap_blist_ns7__Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__SubscribeCreationFailedFaultType, 0, sizeof(struct ns3__SubscribeCreationFailedFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__SubscribeCreationFailedFaultType(struct soap *soap, const struct ns3__SubscribeCreationFailedFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__SubscribeCreationFailedFaultType);
  if (soap_out_ns3__SubscribeCreationFailedFaultType(soap, tag?tag:"ns3:SubscribeCreationFailedFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_ns3__SubscribeCreationFailedFaultType(struct soap *soap, struct ns3__SubscribeCreationFailedFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__SubscribeCreationFailedFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__reservationResourceType_sequence(struct soap *soap, struct __ns1__reservationResourceType_sequence *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->localDetails = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__reservationResourceType_sequence(struct soap *soap, const struct __ns1__reservationResourceType_sequence *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__localDetails(soap, &a->localDetails);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__reservationResourceType_sequence(struct soap *soap, const char *tag, int id, const struct __ns1__reservationResourceType_sequence *a, const char *type) {
  if (soap_out_PointerTons1__localDetails(soap, "ns1:localDetails", -1, &a->localDetails, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reservationResourceType_sequence * SOAP_FMAC4 soap_in___ns1__reservationResourceType_sequence(struct soap *soap, const char *tag, struct __ns1__reservationResourceType_sequence *a, const char *type) {
  size_t soap_flag_localDetails = 1;
  short soap_flag;
  a = (struct __ns1__reservationResourceType_sequence *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__reservationResourceType_sequence, sizeof(struct __ns1__reservationResourceType_sequence), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns1__reservationResourceType_sequence(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_localDetails && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerTons1__localDetails(soap, "ns1:localDetails", &a->localDetails, "ns1:localDetails")) {
        soap_flag_localDetails--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__reservationResourceType_sequence(struct soap *soap, const struct __ns1__reservationResourceType_sequence *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns1__reservationResourceType_sequence(soap, tag?tag:"-ns1:reservationResourceType-sequence", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reservationResourceType_sequence * SOAP_FMAC4 soap_get___ns1__reservationResourceType_sequence(struct soap *soap, struct __ns1__reservationResourceType_sequence *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__reservationResourceType_sequence(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__reservationResourceType(struct soap *soap, struct ns1__reservationResourceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->globalReservationId);
  soap_default_string(soap, &a->description);
  a->userRequestConstraint = NULL;
  a->reservedConstraint = NULL;
  a->__sizeoptionalConstraint = 0;
  a->optionalConstraint = NULL;
  a->__size_reservationResourceType_sequence = 0;
  a->__reservationResourceType_sequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__reservationResourceType(struct soap *soap, const struct ns1__reservationResourceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->globalReservationId);
  soap_serialize_string(soap, &a->description);
  soap_serialize_PointerTons1__userRequestConstraintType(soap, &a->userRequestConstraint);
  soap_serialize_PointerTons1__reservedConstraintType(soap, &a->reservedConstraint);
  if (a->optionalConstraint) {
    int i;
    for (i = 0; i < a->__sizeoptionalConstraint; i++) {
      soap_serialize_PointerTons1__optionalConstraintType(soap, a->optionalConstraint + i);
    }
  }
  if (a->__reservationResourceType_sequence) {
    int i;
    for (i = 0; i < a->__size_reservationResourceType_sequence; i++) {
      soap_serialize___ns1__reservationResourceType_sequence(soap, a->__reservationResourceType_sequence + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__reservationResourceType(struct soap *soap, const char *tag, int id, const struct ns1__reservationResourceType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__reservationResourceType), type))
    return soap->error;
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
    return soap->error;
  if (a->description) {
    if (soap_out_string(soap, "ns1:description", -1, &a->description, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:description"))
    return soap->error;
  if (a->userRequestConstraint) {
    if (soap_out_PointerTons1__userRequestConstraintType(soap, "ns1:userRequestConstraint", -1, &a->userRequestConstraint, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:userRequestConstraint"))
    return soap->error;
  if (soap_out_PointerTons1__reservedConstraintType(soap, "ns1:reservedConstraint", -1, &a->reservedConstraint, ""))
    return soap->error;
  if (a->optionalConstraint) {
    int i;
    for (i = 0; i < a->__sizeoptionalConstraint; i++)
      if (soap_out_PointerTons1__optionalConstraintType(soap, "ns1:optionalConstraint", -1, a->optionalConstraint + i, ""))
        return soap->error;
  }
  if (a->__reservationResourceType_sequence) {
    int i;
    for (i = 0; i < a->__size_reservationResourceType_sequence; i++)
      if (soap_out___ns1__reservationResourceType_sequence(soap, "-reservationResourceType-sequence", -1, a->__reservationResourceType_sequence + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__reservationResourceType * SOAP_FMAC4 soap_in_ns1__reservationResourceType(struct soap *soap, const char *tag, struct ns1__reservationResourceType *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_globalReservationId = 1;
  size_t soap_flag_description = 1;
  size_t soap_flag_userRequestConstraint = 1;
  size_t soap_flag_reservedConstraint = 1;
  struct soap_blist *soap_blist_optionalConstraint = NULL;
  struct soap_blist *soap_blist___reservationResourceType_sequence = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__reservationResourceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__reservationResourceType, sizeof(struct ns1__reservationResourceType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__reservationResourceType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:description", &a->description, "xsd:string")) {
          soap_flag_description--;
          continue;
        }
      if (soap_flag_userRequestConstraint && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__userRequestConstraintType(soap, "ns1:userRequestConstraint", &a->userRequestConstraint, "ns1:userRequestConstraintType")) {
          soap_flag_userRequestConstraint--;
          continue;
        }
      if (soap_flag_reservedConstraint && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__reservedConstraintType(soap, "ns1:reservedConstraint", &a->reservedConstraint, "ns1:reservedConstraintType")) {
          soap_flag_reservedConstraint--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:optionalConstraint", 1, NULL)) {
        if (a->optionalConstraint == NULL) {
          if (soap_blist_optionalConstraint == NULL)
            soap_blist_optionalConstraint = soap_new_block(soap);
          a->optionalConstraint = (struct ns1__optionalConstraintType **)soap_push_block(soap, soap_blist_optionalConstraint, sizeof(struct ns1__optionalConstraintType *));
          if (a->optionalConstraint == NULL)
            return NULL;
          *a->optionalConstraint = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons1__optionalConstraintType(soap, "ns1:optionalConstraint", a->optionalConstraint, "ns1:optionalConstraintType")) {
          a->__sizeoptionalConstraint++;
          a->optionalConstraint = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__reservationResourceType_sequence == NULL) {
          if (soap_blist___reservationResourceType_sequence == NULL)
            soap_blist___reservationResourceType_sequence = soap_new_block(soap);
          a->__reservationResourceType_sequence = (struct __ns1__reservationResourceType_sequence *)soap_push_block(soap, soap_blist___reservationResourceType_sequence, sizeof(struct __ns1__reservationResourceType_sequence));
          if (a->__reservationResourceType_sequence == NULL)
            return NULL;
          soap_default___ns1__reservationResourceType_sequence(soap, a->__reservationResourceType_sequence);
        }
        if (soap_in___ns1__reservationResourceType_sequence(soap, "-reservationResourceType-sequence", a->__reservationResourceType_sequence, "-ns1:reservationResourceType-sequence")) {
          a->__size_reservationResourceType_sequence++;
          a->__reservationResourceType_sequence = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->optionalConstraint)
      soap_pop_block(soap, soap_blist_optionalConstraint);
    if (a->__sizeoptionalConstraint)
      a->optionalConstraint = (struct ns1__optionalConstraintType **)soap_save_block(soap, soap_blist_optionalConstraint, NULL, 1);
    else {
      a->optionalConstraint = NULL;
      if (soap_blist_optionalConstraint)
        soap_end_block(soap, soap_blist_optionalConstraint);
    }
    if (a->__reservationResourceType_sequence)
      soap_pop_block(soap, soap_blist___reservationResourceType_sequence);
    if (a->__size_reservationResourceType_sequence)
      a->__reservationResourceType_sequence = (struct __ns1__reservationResourceType_sequence *)soap_save_block(soap, soap_blist___reservationResourceType_sequence, NULL, 1);
    else {
      a->__reservationResourceType_sequence = NULL;
      if (soap_blist___reservationResourceType_sequence)
        soap_end_block(soap, soap_blist___reservationResourceType_sequence);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__reservationResourceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__reservationResourceType, 0, sizeof(struct ns1__reservationResourceType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_description > 0 || soap_flag_userRequestConstraint > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__reservationResourceType(struct soap *soap, const struct ns1__reservationResourceType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__reservationResourceType);
  if (soap_out_ns1__reservationResourceType(soap, tag?tag:"ns1:reservationResourceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__reservationResourceType * SOAP_FMAC4 soap_get_ns1__reservationResourceType(struct soap *soap, struct ns1__reservationResourceType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__reservationResourceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__union_EvidenceType(struct soap *soap, struct __ns8__union_EvidenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__union_EvidenceType = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__union_EvidenceType(struct soap *soap, const struct __ns8__union_EvidenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__ns8__union_EvidenceType(soap, a->__union_EvidenceType, &a->union_EvidenceType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__union_EvidenceType(struct soap *soap, const char *tag, int id, const struct __ns8__union_EvidenceType *a, const char *type) {
  if (soap_out__ns8__union_EvidenceType(soap, a->__union_EvidenceType, &a->union_EvidenceType))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__union_EvidenceType * SOAP_FMAC4 soap_in___ns8__union_EvidenceType(struct soap *soap, const char *tag, struct __ns8__union_EvidenceType *a, const char *type) {
  a = (struct __ns8__union_EvidenceType *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__union_EvidenceType, sizeof(struct __ns8__union_EvidenceType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns8__union_EvidenceType(soap, a);
  if (!soap_in__ns8__union_EvidenceType(soap, &a->__union_EvidenceType, &a->union_EvidenceType))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__union_EvidenceType(struct soap *soap, const struct __ns8__union_EvidenceType *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns8__union_EvidenceType(soap, tag?tag:"-ns8:union-EvidenceType", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__union_EvidenceType * SOAP_FMAC4 soap_get___ns8__union_EvidenceType(struct soap *soap, struct __ns8__union_EvidenceType *p, const char *tag, const char *type) {
  if ((p = soap_in___ns8__union_EvidenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__EvidenceType(struct soap *soap, struct ns8__EvidenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size_EvidenceType = 0;
  a->__union_EvidenceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__EvidenceType(struct soap *soap, const struct ns8__EvidenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->__union_EvidenceType) {
    int i;
    for (i = 0; i < a->__size_EvidenceType; i++) {
      soap_serialize___ns8__union_EvidenceType(soap, a->__union_EvidenceType + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__EvidenceType(struct soap *soap, const char *tag, int id, const struct ns8__EvidenceType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__EvidenceType), type))
    return soap->error;
  if (a->__union_EvidenceType) {
    int i;
    for (i = 0; i < a->__size_EvidenceType; i++)
      if (soap_out___ns8__union_EvidenceType(soap, "-union-EvidenceType", -1, a->__union_EvidenceType + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__EvidenceType * SOAP_FMAC4 soap_in_ns8__EvidenceType(struct soap *soap, const char *tag, struct ns8__EvidenceType *a, const char *type) {
  struct soap_blist *soap_blist___union_EvidenceType = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__EvidenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__EvidenceType, sizeof(struct ns8__EvidenceType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__EvidenceType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__union_EvidenceType == NULL) {
          if (soap_blist___union_EvidenceType == NULL)
            soap_blist___union_EvidenceType = soap_new_block(soap);
          a->__union_EvidenceType = (struct __ns8__union_EvidenceType *)soap_push_block(soap, soap_blist___union_EvidenceType, sizeof(struct __ns8__union_EvidenceType));
          if (a->__union_EvidenceType == NULL)
            return NULL;
          soap_default___ns8__union_EvidenceType(soap, a->__union_EvidenceType);
        }
        if (soap_in___ns8__union_EvidenceType(soap, "-union-EvidenceType", a->__union_EvidenceType, "-ns8:union-EvidenceType")) {
          a->__size_EvidenceType++;
          a->__union_EvidenceType = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__union_EvidenceType)
      soap_pop_block(soap, soap_blist___union_EvidenceType);
    if (a->__size_EvidenceType)
      a->__union_EvidenceType = (struct __ns8__union_EvidenceType *)soap_save_block(soap, soap_blist___union_EvidenceType, NULL, 1);
    else {
      a->__union_EvidenceType = NULL;
      if (soap_blist___union_EvidenceType)
        soap_end_block(soap, soap_blist___union_EvidenceType);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__EvidenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__EvidenceType, 0, sizeof(struct ns8__EvidenceType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__EvidenceType(struct soap *soap, const struct ns8__EvidenceType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__EvidenceType);
  if (soap_out_ns8__EvidenceType(soap, tag?tag:"ns8:EvidenceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__EvidenceType * SOAP_FMAC4 soap_get_ns8__EvidenceType(struct soap *soap, struct ns8__EvidenceType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__EvidenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__AuthnContextType(struct soap *soap, struct ns8__AuthnContextType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->AuthnContextClassRef);
  a->__union_AuthnContextType_ = 0;
  a->__union_AuthnContextType__ = 0;
  a->__sizeAuthenticatingAuthority = 0;
  a->AuthenticatingAuthority = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__AuthnContextType(struct soap *soap, const struct ns8__AuthnContextType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->AuthnContextClassRef);
  soap_serialize__ns8__union_AuthnContextType_(soap, a->__union_AuthnContextType_, &a->union_AuthnContextType_);
  soap_serialize__ns8__union_AuthnContextType__(soap, a->__union_AuthnContextType__, &a->union_AuthnContextType__);
  if (a->AuthenticatingAuthority) {
    int i;
    for (i = 0; i < a->__sizeAuthenticatingAuthority; i++) {
      soap_serialize_string(soap, a->AuthenticatingAuthority + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__AuthnContextType(struct soap *soap, const char *tag, int id, const struct ns8__AuthnContextType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__AuthnContextType), type))
    return soap->error;
  if (soap_out_string(soap, "AuthnContextClassRef", -1, &a->AuthnContextClassRef, ""))
    return soap->error;
  if (soap_out__ns8__union_AuthnContextType_(soap, a->__union_AuthnContextType_, &a->union_AuthnContextType_))
    return soap->error;
  if (soap_out__ns8__union_AuthnContextType__(soap, a->__union_AuthnContextType__, &a->union_AuthnContextType__))
    return soap->error;
  if (a->AuthenticatingAuthority) {
    int i;
    for (i = 0; i < a->__sizeAuthenticatingAuthority; i++)
      if (soap_out_string(soap, "AuthenticatingAuthority", -1, a->AuthenticatingAuthority + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__AuthnContextType * SOAP_FMAC4 soap_in_ns8__AuthnContextType(struct soap *soap, const char *tag, struct ns8__AuthnContextType *a, const char *type) {
  size_t soap_flag_AuthnContextClassRef = 1;
  size_t soap_flag_union_AuthnContextType_ = 1;
  size_t soap_flag_union_AuthnContextType__ = 1;
  struct soap_blist *soap_blist_AuthenticatingAuthority = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__AuthnContextType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__AuthnContextType, sizeof(struct ns8__AuthnContextType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__AuthnContextType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_AuthnContextClassRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "AuthnContextClassRef", &a->AuthnContextClassRef, "xsd:string")) {
          soap_flag_AuthnContextClassRef--;
          continue;
        }
      if (soap_flag_union_AuthnContextType_ && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in__ns8__union_AuthnContextType_(soap, &a->__union_AuthnContextType_, &a->union_AuthnContextType_)) {
          soap_flag_union_AuthnContextType_ = 0;
          continue;
        }
      if (soap_flag_union_AuthnContextType__ && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in__ns8__union_AuthnContextType__(soap, &a->__union_AuthnContextType__, &a->union_AuthnContextType__)) {
          soap_flag_union_AuthnContextType__ = 0;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "AuthenticatingAuthority", 1, NULL)) {
        if (a->AuthenticatingAuthority == NULL) {
          if (soap_blist_AuthenticatingAuthority == NULL)
            soap_blist_AuthenticatingAuthority = soap_new_block(soap);
          a->AuthenticatingAuthority = (char **)soap_push_block(soap, soap_blist_AuthenticatingAuthority, sizeof(char *));
          if (a->AuthenticatingAuthority == NULL)
            return NULL;
          *a->AuthenticatingAuthority = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "AuthenticatingAuthority", a->AuthenticatingAuthority, "xsd:string")) {
          a->__sizeAuthenticatingAuthority++;
          a->AuthenticatingAuthority = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->AuthenticatingAuthority)
      soap_pop_block(soap, soap_blist_AuthenticatingAuthority);
    if (a->__sizeAuthenticatingAuthority)
      a->AuthenticatingAuthority = (char **)soap_save_block(soap, soap_blist_AuthenticatingAuthority, NULL, 1);
    else {
      a->AuthenticatingAuthority = NULL;
      if (soap_blist_AuthenticatingAuthority)
        soap_end_block(soap, soap_blist_AuthenticatingAuthority);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__AuthnContextType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__AuthnContextType, 0, sizeof(struct ns8__AuthnContextType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_AuthnContextType__)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__AuthnContextType(struct soap *soap, const struct ns8__AuthnContextType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__AuthnContextType);
  if (soap_out_ns8__AuthnContextType(soap, tag?tag:"ns8:AuthnContextType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AuthnContextType * SOAP_FMAC4 soap_get_ns8__AuthnContextType(struct soap *soap, struct ns8__AuthnContextType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__AuthnContextType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__SubjectLocalityType(struct soap *soap, struct ns8__SubjectLocalityType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->Address);
  soap_default_string(soap, &a->DNSName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__SubjectLocalityType(struct soap *soap, const struct ns8__SubjectLocalityType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__SubjectLocalityType(struct soap *soap, const char *tag, int id, const struct ns8__SubjectLocalityType *a, const char *type) {
  if (a->Address)
    soap_set_attr(soap, "Address", a->Address, 1);
  if (a->DNSName)
    soap_set_attr(soap, "DNSName", a->DNSName, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__SubjectLocalityType), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__SubjectLocalityType * SOAP_FMAC4 soap_in_ns8__SubjectLocalityType(struct soap *soap, const char *tag, struct ns8__SubjectLocalityType *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__SubjectLocalityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__SubjectLocalityType, sizeof(struct ns8__SubjectLocalityType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__SubjectLocalityType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Address", 0), &a->Address, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "DNSName", 0), &a->DNSName, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__SubjectLocalityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__SubjectLocalityType, 0, sizeof(struct ns8__SubjectLocalityType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__SubjectLocalityType(struct soap *soap, const struct ns8__SubjectLocalityType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__SubjectLocalityType);
  if (soap_out_ns8__SubjectLocalityType(soap, tag?tag:"ns8:SubjectLocalityType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__SubjectLocalityType * SOAP_FMAC4 soap_get_ns8__SubjectLocalityType(struct soap *soap, struct ns8__SubjectLocalityType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__SubjectLocalityType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__union_AdviceType(struct soap *soap, struct __ns8__union_AdviceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__union_AdviceType = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__union_AdviceType(struct soap *soap, const struct __ns8__union_AdviceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__ns8__union_AdviceType(soap, a->__union_AdviceType, &a->union_AdviceType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__union_AdviceType(struct soap *soap, const char *tag, int id, const struct __ns8__union_AdviceType *a, const char *type) {
  if (soap_out__ns8__union_AdviceType(soap, a->__union_AdviceType, &a->union_AdviceType))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__union_AdviceType * SOAP_FMAC4 soap_in___ns8__union_AdviceType(struct soap *soap, const char *tag, struct __ns8__union_AdviceType *a, const char *type) {
  a = (struct __ns8__union_AdviceType *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__union_AdviceType, sizeof(struct __ns8__union_AdviceType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns8__union_AdviceType(soap, a);
  if (!soap_in__ns8__union_AdviceType(soap, &a->__union_AdviceType, &a->union_AdviceType))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__union_AdviceType(struct soap *soap, const struct __ns8__union_AdviceType *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns8__union_AdviceType(soap, tag?tag:"-ns8:union-AdviceType", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__union_AdviceType * SOAP_FMAC4 soap_get___ns8__union_AdviceType(struct soap *soap, struct __ns8__union_AdviceType *p, const char *tag, const char *type) {
  if ((p = soap_in___ns8__union_AdviceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__ProxyRestrictionType(struct soap *soap, struct ns8__ProxyRestrictionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__sizeAudience = 0;
  a->Audience = NULL;
  a->Count = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__ProxyRestrictionType(struct soap *soap, const struct ns8__ProxyRestrictionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->Audience) {
    int i;
    for (i = 0; i < a->__sizeAudience; i++) {
      soap_serialize_string(soap, a->Audience + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__ProxyRestrictionType(struct soap *soap, const char *tag, int id, const struct ns8__ProxyRestrictionType *a, const char *type) {
  if (a->Count)
    soap_set_attr(soap, "Count", soap_unsignedInt2s(soap, *a->Count), 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__ProxyRestrictionType), type))
    return soap->error;
  if (a->Audience) {
    int i;
    for (i = 0; i < a->__sizeAudience; i++)
      if (soap_out_string(soap, "Audience", -1, a->Audience + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__ProxyRestrictionType * SOAP_FMAC4 soap_in_ns8__ProxyRestrictionType(struct soap *soap, const char *tag, struct ns8__ProxyRestrictionType *a, const char *type) {
  struct soap_blist *soap_blist_Audience = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__ProxyRestrictionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__ProxyRestrictionType, sizeof(struct ns8__ProxyRestrictionType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__ProxyRestrictionType(soap, a);
  {
    const char *t = soap_attr_value(soap, "Count", 0);
    if (t) {
      if (!(a->Count = (unsigned int *)soap_malloc(soap, sizeof(unsigned int)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2unsignedInt(soap, t, a->Count))
        return NULL;
    }
    else if (soap->error)
      return NULL;
  }
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "Audience", 1, NULL)) {
        if (a->Audience == NULL) {
          if (soap_blist_Audience == NULL)
            soap_blist_Audience = soap_new_block(soap);
          a->Audience = (char **)soap_push_block(soap, soap_blist_Audience, sizeof(char *));
          if (a->Audience == NULL)
            return NULL;
          *a->Audience = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "Audience", a->Audience, "xsd:string")) {
          a->__sizeAudience++;
          a->Audience = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->Audience)
      soap_pop_block(soap, soap_blist_Audience);
    if (a->__sizeAudience)
      a->Audience = (char **)soap_save_block(soap, soap_blist_Audience, NULL, 1);
    else {
      a->Audience = NULL;
      if (soap_blist_Audience)
        soap_end_block(soap, soap_blist_Audience);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__ProxyRestrictionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__ProxyRestrictionType, 0, sizeof(struct ns8__ProxyRestrictionType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__ProxyRestrictionType(struct soap *soap, const struct ns8__ProxyRestrictionType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__ProxyRestrictionType);
  if (soap_out_ns8__ProxyRestrictionType(soap, tag?tag:"ns8:ProxyRestrictionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ProxyRestrictionType * SOAP_FMAC4 soap_get_ns8__ProxyRestrictionType(struct soap *soap, struct ns8__ProxyRestrictionType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__ProxyRestrictionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__OneTimeUseType(struct soap *soap, struct ns8__OneTimeUseType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__OneTimeUseType(struct soap *soap, const struct ns8__OneTimeUseType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__OneTimeUseType(struct soap *soap, const char *tag, int id, const struct ns8__OneTimeUseType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__OneTimeUseType), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__OneTimeUseType * SOAP_FMAC4 soap_in_ns8__OneTimeUseType(struct soap *soap, const char *tag, struct ns8__OneTimeUseType *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__OneTimeUseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__OneTimeUseType, sizeof(struct ns8__OneTimeUseType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__OneTimeUseType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__OneTimeUseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__OneTimeUseType, 0, sizeof(struct ns8__OneTimeUseType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__OneTimeUseType(struct soap *soap, const struct ns8__OneTimeUseType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__OneTimeUseType);
  if (soap_out_ns8__OneTimeUseType(soap, tag?tag:"ns8:OneTimeUseType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__OneTimeUseType * SOAP_FMAC4 soap_get_ns8__OneTimeUseType(struct soap *soap, struct ns8__OneTimeUseType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__OneTimeUseType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__AudienceRestrictionType(struct soap *soap, struct ns8__AudienceRestrictionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__sizeAudience = 0;
  a->Audience = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__AudienceRestrictionType(struct soap *soap, const struct ns8__AudienceRestrictionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->Audience) {
    int i;
    for (i = 0; i < a->__sizeAudience; i++) {
      soap_serialize_string(soap, a->Audience + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__AudienceRestrictionType(struct soap *soap, const char *tag, int id, const struct ns8__AudienceRestrictionType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__AudienceRestrictionType), type))
    return soap->error;
  if (a->Audience) {
    int i;
    for (i = 0; i < a->__sizeAudience; i++)
      if (soap_out_string(soap, "Audience", -1, a->Audience + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__AudienceRestrictionType * SOAP_FMAC4 soap_in_ns8__AudienceRestrictionType(struct soap *soap, const char *tag, struct ns8__AudienceRestrictionType *a, const char *type) {
  struct soap_blist *soap_blist_Audience = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__AudienceRestrictionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__AudienceRestrictionType, sizeof(struct ns8__AudienceRestrictionType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__AudienceRestrictionType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "Audience", 1, NULL)) {
        if (a->Audience == NULL) {
          if (soap_blist_Audience == NULL)
            soap_blist_Audience = soap_new_block(soap);
          a->Audience = (char **)soap_push_block(soap, soap_blist_Audience, sizeof(char *));
          if (a->Audience == NULL)
            return NULL;
          *a->Audience = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "Audience", a->Audience, "xsd:string")) {
          a->__sizeAudience++;
          a->Audience = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->Audience)
      soap_pop_block(soap, soap_blist_Audience);
    if (a->__sizeAudience)
      a->Audience = (char **)soap_save_block(soap, soap_blist_Audience, NULL, 1);
    else {
      a->Audience = NULL;
      if (soap_blist_Audience)
        soap_end_block(soap, soap_blist_Audience);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__AudienceRestrictionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__AudienceRestrictionType, 0, sizeof(struct ns8__AudienceRestrictionType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAudience < 1)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__AudienceRestrictionType(struct soap *soap, const struct ns8__AudienceRestrictionType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__AudienceRestrictionType);
  if (soap_out_ns8__AudienceRestrictionType(soap, tag?tag:"ns8:AudienceRestrictionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AudienceRestrictionType * SOAP_FMAC4 soap_get_ns8__AudienceRestrictionType(struct soap *soap, struct ns8__AudienceRestrictionType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__AudienceRestrictionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__ConditionAbstractType(struct soap *soap, struct ns8__ConditionAbstractType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__ConditionAbstractType(struct soap *soap, const struct ns8__ConditionAbstractType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__ConditionAbstractType(struct soap *soap, const char *tag, int id, const struct ns8__ConditionAbstractType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__ConditionAbstractType), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__ConditionAbstractType * SOAP_FMAC4 soap_in_ns8__ConditionAbstractType(struct soap *soap, const char *tag, struct ns8__ConditionAbstractType *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__ConditionAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__ConditionAbstractType, sizeof(struct ns8__ConditionAbstractType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__ConditionAbstractType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__ConditionAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__ConditionAbstractType, 0, sizeof(struct ns8__ConditionAbstractType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__ConditionAbstractType(struct soap *soap, const struct ns8__ConditionAbstractType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__ConditionAbstractType);
  if (soap_out_ns8__ConditionAbstractType(soap, tag?tag:"ns8:ConditionAbstractType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ConditionAbstractType * SOAP_FMAC4 soap_get_ns8__ConditionAbstractType(struct soap *soap, struct ns8__ConditionAbstractType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__ConditionAbstractType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__union_ConditionsType(struct soap *soap, struct __ns8__union_ConditionsType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__union_ConditionsType = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__union_ConditionsType(struct soap *soap, const struct __ns8__union_ConditionsType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__ns8__union_ConditionsType(soap, a->__union_ConditionsType, &a->union_ConditionsType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__union_ConditionsType(struct soap *soap, const char *tag, int id, const struct __ns8__union_ConditionsType *a, const char *type) {
  if (soap_out__ns8__union_ConditionsType(soap, a->__union_ConditionsType, &a->union_ConditionsType))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__union_ConditionsType * SOAP_FMAC4 soap_in___ns8__union_ConditionsType(struct soap *soap, const char *tag, struct __ns8__union_ConditionsType *a, const char *type) {
  a = (struct __ns8__union_ConditionsType *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__union_ConditionsType, sizeof(struct __ns8__union_ConditionsType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns8__union_ConditionsType(soap, a);
  if (!soap_in__ns8__union_ConditionsType(soap, &a->__union_ConditionsType, &a->union_ConditionsType))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__union_ConditionsType(struct soap *soap, const struct __ns8__union_ConditionsType *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns8__union_ConditionsType(soap, tag?tag:"-ns8:union-ConditionsType", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__union_ConditionsType * SOAP_FMAC4 soap_get___ns8__union_ConditionsType(struct soap *soap, struct __ns8__union_ConditionsType *p, const char *tag, const char *type) {
  if ((p = soap_in___ns8__union_ConditionsType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__SubjectConfirmationDataType(struct soap *soap, struct ns8__SubjectConfirmationDataType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size = 0;
  a->__any = NULL;
  a->NotBefore = NULL;
  a->NotOnOrAfter = NULL;
  soap_default_string(soap, &a->Recipient);
  soap_default_string(soap, &a->InResponseTo);
  soap_default_string(soap, &a->Address);
  a->__anyAttribute = NULL;
  a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__SubjectConfirmationDataType(struct soap *soap, const struct ns8__SubjectConfirmationDataType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__SubjectConfirmationDataType(struct soap *soap, const char *tag, int id, const struct ns8__SubjectConfirmationDataType *a, const char *type) {
  if (a->NotBefore)
    soap_set_attr(soap, "NotBefore", soap_dateTime2s(soap, *a->NotBefore), 1);
  if (a->NotOnOrAfter)
    soap_set_attr(soap, "NotOnOrAfter", soap_dateTime2s(soap, *a->NotOnOrAfter), 1);
  if (a->Recipient)
    soap_set_attr(soap, "Recipient", a->Recipient, 1);
  if (a->InResponseTo)
    soap_set_attr(soap, "InResponseTo", a->InResponseTo, 1);
  if (a->Address)
    soap_set_attr(soap, "Address", a->Address, 1);
  if (a->__anyAttribute)
    soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__SubjectConfirmationDataType), type))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__SubjectConfirmationDataType * SOAP_FMAC4 soap_in_ns8__SubjectConfirmationDataType(struct soap *soap, const char *tag, struct ns8__SubjectConfirmationDataType *a, const char *type) {
  struct soap_blist *soap_blist___any = NULL;
  size_t soap_flag___mixed = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__SubjectConfirmationDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__SubjectConfirmationDataType, sizeof(struct ns8__SubjectConfirmationDataType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__SubjectConfirmationDataType(soap, a);
  {
    const char *t = soap_attr_value(soap, "NotBefore", 0);
    if (t) {
      if (!(a->NotBefore = (time_t *)soap_malloc(soap, sizeof(time_t)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2dateTime(soap, t, a->NotBefore))
        return NULL;
    }
    else if (soap->error)
      return NULL;
  }
  {
    const char *t = soap_attr_value(soap, "NotOnOrAfter", 0);
    if (t) {
      if (!(a->NotOnOrAfter = (time_t *)soap_malloc(soap, sizeof(time_t)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2dateTime(soap, t, a->NotOnOrAfter))
        return NULL;
    }
    else if (soap->error)
      return NULL;
  }
  if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 0), &a->Recipient, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "InResponseTo", 0), &a->InResponseTo, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Address", 0), &a->Address, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-mixed", &a->__mixed)) {
          soap_flag___mixed--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__SubjectConfirmationDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__SubjectConfirmationDataType, 0, sizeof(struct ns8__SubjectConfirmationDataType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__SubjectConfirmationDataType(struct soap *soap, const struct ns8__SubjectConfirmationDataType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__SubjectConfirmationDataType);
  if (soap_out_ns8__SubjectConfirmationDataType(soap, tag?tag:"ns8:SubjectConfirmationDataType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__SubjectConfirmationDataType * SOAP_FMAC4 soap_get_ns8__SubjectConfirmationDataType(struct soap *soap, struct ns8__SubjectConfirmationDataType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__SubjectConfirmationDataType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__SubjectConfirmationType(struct soap *soap, struct ns8__SubjectConfirmationType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__union_SubjectConfirmationType = 0;
  a->SubjectConfirmationData = NULL;
  soap_default_string(soap, &a->Method);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__SubjectConfirmationType(struct soap *soap, const struct ns8__SubjectConfirmationType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__ns8__union_SubjectConfirmationType(soap, a->__union_SubjectConfirmationType, &a->union_SubjectConfirmationType);
  soap_serialize_PointerTons8__SubjectConfirmationDataType(soap, &a->SubjectConfirmationData);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__SubjectConfirmationType(struct soap *soap, const char *tag, int id, const struct ns8__SubjectConfirmationType *a, const char *type) {
  if (a->Method)
    soap_set_attr(soap, "Method", a->Method, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__SubjectConfirmationType), type))
    return soap->error;
  if (soap_out__ns8__union_SubjectConfirmationType(soap, a->__union_SubjectConfirmationType, &a->union_SubjectConfirmationType))
    return soap->error;
  if (soap_out_PointerTons8__SubjectConfirmationDataType(soap, "SubjectConfirmationData", -1, &a->SubjectConfirmationData, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__SubjectConfirmationType * SOAP_FMAC4 soap_in_ns8__SubjectConfirmationType(struct soap *soap, const char *tag, struct ns8__SubjectConfirmationType *a, const char *type) {
  size_t soap_flag_union_SubjectConfirmationType = 1;
  size_t soap_flag_SubjectConfirmationData = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__SubjectConfirmationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__SubjectConfirmationType, sizeof(struct ns8__SubjectConfirmationType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__SubjectConfirmationType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Method", 1), &a->Method, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_union_SubjectConfirmationType && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in__ns8__union_SubjectConfirmationType(soap, &a->__union_SubjectConfirmationType, &a->union_SubjectConfirmationType)) {
          soap_flag_union_SubjectConfirmationType = 0;
          continue;
        }
      if (soap_flag_SubjectConfirmationData && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons8__SubjectConfirmationDataType(soap, "SubjectConfirmationData", &a->SubjectConfirmationData, "ns8:SubjectConfirmationDataType")) {
          soap_flag_SubjectConfirmationData--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__SubjectConfirmationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__SubjectConfirmationType, 0, sizeof(struct ns8__SubjectConfirmationType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__SubjectConfirmationType(struct soap *soap, const struct ns8__SubjectConfirmationType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__SubjectConfirmationType);
  if (soap_out_ns8__SubjectConfirmationType(soap, tag?tag:"ns8:SubjectConfirmationType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__SubjectConfirmationType * SOAP_FMAC4 soap_get_ns8__SubjectConfirmationType(struct soap *soap, struct ns8__SubjectConfirmationType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__SubjectConfirmationType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__AttributeStatementType(struct soap *soap, struct ns8__AttributeStatementType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size_AttributeStatementType = 0;
  a->__union_AttributeStatementType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__AttributeStatementType(struct soap *soap, const struct ns8__AttributeStatementType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->__union_AttributeStatementType) {
    int i;
    for (i = 0; i < a->__size_AttributeStatementType; i++) {
      soap_serialize___ns8__union_AttributeStatementType(soap, a->__union_AttributeStatementType + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__AttributeStatementType(struct soap *soap, const char *tag, int id, const struct ns8__AttributeStatementType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__AttributeStatementType), type))
    return soap->error;
  if (a->__union_AttributeStatementType) {
    int i;
    for (i = 0; i < a->__size_AttributeStatementType; i++)
      if (soap_out___ns8__union_AttributeStatementType(soap, "-union-AttributeStatementType", -1, a->__union_AttributeStatementType + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__AttributeStatementType * SOAP_FMAC4 soap_in_ns8__AttributeStatementType(struct soap *soap, const char *tag, struct ns8__AttributeStatementType *a, const char *type) {
  struct soap_blist *soap_blist___union_AttributeStatementType = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__AttributeStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__AttributeStatementType, sizeof(struct ns8__AttributeStatementType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__AttributeStatementType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__union_AttributeStatementType == NULL) {
          if (soap_blist___union_AttributeStatementType == NULL)
            soap_blist___union_AttributeStatementType = soap_new_block(soap);
          a->__union_AttributeStatementType = (struct __ns8__union_AttributeStatementType *)soap_push_block(soap, soap_blist___union_AttributeStatementType, sizeof(struct __ns8__union_AttributeStatementType));
          if (a->__union_AttributeStatementType == NULL)
            return NULL;
          soap_default___ns8__union_AttributeStatementType(soap, a->__union_AttributeStatementType);
        }
        if (soap_in___ns8__union_AttributeStatementType(soap, "-union-AttributeStatementType", a->__union_AttributeStatementType, "-ns8:union-AttributeStatementType")) {
          a->__size_AttributeStatementType++;
          a->__union_AttributeStatementType = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__union_AttributeStatementType)
      soap_pop_block(soap, soap_blist___union_AttributeStatementType);
    if (a->__size_AttributeStatementType)
      a->__union_AttributeStatementType = (struct __ns8__union_AttributeStatementType *)soap_save_block(soap, soap_blist___union_AttributeStatementType, NULL, 1);
    else {
      a->__union_AttributeStatementType = NULL;
      if (soap_blist___union_AttributeStatementType)
        soap_end_block(soap, soap_blist___union_AttributeStatementType);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__AttributeStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__AttributeStatementType, 0, sizeof(struct ns8__AttributeStatementType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__AttributeStatementType(struct soap *soap, const struct ns8__AttributeStatementType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__AttributeStatementType);
  if (soap_out_ns8__AttributeStatementType(soap, tag?tag:"ns8:AttributeStatementType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AttributeStatementType * SOAP_FMAC4 soap_get_ns8__AttributeStatementType(struct soap *soap, struct ns8__AttributeStatementType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__AttributeStatementType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__AuthzDecisionStatementType(struct soap *soap, struct ns8__AuthzDecisionStatementType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__sizeAction = 0;
  a->Action = NULL;
  a->Evidence = NULL;
  soap_default_string(soap, &a->Resource);
  soap_default_ns8__DecisionType(soap, &a->Decision);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__AuthzDecisionStatementType(struct soap *soap, const struct ns8__AuthzDecisionStatementType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->Action) {
    int i;
    for (i = 0; i < a->__sizeAction; i++) {
      soap_serialize_PointerTons8__ActionType(soap, a->Action + i);
    }
  }
  soap_serialize_PointerTons8__EvidenceType(soap, &a->Evidence);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__AuthzDecisionStatementType(struct soap *soap, const char *tag, int id, const struct ns8__AuthzDecisionStatementType *a, const char *type) {
  if (a->Resource)
    soap_set_attr(soap, "Resource", a->Resource, 1);
  soap_set_attr(soap, "Decision", soap_ns8__DecisionType2s(soap, a->Decision), 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__AuthzDecisionStatementType), type))
    return soap->error;
  if (a->Action) {
    int i;
    for (i = 0; i < a->__sizeAction; i++)
      if (soap_out_PointerTons8__ActionType(soap, "Action", -1, a->Action + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons8__EvidenceType(soap, "Evidence", -1, &a->Evidence, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__AuthzDecisionStatementType * SOAP_FMAC4 soap_in_ns8__AuthzDecisionStatementType(struct soap *soap, const char *tag, struct ns8__AuthzDecisionStatementType *a, const char *type) {
  struct soap_blist *soap_blist_Action = NULL;
  size_t soap_flag_Evidence = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__AuthzDecisionStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__AuthzDecisionStatementType, sizeof(struct ns8__AuthzDecisionStatementType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__AuthzDecisionStatementType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Resource", 1), &a->Resource, -1, -1))
    return NULL;
  if (soap_s2ns8__DecisionType(soap, soap_attr_value(soap, "Decision", 1), &a->Decision))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "Action", 1, NULL)) {
        if (a->Action == NULL) {
          if (soap_blist_Action == NULL)
            soap_blist_Action = soap_new_block(soap);
          a->Action = (struct ns8__ActionType **)soap_push_block(soap, soap_blist_Action, sizeof(struct ns8__ActionType *));
          if (a->Action == NULL)
            return NULL;
          *a->Action = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons8__ActionType(soap, "Action", a->Action, "ns8:ActionType")) {
          a->__sizeAction++;
          a->Action = NULL;
          continue;
        }
      }
      if (soap_flag_Evidence && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons8__EvidenceType(soap, "Evidence", &a->Evidence, "ns8:EvidenceType")) {
          soap_flag_Evidence--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->Action)
      soap_pop_block(soap, soap_blist_Action);
    if (a->__sizeAction)
      a->Action = (struct ns8__ActionType **)soap_save_block(soap, soap_blist_Action, NULL, 1);
    else {
      a->Action = NULL;
      if (soap_blist_Action)
        soap_end_block(soap, soap_blist_Action);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__AuthzDecisionStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__AuthzDecisionStatementType, 0, sizeof(struct ns8__AuthzDecisionStatementType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAction < 1)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__AuthzDecisionStatementType(struct soap *soap, const struct ns8__AuthzDecisionStatementType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__AuthzDecisionStatementType);
  if (soap_out_ns8__AuthzDecisionStatementType(soap, tag?tag:"ns8:AuthzDecisionStatementType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AuthzDecisionStatementType * SOAP_FMAC4 soap_get_ns8__AuthzDecisionStatementType(struct soap *soap, struct ns8__AuthzDecisionStatementType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__AuthzDecisionStatementType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__AuthnStatementType(struct soap *soap, struct ns8__AuthnStatementType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->SubjectLocality = NULL;
  a->AuthnContext = NULL;
  soap_default_time(soap, &a->AuthnInstant);
  soap_default_string(soap, &a->SessionIndex);
  a->SessionNotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__AuthnStatementType(struct soap *soap, const struct ns8__AuthnStatementType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons8__SubjectLocalityType(soap, &a->SubjectLocality);
  soap_serialize_PointerTons8__AuthnContextType(soap, &a->AuthnContext);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__AuthnStatementType(struct soap *soap, const char *tag, int id, const struct ns8__AuthnStatementType *a, const char *type) {
  soap_set_attr(soap, "AuthnInstant", soap_dateTime2s(soap, a->AuthnInstant), 1);
  if (a->SessionIndex)
    soap_set_attr(soap, "SessionIndex", a->SessionIndex, 1);
  if (a->SessionNotOnOrAfter)
    soap_set_attr(soap, "SessionNotOnOrAfter", soap_dateTime2s(soap, *a->SessionNotOnOrAfter), 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__AuthnStatementType), type))
    return soap->error;
  if (soap_out_PointerTons8__SubjectLocalityType(soap, "SubjectLocality", -1, &a->SubjectLocality, ""))
    return soap->error;
  if (a->AuthnContext) {
    if (soap_out_PointerTons8__AuthnContextType(soap, "AuthnContext", -1, &a->AuthnContext, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "AuthnContext"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__AuthnStatementType * SOAP_FMAC4 soap_in_ns8__AuthnStatementType(struct soap *soap, const char *tag, struct ns8__AuthnStatementType *a, const char *type) {
  size_t soap_flag_SubjectLocality = 1;
  size_t soap_flag_AuthnContext = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__AuthnStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__AuthnStatementType, sizeof(struct ns8__AuthnStatementType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__AuthnStatementType(soap, a);
  if (soap_s2dateTime(soap, soap_attr_value(soap, "AuthnInstant", 1), &a->AuthnInstant))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "SessionIndex", 0), &a->SessionIndex, -1, -1))
    return NULL;
  {
    const char *t = soap_attr_value(soap, "SessionNotOnOrAfter", 0);
    if (t) {
      if (!(a->SessionNotOnOrAfter = (time_t *)soap_malloc(soap, sizeof(time_t)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2dateTime(soap, t, a->SessionNotOnOrAfter))
        return NULL;
    }
    else if (soap->error)
      return NULL;
  }
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SubjectLocality && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons8__SubjectLocalityType(soap, "SubjectLocality", &a->SubjectLocality, "ns8:SubjectLocalityType")) {
          soap_flag_SubjectLocality--;
          continue;
        }
      if (soap_flag_AuthnContext && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons8__AuthnContextType(soap, "AuthnContext", &a->AuthnContext, "ns8:AuthnContextType")) {
          soap_flag_AuthnContext--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__AuthnStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__AuthnStatementType, 0, sizeof(struct ns8__AuthnStatementType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AuthnContext > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__AuthnStatementType(struct soap *soap, const struct ns8__AuthnStatementType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__AuthnStatementType);
  if (soap_out_ns8__AuthnStatementType(soap, tag?tag:"ns8:AuthnStatementType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AuthnStatementType * SOAP_FMAC4 soap_get_ns8__AuthnStatementType(struct soap *soap, struct ns8__AuthnStatementType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__AuthnStatementType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__StatementAbstractType(struct soap *soap, struct ns8__StatementAbstractType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__StatementAbstractType(struct soap *soap, const struct ns8__StatementAbstractType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__StatementAbstractType(struct soap *soap, const char *tag, int id, const struct ns8__StatementAbstractType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__StatementAbstractType), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__StatementAbstractType * SOAP_FMAC4 soap_in_ns8__StatementAbstractType(struct soap *soap, const char *tag, struct ns8__StatementAbstractType *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__StatementAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__StatementAbstractType, sizeof(struct ns8__StatementAbstractType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__StatementAbstractType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__StatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__StatementAbstractType, 0, sizeof(struct ns8__StatementAbstractType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__StatementAbstractType(struct soap *soap, const struct ns8__StatementAbstractType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__StatementAbstractType);
  if (soap_out_ns8__StatementAbstractType(soap, tag?tag:"ns8:StatementAbstractType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__StatementAbstractType * SOAP_FMAC4 soap_get_ns8__StatementAbstractType(struct soap *soap, struct ns8__StatementAbstractType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__StatementAbstractType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__union_AssertionType(struct soap *soap, struct __ns8__union_AssertionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__union_AssertionType = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__union_AssertionType(struct soap *soap, const struct __ns8__union_AssertionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__ns8__union_AssertionType(soap, a->__union_AssertionType, &a->union_AssertionType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__union_AssertionType(struct soap *soap, const char *tag, int id, const struct __ns8__union_AssertionType *a, const char *type) {
  if (soap_out__ns8__union_AssertionType(soap, a->__union_AssertionType, &a->union_AssertionType))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__union_AssertionType * SOAP_FMAC4 soap_in___ns8__union_AssertionType(struct soap *soap, const char *tag, struct __ns8__union_AssertionType *a, const char *type) {
  a = (struct __ns8__union_AssertionType *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__union_AssertionType, sizeof(struct __ns8__union_AssertionType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns8__union_AssertionType(soap, a);
  if (!soap_in__ns8__union_AssertionType(soap, &a->__union_AssertionType, &a->union_AssertionType))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__union_AssertionType(struct soap *soap, const struct __ns8__union_AssertionType *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns8__union_AssertionType(soap, tag?tag:"-ns8:union-AssertionType", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__union_AssertionType * SOAP_FMAC4 soap_get___ns8__union_AssertionType(struct soap *soap, struct __ns8__union_AssertionType *p, const char *tag, const char *type) {
  if ((p = soap_in___ns8__union_AssertionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__AdviceType(struct soap *soap, struct ns8__AdviceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size_AdviceType = 0;
  a->__union_AdviceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__AdviceType(struct soap *soap, const struct ns8__AdviceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->__union_AdviceType) {
    int i;
    for (i = 0; i < a->__size_AdviceType; i++) {
      soap_serialize___ns8__union_AdviceType(soap, a->__union_AdviceType + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__AdviceType(struct soap *soap, const char *tag, int id, const struct ns8__AdviceType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__AdviceType), type))
    return soap->error;
  if (a->__union_AdviceType) {
    int i;
    for (i = 0; i < a->__size_AdviceType; i++)
      if (soap_out___ns8__union_AdviceType(soap, "-union-AdviceType", -1, a->__union_AdviceType + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__AdviceType * SOAP_FMAC4 soap_in_ns8__AdviceType(struct soap *soap, const char *tag, struct ns8__AdviceType *a, const char *type) {
  struct soap_blist *soap_blist___union_AdviceType = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__AdviceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__AdviceType, sizeof(struct ns8__AdviceType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__AdviceType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__union_AdviceType == NULL) {
          if (soap_blist___union_AdviceType == NULL)
            soap_blist___union_AdviceType = soap_new_block(soap);
          a->__union_AdviceType = (struct __ns8__union_AdviceType *)soap_push_block(soap, soap_blist___union_AdviceType, sizeof(struct __ns8__union_AdviceType));
          if (a->__union_AdviceType == NULL)
            return NULL;
          soap_default___ns8__union_AdviceType(soap, a->__union_AdviceType);
        }
        if (soap_in___ns8__union_AdviceType(soap, "-union-AdviceType", a->__union_AdviceType, "-ns8:union-AdviceType")) {
          a->__size_AdviceType++;
          a->__union_AdviceType = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__union_AdviceType)
      soap_pop_block(soap, soap_blist___union_AdviceType);
    if (a->__size_AdviceType)
      a->__union_AdviceType = (struct __ns8__union_AdviceType *)soap_save_block(soap, soap_blist___union_AdviceType, NULL, 1);
    else {
      a->__union_AdviceType = NULL;
      if (soap_blist___union_AdviceType)
        soap_end_block(soap, soap_blist___union_AdviceType);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__AdviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__AdviceType, 0, sizeof(struct ns8__AdviceType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__AdviceType(struct soap *soap, const struct ns8__AdviceType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__AdviceType);
  if (soap_out_ns8__AdviceType(soap, tag?tag:"ns8:AdviceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AdviceType * SOAP_FMAC4 soap_get_ns8__AdviceType(struct soap *soap, struct ns8__AdviceType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__AdviceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__ConditionsType(struct soap *soap, struct ns8__ConditionsType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size_ConditionsType = 0;
  a->__union_ConditionsType = NULL;
  a->NotBefore = NULL;
  a->NotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__ConditionsType(struct soap *soap, const struct ns8__ConditionsType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->__union_ConditionsType) {
    int i;
    for (i = 0; i < a->__size_ConditionsType; i++) {
      soap_serialize___ns8__union_ConditionsType(soap, a->__union_ConditionsType + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__ConditionsType(struct soap *soap, const char *tag, int id, const struct ns8__ConditionsType *a, const char *type) {
  if (a->NotBefore)
    soap_set_attr(soap, "NotBefore", soap_dateTime2s(soap, *a->NotBefore), 1);
  if (a->NotOnOrAfter)
    soap_set_attr(soap, "NotOnOrAfter", soap_dateTime2s(soap, *a->NotOnOrAfter), 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__ConditionsType), type))
    return soap->error;
  if (a->__union_ConditionsType) {
    int i;
    for (i = 0; i < a->__size_ConditionsType; i++)
      if (soap_out___ns8__union_ConditionsType(soap, "-union-ConditionsType", -1, a->__union_ConditionsType + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__ConditionsType * SOAP_FMAC4 soap_in_ns8__ConditionsType(struct soap *soap, const char *tag, struct ns8__ConditionsType *a, const char *type) {
  struct soap_blist *soap_blist___union_ConditionsType = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__ConditionsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__ConditionsType, sizeof(struct ns8__ConditionsType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__ConditionsType(soap, a);
  {
    const char *t = soap_attr_value(soap, "NotBefore", 0);
    if (t) {
      if (!(a->NotBefore = (time_t *)soap_malloc(soap, sizeof(time_t)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2dateTime(soap, t, a->NotBefore))
        return NULL;
    }
    else if (soap->error)
      return NULL;
  }
  {
    const char *t = soap_attr_value(soap, "NotOnOrAfter", 0);
    if (t) {
      if (!(a->NotOnOrAfter = (time_t *)soap_malloc(soap, sizeof(time_t)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2dateTime(soap, t, a->NotOnOrAfter))
        return NULL;
    }
    else if (soap->error)
      return NULL;
  }
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__union_ConditionsType == NULL) {
          if (soap_blist___union_ConditionsType == NULL)
            soap_blist___union_ConditionsType = soap_new_block(soap);
          a->__union_ConditionsType = (struct __ns8__union_ConditionsType *)soap_push_block(soap, soap_blist___union_ConditionsType, sizeof(struct __ns8__union_ConditionsType));
          if (a->__union_ConditionsType == NULL)
            return NULL;
          soap_default___ns8__union_ConditionsType(soap, a->__union_ConditionsType);
        }
        if (soap_in___ns8__union_ConditionsType(soap, "-union-ConditionsType", a->__union_ConditionsType, "-ns8:union-ConditionsType")) {
          a->__size_ConditionsType++;
          a->__union_ConditionsType = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__union_ConditionsType)
      soap_pop_block(soap, soap_blist___union_ConditionsType);
    if (a->__size_ConditionsType)
      a->__union_ConditionsType = (struct __ns8__union_ConditionsType *)soap_save_block(soap, soap_blist___union_ConditionsType, NULL, 1);
    else {
      a->__union_ConditionsType = NULL;
      if (soap_blist___union_ConditionsType)
        soap_end_block(soap, soap_blist___union_ConditionsType);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__ConditionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__ConditionsType, 0, sizeof(struct ns8__ConditionsType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__ConditionsType(struct soap *soap, const struct ns8__ConditionsType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__ConditionsType);
  if (soap_out_ns8__ConditionsType(soap, tag?tag:"ns8:ConditionsType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ConditionsType * SOAP_FMAC4 soap_get_ns8__ConditionsType(struct soap *soap, struct ns8__ConditionsType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__ConditionsType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__SubjectType(struct soap *soap, struct ns8__SubjectType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__union_SubjectType_ = 0;
  a->__sizeSubjectConfirmation = 0;
  a->SubjectConfirmation = NULL;
  a->__sizeSubjectConfirmation_ = 0;
  a->SubjectConfirmation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__SubjectType(struct soap *soap, const struct ns8__SubjectType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__ns8__union_SubjectType_(soap, a->__union_SubjectType_, &a->union_SubjectType_);
  if (a->SubjectConfirmation) {
    int i;
    for (i = 0; i < a->__sizeSubjectConfirmation; i++) {
      soap_serialize_PointerTons8__SubjectConfirmationType(soap, a->SubjectConfirmation + i);
    }
  }
  if (a->SubjectConfirmation_) {
    int i;
    for (i = 0; i < a->__sizeSubjectConfirmation_; i++) {
      soap_serialize_PointerTons8__SubjectConfirmationType(soap, a->SubjectConfirmation_ + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__SubjectType(struct soap *soap, const char *tag, int id, const struct ns8__SubjectType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__SubjectType), type))
    return soap->error;
  if (soap_out__ns8__union_SubjectType_(soap, a->__union_SubjectType_, &a->union_SubjectType_))
    return soap->error;
  if (a->SubjectConfirmation) {
    int i;
    for (i = 0; i < a->__sizeSubjectConfirmation; i++)
      if (soap_out_PointerTons8__SubjectConfirmationType(soap, "SubjectConfirmation", -1, a->SubjectConfirmation + i, ""))
        return soap->error;
  }
  if (a->SubjectConfirmation_) {
    int i;
    for (i = 0; i < a->__sizeSubjectConfirmation_; i++)
      if (soap_out_PointerTons8__SubjectConfirmationType(soap, "SubjectConfirmation", -1, a->SubjectConfirmation_ + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__SubjectType * SOAP_FMAC4 soap_in_ns8__SubjectType(struct soap *soap, const char *tag, struct ns8__SubjectType *a, const char *type) {
  size_t soap_flag_union_SubjectType_ = 1;
  struct soap_blist *soap_blist_SubjectConfirmation = NULL;
  struct soap_blist *soap_blist_SubjectConfirmation_ = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__SubjectType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__SubjectType, sizeof(struct ns8__SubjectType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__SubjectType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_union_SubjectType_ && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in__ns8__union_SubjectType_(soap, &a->__union_SubjectType_, &a->union_SubjectType_)) {
          soap_flag_union_SubjectType_ = 0;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "SubjectConfirmation", 1, NULL)) {
        if (a->SubjectConfirmation == NULL) {
          if (soap_blist_SubjectConfirmation == NULL)
            soap_blist_SubjectConfirmation = soap_new_block(soap);
          a->SubjectConfirmation = (struct ns8__SubjectConfirmationType **)soap_push_block(soap, soap_blist_SubjectConfirmation, sizeof(struct ns8__SubjectConfirmationType *));
          if (a->SubjectConfirmation == NULL)
            return NULL;
          *a->SubjectConfirmation = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons8__SubjectConfirmationType(soap, "SubjectConfirmation", a->SubjectConfirmation, "ns8:SubjectConfirmationType")) {
          a->__sizeSubjectConfirmation++;
          a->SubjectConfirmation = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "SubjectConfirmation", 1, NULL)) {
        if (a->SubjectConfirmation_ == NULL) {
          if (soap_blist_SubjectConfirmation_ == NULL)
            soap_blist_SubjectConfirmation_ = soap_new_block(soap);
          a->SubjectConfirmation_ = (struct ns8__SubjectConfirmationType **)soap_push_block(soap, soap_blist_SubjectConfirmation_, sizeof(struct ns8__SubjectConfirmationType *));
          if (a->SubjectConfirmation_ == NULL)
            return NULL;
          *a->SubjectConfirmation_ = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons8__SubjectConfirmationType(soap, "SubjectConfirmation", a->SubjectConfirmation_, "ns8:SubjectConfirmationType")) {
          a->__sizeSubjectConfirmation_++;
          a->SubjectConfirmation_ = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->SubjectConfirmation)
      soap_pop_block(soap, soap_blist_SubjectConfirmation);
    if (a->__sizeSubjectConfirmation)
      a->SubjectConfirmation = (struct ns8__SubjectConfirmationType **)soap_save_block(soap, soap_blist_SubjectConfirmation, NULL, 1);
    else {
      a->SubjectConfirmation = NULL;
      if (soap_blist_SubjectConfirmation)
        soap_end_block(soap, soap_blist_SubjectConfirmation);
    }
    if (a->SubjectConfirmation_)
      soap_pop_block(soap, soap_blist_SubjectConfirmation_);
    if (a->__sizeSubjectConfirmation_)
      a->SubjectConfirmation_ = (struct ns8__SubjectConfirmationType **)soap_save_block(soap, soap_blist_SubjectConfirmation_, NULL, 1);
    else {
      a->SubjectConfirmation_ = NULL;
      if (soap_blist_SubjectConfirmation_)
        soap_end_block(soap, soap_blist_SubjectConfirmation_);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__SubjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__SubjectType, 0, sizeof(struct ns8__SubjectType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_SubjectType_)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__SubjectType(struct soap *soap, const struct ns8__SubjectType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__SubjectType);
  if (soap_out_ns8__SubjectType(soap, tag?tag:"ns8:SubjectType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__SubjectType * SOAP_FMAC4 soap_get_ns8__SubjectType(struct soap *soap, struct ns8__SubjectType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__SubjectType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__NameIDType(struct soap *soap, struct ns8__NameIDType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_string(soap, &a->Format);
  soap_default_string(soap, &a->SPProvidedID);
  soap_default_string(soap, &a->NameQualifier);
  soap_default_string(soap, &a->SPNameQualifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__NameIDType(struct soap *soap, const struct ns8__NameIDType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__NameIDType(struct soap *soap, const char *tag, int id, const struct ns8__NameIDType *a, const char *type) {
  if (a->Format)
    soap_set_attr(soap, "Format", a->Format, 1);
  if (a->SPProvidedID)
    soap_set_attr(soap, "SPProvidedID", a->SPProvidedID, 1);
  if (a->NameQualifier)
    soap_set_attr(soap, "NameQualifier", a->NameQualifier, 1);
  if (a->SPNameQualifier)
    soap_set_attr(soap, "SPNameQualifier", a->SPNameQualifier, 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns8__NameIDType * SOAP_FMAC4 soap_in_ns8__NameIDType(struct soap *soap, const char *tag, struct ns8__NameIDType *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct ns8__NameIDType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__NameIDType, sizeof(struct ns8__NameIDType), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default_ns8__NameIDType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Format", 0), &a->Format, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "SPProvidedID", 0), &a->SPProvidedID, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 0), &a->NameQualifier, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "SPNameQualifier", 0), &a->SPNameQualifier, -1, -1))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, "ns8:NameIDType"))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__NameIDType(struct soap *soap, const struct ns8__NameIDType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__NameIDType);
  if (soap_out_ns8__NameIDType(soap, tag?tag:"ns8:NameIDType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__NameIDType * SOAP_FMAC4 soap_get_ns8__NameIDType(struct soap *soap, struct ns8__NameIDType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__NameIDType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__AssertionType(struct soap *soap, struct ns8__AssertionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->Issuer = NULL;
  a->ds__Signature = NULL;
  a->Subject = NULL;
  a->Conditions = NULL;
  a->Advice = NULL;
  a->__size_AssertionType = 0;
  a->__union_AssertionType = NULL;
  soap_default_string(soap, &a->Version);
  soap_default_string(soap, &a->ID);
  soap_default_time(soap, &a->IssueInstant);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__AssertionType(struct soap *soap, const struct ns8__AssertionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons8__NameIDType(soap, &a->Issuer);
  soap_serialize_PointerTo_ds__Signature(soap, &a->ds__Signature);
  soap_serialize_PointerTons8__SubjectType(soap, &a->Subject);
  soap_serialize_PointerTons8__ConditionsType(soap, &a->Conditions);
  soap_serialize_PointerTons8__AdviceType(soap, &a->Advice);
  if (a->__union_AssertionType) {
    int i;
    for (i = 0; i < a->__size_AssertionType; i++) {
      soap_serialize___ns8__union_AssertionType(soap, a->__union_AssertionType + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__AssertionType(struct soap *soap, const char *tag, int id, const struct ns8__AssertionType *a, const char *type) {
  if (a->Version)
    soap_set_attr(soap, "Version", a->Version, 1);
  if (a->ID)
    soap_set_attr(soap, "ID", a->ID, 1);
  soap_set_attr(soap, "IssueInstant", soap_dateTime2s(soap, a->IssueInstant), 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__AssertionType), type))
    return soap->error;
  if (a->Issuer) {
    if (soap_out_PointerTons8__NameIDType(soap, "Issuer", -1, &a->Issuer, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "Issuer"))
    return soap->error;
  if (soap_out_PointerTo_ds__Signature(soap, "ds:Signature", -1, &a->ds__Signature, ""))
    return soap->error;
  if (soap_out_PointerTons8__SubjectType(soap, "Subject", -1, &a->Subject, ""))
    return soap->error;
  if (soap_out_PointerTons8__ConditionsType(soap, "Conditions", -1, &a->Conditions, ""))
    return soap->error;
  if (soap_out_PointerTons8__AdviceType(soap, "Advice", -1, &a->Advice, ""))
    return soap->error;
  if (a->__union_AssertionType) {
    int i;
    for (i = 0; i < a->__size_AssertionType; i++)
      if (soap_out___ns8__union_AssertionType(soap, "-union-AssertionType", -1, a->__union_AssertionType + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__AssertionType * SOAP_FMAC4 soap_in_ns8__AssertionType(struct soap *soap, const char *tag, struct ns8__AssertionType *a, const char *type) {
  size_t soap_flag_Issuer = 1;
  size_t soap_flag_ds__Signature = 1;
  size_t soap_flag_Subject = 1;
  size_t soap_flag_Conditions = 1;
  size_t soap_flag_Advice = 1;
  struct soap_blist *soap_blist___union_AssertionType = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__AssertionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__AssertionType, sizeof(struct ns8__AssertionType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__AssertionType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Version", 1), &a->Version, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "ID", 1), &a->ID, -1, -1))
    return NULL;
  if (soap_s2dateTime(soap, soap_attr_value(soap, "IssueInstant", 1), &a->IssueInstant))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Issuer && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons8__NameIDType(soap, "Issuer", &a->Issuer, "ns8:NameIDType")) {
          soap_flag_Issuer--;
          continue;
        }
      if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_ds__Signature(soap, "ds:Signature", &a->ds__Signature, "")) {
          soap_flag_ds__Signature--;
          continue;
        }
      if (soap_flag_Subject && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons8__SubjectType(soap, "Subject", &a->Subject, "ns8:SubjectType")) {
          soap_flag_Subject--;
          continue;
        }
      if (soap_flag_Conditions && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons8__ConditionsType(soap, "Conditions", &a->Conditions, "ns8:ConditionsType")) {
          soap_flag_Conditions--;
          continue;
        }
      if (soap_flag_Advice && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons8__AdviceType(soap, "Advice", &a->Advice, "ns8:AdviceType")) {
          soap_flag_Advice--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__union_AssertionType == NULL) {
          if (soap_blist___union_AssertionType == NULL)
            soap_blist___union_AssertionType = soap_new_block(soap);
          a->__union_AssertionType = (struct __ns8__union_AssertionType *)soap_push_block(soap, soap_blist___union_AssertionType, sizeof(struct __ns8__union_AssertionType));
          if (a->__union_AssertionType == NULL)
            return NULL;
          soap_default___ns8__union_AssertionType(soap, a->__union_AssertionType);
        }
        if (soap_in___ns8__union_AssertionType(soap, "-union-AssertionType", a->__union_AssertionType, "-ns8:union-AssertionType")) {
          a->__size_AssertionType++;
          a->__union_AssertionType = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__union_AssertionType)
      soap_pop_block(soap, soap_blist___union_AssertionType);
    if (a->__size_AssertionType)
      a->__union_AssertionType = (struct __ns8__union_AssertionType *)soap_save_block(soap, soap_blist___union_AssertionType, NULL, 1);
    else {
      a->__union_AssertionType = NULL;
      if (soap_blist___union_AssertionType)
        soap_end_block(soap, soap_blist___union_AssertionType);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__AssertionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__AssertionType, 0, sizeof(struct ns8__AssertionType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Issuer > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__AssertionType(struct soap *soap, const struct ns8__AssertionType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__AssertionType);
  if (soap_out_ns8__AssertionType(soap, tag?tag:"ns8:AssertionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AssertionType * SOAP_FMAC4 soap_get_ns8__AssertionType(struct soap *soap, struct ns8__AssertionType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__AssertionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__EncryptedElementType(struct soap *soap, struct ns8__EncryptedElementType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default__xenc__EncryptedData(soap, &a->xenc__EncryptedData);
  a->xenc__EncryptedKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__EncryptedElementType(struct soap *soap, const struct ns8__EncryptedElementType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__xenc__EncryptedData(soap, &a->xenc__EncryptedData);
  soap_serialize_PointerTo_xenc__EncryptedKey(soap, &a->xenc__EncryptedKey);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__EncryptedElementType(struct soap *soap, const char *tag, int id, const struct ns8__EncryptedElementType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__EncryptedElementType), type))
    return soap->error;
  if (soap_out__xenc__EncryptedData(soap, "xenc:EncryptedData", -1, &a->xenc__EncryptedData, ""))
    return soap->error;
  if (soap_out_PointerTo_xenc__EncryptedKey(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__EncryptedElementType * SOAP_FMAC4 soap_in_ns8__EncryptedElementType(struct soap *soap, const char *tag, struct ns8__EncryptedElementType *a, const char *type) {
  size_t soap_flag_xenc__EncryptedData = 1;
  size_t soap_flag_xenc__EncryptedKey = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__EncryptedElementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__EncryptedElementType, sizeof(struct ns8__EncryptedElementType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__EncryptedElementType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_xenc__EncryptedData && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in__xenc__EncryptedData(soap, "xenc:EncryptedData", &a->xenc__EncryptedData, "")) {
          soap_flag_xenc__EncryptedData--;
          continue;
        }
      if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_xenc__EncryptedKey(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "")) {
          soap_flag_xenc__EncryptedKey--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__EncryptedElementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__EncryptedElementType, 0, sizeof(struct ns8__EncryptedElementType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xenc__EncryptedData > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__EncryptedElementType(struct soap *soap, const struct ns8__EncryptedElementType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__EncryptedElementType);
  if (soap_out_ns8__EncryptedElementType(soap, tag?tag:"ns8:EncryptedElementType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__EncryptedElementType * SOAP_FMAC4 soap_get_ns8__EncryptedElementType(struct soap *soap, struct ns8__EncryptedElementType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__EncryptedElementType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__BaseIDAbstractType(struct soap *soap, struct ns8__BaseIDAbstractType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->NameQualifier);
  soap_default_string(soap, &a->SPNameQualifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__BaseIDAbstractType(struct soap *soap, const struct ns8__BaseIDAbstractType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__BaseIDAbstractType(struct soap *soap, const char *tag, int id, const struct ns8__BaseIDAbstractType *a, const char *type) {
  if (a->NameQualifier)
    soap_set_attr(soap, "NameQualifier", a->NameQualifier, 1);
  if (a->SPNameQualifier)
    soap_set_attr(soap, "SPNameQualifier", a->SPNameQualifier, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__BaseIDAbstractType), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__BaseIDAbstractType * SOAP_FMAC4 soap_in_ns8__BaseIDAbstractType(struct soap *soap, const char *tag, struct ns8__BaseIDAbstractType *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__BaseIDAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__BaseIDAbstractType, sizeof(struct ns8__BaseIDAbstractType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__BaseIDAbstractType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 0), &a->NameQualifier, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "SPNameQualifier", 0), &a->SPNameQualifier, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__BaseIDAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__BaseIDAbstractType, 0, sizeof(struct ns8__BaseIDAbstractType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__BaseIDAbstractType(struct soap *soap, const struct ns8__BaseIDAbstractType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__BaseIDAbstractType);
  if (soap_out_ns8__BaseIDAbstractType(soap, tag?tag:"ns8:BaseIDAbstractType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__BaseIDAbstractType * SOAP_FMAC4 soap_get_ns8__BaseIDAbstractType(struct soap *soap, struct ns8__BaseIDAbstractType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__BaseIDAbstractType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__FaultCauseType(struct soap *soap, struct ns7__FaultCauseType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_string(soap, &a->dialect);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__FaultCauseType(struct soap *soap, const struct ns7__FaultCauseType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__FaultCauseType(struct soap *soap, const char *tag, int id, const struct ns7__FaultCauseType *a, const char *type) {
  if (a->dialect)
    soap_set_attr(soap, "dialect", a->dialect, 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns7__FaultCauseType * SOAP_FMAC4 soap_in_ns7__FaultCauseType(struct soap *soap, const char *tag, struct ns7__FaultCauseType *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct ns7__FaultCauseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__FaultCauseType, sizeof(struct ns7__FaultCauseType), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default_ns7__FaultCauseType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "dialect", 0), &a->dialect, -1, -1))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, "ns7:FaultCauseType"))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__FaultCauseType(struct soap *soap, const struct ns7__FaultCauseType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__FaultCauseType);
  if (soap_out_ns7__FaultCauseType(soap, tag?tag:"ns7:FaultCauseType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__FaultCauseType * SOAP_FMAC4 soap_get_ns7__FaultCauseType(struct soap *soap, struct ns7__FaultCauseType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns7__FaultCauseType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__ErrorCodeType(struct soap *soap, struct ns7__ErrorCodeType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_string(soap, &a->dialect);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__ErrorCodeType(struct soap *soap, const struct ns7__ErrorCodeType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ErrorCodeType(struct soap *soap, const char *tag, int id, const struct ns7__ErrorCodeType *a, const char *type) {
  if (a->dialect)
    soap_set_attr(soap, "dialect", a->dialect, 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns7__ErrorCodeType * SOAP_FMAC4 soap_in_ns7__ErrorCodeType(struct soap *soap, const char *tag, struct ns7__ErrorCodeType *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct ns7__ErrorCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ErrorCodeType, sizeof(struct ns7__ErrorCodeType), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default_ns7__ErrorCodeType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "dialect", 1), &a->dialect, -1, -1))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, "ns7:ErrorCodeType"))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__ErrorCodeType(struct soap *soap, const struct ns7__ErrorCodeType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__ErrorCodeType);
  if (soap_out_ns7__ErrorCodeType(soap, tag?tag:"ns7:ErrorCodeType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__ErrorCodeType * SOAP_FMAC4 soap_get_ns7__ErrorCodeType(struct soap *soap, struct ns7__ErrorCodeType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns7__ErrorCodeType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__BaseFaultType(struct soap *soap, struct ns7__BaseFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->Timestamp);
  a->Originator = NULL;
  a->ErrorCode = NULL;
  a->__sizeDescription = 0;
  a->Description = NULL;
  a->FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__BaseFaultType(struct soap *soap, const struct ns7__BaseFaultType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->Timestamp, SOAP_TYPE_time);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->Originator);
  soap_serialize_PointerTons7__ErrorCodeType(soap, &a->ErrorCode);
  if (a->Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++) {
      soap_serialize_string(soap, a->Description + i);
    }
  }
  soap_serialize_PointerTons7__FaultCauseType(soap, &a->FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__BaseFaultType(struct soap *soap, const char *tag, int id, const struct ns7__BaseFaultType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__BaseFaultType), type))
    return soap->error;
  if (soap_out_time(soap, "ns7:Timestamp", -1, &a->Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", -1, &a->Originator, ""))
    return soap->error;
  if (soap_out_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", -1, &a->ErrorCode, ""))
    return soap->error;
  if (a->Description) {
    int i;
    for (i = 0; i < a->__sizeDescription; i++)
      if (soap_out_string(soap, "ns7:Description", -1, a->Description + i, ""))
        return soap->error;
  }
  if (soap_out_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", -1, &a->FaultCause, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__BaseFaultType * SOAP_FMAC4 soap_in_ns7__BaseFaultType(struct soap *soap, const char *tag, struct ns7__BaseFaultType *a, const char *type) {
  size_t soap_flag_Timestamp = 1;
  size_t soap_flag_Originator = 1;
  size_t soap_flag_ErrorCode = 1;
  struct soap_blist *soap_blist_Description = NULL;
  size_t soap_flag_FaultCause = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns7__BaseFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__BaseFaultType, sizeof(struct ns7__BaseFaultType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns7__BaseFaultType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns7:Timestamp", &a->Timestamp, "xsd:dateTime")) {
          soap_flag_Timestamp--;
          continue;
        }
      if (soap_flag_Originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns7:Originator", &a->Originator, "wsa5:EndpointReferenceType")) {
          soap_flag_Originator--;
          continue;
        }
      if (soap_flag_ErrorCode && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__ErrorCodeType(soap, "ns7:ErrorCode", &a->ErrorCode, "ns7:ErrorCodeType")) {
          soap_flag_ErrorCode--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Description", 1, NULL)) {
        if (a->Description == NULL) {
          if (soap_blist_Description == NULL)
            soap_blist_Description = soap_new_block(soap);
          a->Description = (char **)soap_push_block(soap, soap_blist_Description, sizeof(char *));
          if (a->Description == NULL)
            return NULL;
          *a->Description = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns7:Description", a->Description, "xsd:string")) {
          a->__sizeDescription++;
          a->Description = NULL;
          continue;
        }
      }
      if (soap_flag_FaultCause && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons7__FaultCauseType(soap, "ns7:FaultCause", &a->FaultCause, "ns7:FaultCauseType")) {
          soap_flag_FaultCause--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->Description)
      soap_pop_block(soap, soap_blist_Description);
    if (a->__sizeDescription)
      a->Description = (char **)soap_save_block(soap, soap_blist_Description, NULL, 1);
    else {
      a->Description = NULL;
      if (soap_blist_Description)
        soap_end_block(soap, soap_blist_Description);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns7__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__BaseFaultType, 0, sizeof(struct ns7__BaseFaultType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__BaseFaultType(struct soap *soap, const struct ns7__BaseFaultType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__BaseFaultType);
  if (soap_out_ns7__BaseFaultType(soap, tag?tag:"ns7:BaseFaultType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__BaseFaultType * SOAP_FMAC4 soap_get_ns7__BaseFaultType(struct soap *soap, struct ns7__BaseFaultType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns7__BaseFaultType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__authConditionType(struct soap *soap, struct ns6__authConditionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__sizeconditionValue = 0;
  a->conditionValue = NULL;
  soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__authConditionType(struct soap *soap, const struct ns6__authConditionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->conditionValue) {
    int i;
    for (i = 0; i < a->__sizeconditionValue; i++) {
      soap_serialize_string(soap, a->conditionValue + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__authConditionType(struct soap *soap, const char *tag, int id, const struct ns6__authConditionType *a, const char *type) {
  if (a->name)
    soap_set_attr(soap, "name", a->name, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__authConditionType), type))
    return soap->error;
  if (a->conditionValue) {
    int i;
    for (i = 0; i < a->__sizeconditionValue; i++)
      if (soap_out_string(soap, "ns6:conditionValue", -1, a->conditionValue + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__authConditionType * SOAP_FMAC4 soap_in_ns6__authConditionType(struct soap *soap, const char *tag, struct ns6__authConditionType *a, const char *type) {
  struct soap_blist *soap_blist_conditionValue = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns6__authConditionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__authConditionType, sizeof(struct ns6__authConditionType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns6__authConditionType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:conditionValue", 1, NULL)) {
        if (a->conditionValue == NULL) {
          if (soap_blist_conditionValue == NULL)
            soap_blist_conditionValue = soap_new_block(soap);
          a->conditionValue = (char **)soap_push_block(soap, soap_blist_conditionValue, sizeof(char *));
          if (a->conditionValue == NULL)
            return NULL;
          *a->conditionValue = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns6:conditionValue", a->conditionValue, "xsd:string")) {
          a->__sizeconditionValue++;
          a->conditionValue = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->conditionValue)
      soap_pop_block(soap, soap_blist_conditionValue);
    if (a->__sizeconditionValue)
      a->conditionValue = (char **)soap_save_block(soap, soap_blist_conditionValue, NULL, 1);
    else {
      a->conditionValue = NULL;
      if (soap_blist_conditionValue)
        soap_end_block(soap, soap_blist_conditionValue);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns6__authConditionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__authConditionType, 0, sizeof(struct ns6__authConditionType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeconditionValue < 1)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__authConditionType(struct soap *soap, const struct ns6__authConditionType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__authConditionType);
  if (soap_out_ns6__authConditionType(soap, tag?tag:"ns6:authConditionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__authConditionType * SOAP_FMAC4 soap_get_ns6__authConditionType(struct soap *soap, struct ns6__authConditionType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns6__authConditionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__authConditions(struct soap *soap, struct ns6__authConditions *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__sizeauthCondition = 0;
  a->authCondition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__authConditions(struct soap *soap, const struct ns6__authConditions *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->authCondition) {
    int i;
    for (i = 0; i < a->__sizeauthCondition; i++) {
      soap_serialize_PointerTons6__authConditionType(soap, a->authCondition + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__authConditions(struct soap *soap, const char *tag, int id, const struct ns6__authConditions *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__authConditions), type))
    return soap->error;
  if (a->authCondition) {
    int i;
    for (i = 0; i < a->__sizeauthCondition; i++)
      if (soap_out_PointerTons6__authConditionType(soap, "ns6:authCondition", -1, a->authCondition + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__authConditions * SOAP_FMAC4 soap_in_ns6__authConditions(struct soap *soap, const char *tag, struct ns6__authConditions *a, const char *type) {
  struct soap_blist *soap_blist_authCondition = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns6__authConditions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__authConditions, sizeof(struct ns6__authConditions), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns6__authConditions(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:authCondition", 1, NULL)) {
        if (a->authCondition == NULL) {
          if (soap_blist_authCondition == NULL)
            soap_blist_authCondition = soap_new_block(soap);
          a->authCondition = (struct ns6__authConditionType **)soap_push_block(soap, soap_blist_authCondition, sizeof(struct ns6__authConditionType *));
          if (a->authCondition == NULL)
            return NULL;
          *a->authCondition = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons6__authConditionType(soap, "ns6:authCondition", a->authCondition, "ns6:authConditionType")) {
          a->__sizeauthCondition++;
          a->authCondition = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->authCondition)
      soap_pop_block(soap, soap_blist_authCondition);
    if (a->__sizeauthCondition)
      a->authCondition = (struct ns6__authConditionType **)soap_save_block(soap, soap_blist_authCondition, NULL, 1);
    else {
      a->authCondition = NULL;
      if (soap_blist_authCondition)
        soap_end_block(soap, soap_blist_authCondition);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns6__authConditions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__authConditions, 0, sizeof(struct ns6__authConditions), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__authConditions(struct soap *soap, const struct ns6__authConditions *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__authConditions);
  if (soap_out_ns6__authConditions(soap, tag?tag:"ns6:authConditions", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__authConditions * SOAP_FMAC4 soap_get_ns6__authConditions(struct soap *soap, struct ns6__authConditions *p, const char *tag, const char *type) {
  if ((p = soap_in_ns6__authConditions(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__AttributeType(struct soap *soap, struct ns8__AttributeType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__sizeAttributeValue = 0;
  a->AttributeValue = NULL;
  soap_default_string(soap, &a->Name);
  soap_default_string(soap, &a->NameFormat);
  soap_default_string(soap, &a->FriendlyName);
  a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__AttributeType(struct soap *soap, const struct ns8__AttributeType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__AttributeType(struct soap *soap, const char *tag, int id, const struct ns8__AttributeType *a, const char *type) {
  if (a->Name)
    soap_set_attr(soap, "Name", a->Name, 1);
  if (a->NameFormat)
    soap_set_attr(soap, "NameFormat", a->NameFormat, 1);
  if (a->FriendlyName)
    soap_set_attr(soap, "FriendlyName", a->FriendlyName, 1);
  if (a->__anyAttribute)
    soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__AttributeType), type))
    return soap->error;
  if (a->AttributeValue) {
    int i;
    for (i = 0; i < a->__sizeAttributeValue; i++)
      soap_outliteral(soap, "AttributeValue", a->AttributeValue + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__AttributeType * SOAP_FMAC4 soap_in_ns8__AttributeType(struct soap *soap, const char *tag, struct ns8__AttributeType *a, const char *type) {
  struct soap_blist *soap_blist_AttributeValue = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns8__AttributeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__AttributeType, sizeof(struct ns8__AttributeType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns8__AttributeType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "NameFormat", 0), &a->NameFormat, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "FriendlyName", 0), &a->FriendlyName, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "AttributeValue", 1, NULL)) {
        if (a->AttributeValue == NULL) {
          if (soap_blist_AttributeValue == NULL)
            soap_blist_AttributeValue = soap_new_block(soap);
          a->AttributeValue = (char **)soap_push_block(soap, soap_blist_AttributeValue, sizeof(char *));
          if (a->AttributeValue == NULL)
            return NULL;
          *a->AttributeValue = NULL;
        }
        soap_revert(soap);
        if (soap_inliteral(soap, "AttributeValue", a->AttributeValue)) {
          a->__sizeAttributeValue++;
          a->AttributeValue = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->AttributeValue)
      soap_pop_block(soap, soap_blist_AttributeValue);
    if (a->__sizeAttributeValue)
      a->AttributeValue = (char **)soap_save_block(soap, soap_blist_AttributeValue, NULL, 1);
    else {
      a->AttributeValue = NULL;
      if (soap_blist_AttributeValue)
        soap_end_block(soap, soap_blist_AttributeValue);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns8__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__AttributeType, 0, sizeof(struct ns8__AttributeType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__AttributeType(struct soap *soap, const struct ns8__AttributeType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns8__AttributeType);
  if (soap_out_ns8__AttributeType(soap, tag?tag:"ns8:AttributeType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AttributeType * SOAP_FMAC4 soap_get_ns8__AttributeType(struct soap *soap, struct ns8__AttributeType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns8__AttributeType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__subjectAttributes(struct soap *soap, struct ns6__subjectAttributes *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__sizesubjectAttribute = 0;
  a->subjectAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__subjectAttributes(struct soap *soap, const struct ns6__subjectAttributes *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->subjectAttribute) {
    int i;
    for (i = 0; i < a->__sizesubjectAttribute; i++) {
      soap_serialize_PointerTons8__AttributeType(soap, a->subjectAttribute + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__subjectAttributes(struct soap *soap, const char *tag, int id, const struct ns6__subjectAttributes *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__subjectAttributes), type))
    return soap->error;
  if (a->subjectAttribute) {
    int i;
    for (i = 0; i < a->__sizesubjectAttribute; i++)
      if (soap_out_PointerTons8__AttributeType(soap, "ns6:subjectAttribute", -1, a->subjectAttribute + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__subjectAttributes * SOAP_FMAC4 soap_in_ns6__subjectAttributes(struct soap *soap, const char *tag, struct ns6__subjectAttributes *a, const char *type) {
  struct soap_blist *soap_blist_subjectAttribute = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns6__subjectAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__subjectAttributes, sizeof(struct ns6__subjectAttributes), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns6__subjectAttributes(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:subjectAttribute", 1, NULL)) {
        if (a->subjectAttribute == NULL) {
          if (soap_blist_subjectAttribute == NULL)
            soap_blist_subjectAttribute = soap_new_block(soap);
          a->subjectAttribute = (struct ns8__AttributeType **)soap_push_block(soap, soap_blist_subjectAttribute, sizeof(struct ns8__AttributeType *));
          if (a->subjectAttribute == NULL)
            return NULL;
          *a->subjectAttribute = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons8__AttributeType(soap, "ns6:subjectAttribute", a->subjectAttribute, "ns8:AttributeType")) {
          a->__sizesubjectAttribute++;
          a->subjectAttribute = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->subjectAttribute)
      soap_pop_block(soap, soap_blist_subjectAttribute);
    if (a->__sizesubjectAttribute)
      a->subjectAttribute = (struct ns8__AttributeType **)soap_save_block(soap, soap_blist_subjectAttribute, NULL, 1);
    else {
      a->subjectAttribute = NULL;
      if (soap_blist_subjectAttribute)
        soap_end_block(soap, soap_blist_subjectAttribute);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns6__subjectAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__subjectAttributes, 0, sizeof(struct ns6__subjectAttributes), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (a->__sizesubjectAttribute < 1)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__subjectAttributes(struct soap *soap, const struct ns6__subjectAttributes *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__subjectAttributes);
  if (soap_out_ns6__subjectAttributes(soap, tag?tag:"ns6:subjectAttributes", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__subjectAttributes * SOAP_FMAC4 soap_get_ns6__subjectAttributes(struct soap *soap, struct ns6__subjectAttributes *p, const char *tag, const char *type) {
  if ((p = soap_in_ns6__subjectAttributes(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->capability);
  a->interfaceMTU = NULL;
  soap_default_string(soap, &a->vlanRangeAvailability);
  soap_default_string(soap, &a->suggestedVLANRange);
  a->vlanTranslation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, const struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->capability);
  soap_serialize_PointerToint(soap, &a->interfaceMTU);
  soap_serialize_string(soap, &a->vlanRangeAvailability);
  soap_serialize_string(soap, &a->suggestedVLANRange);
  soap_serialize_PointerToxsd__boolean_(soap, &a->vlanTranslation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo), type))
    return soap->error;
  if (soap_out_string(soap, "ns5:capability", -1, &a->capability, ""))
    return soap->error;
  if (soap_out_PointerToint(soap, "ns5:interfaceMTU", -1, &a->interfaceMTU, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:vlanRangeAvailability", -1, &a->vlanRangeAvailability, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:suggestedVLANRange", -1, &a->suggestedVLANRange, ""))
    return soap->error;
  if (soap_out_PointerToxsd__boolean_(soap, "ns5:vlanTranslation", -1, &a->vlanTranslation, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo * SOAP_FMAC4 soap_in_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, const char *tag, struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *a, const char *type) {
  size_t soap_flag_capability = 1;
  size_t soap_flag_interfaceMTU = 1;
  size_t soap_flag_vlanRangeAvailability = 1;
  size_t soap_flag_suggestedVLANRange = 1;
  size_t soap_flag_vlanTranslation = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo, sizeof(struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_capability && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:capability", &a->capability, "xsd:string")) {
          soap_flag_capability--;
          continue;
        }
      if (soap_flag_interfaceMTU && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToint(soap, "ns5:interfaceMTU", &a->interfaceMTU, "xsd:int")) {
          soap_flag_interfaceMTU--;
          continue;
        }
      if (soap_flag_vlanRangeAvailability && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:vlanRangeAvailability", &a->vlanRangeAvailability, "xsd:string")) {
          soap_flag_vlanRangeAvailability--;
          continue;
        }
      if (soap_flag_suggestedVLANRange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:suggestedVLANRange", &a->suggestedVLANRange, "xsd:string")) {
          soap_flag_suggestedVLANRange--;
          continue;
        }
      if (soap_flag_vlanTranslation && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxsd__boolean_(soap, "ns5:vlanTranslation", &a->vlanTranslation, "xsd:boolean")) {
          soap_flag_vlanTranslation--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo, 0, sizeof(struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, const struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo);
  if (soap_out_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag?tag:"ns5:CtrlPlaneSwitchingCapabilitySpecificInfo", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo * SOAP_FMAC4 soap_get_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__Duration(struct soap *soap, struct ns5__Duration *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_string(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__Duration(struct soap *soap, const struct ns5__Duration *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Duration(struct soap *soap, const char *tag, int id, const struct ns5__Duration *a, const char *type) {
  if (a->type)
    soap_set_attr(soap, "type", a->type, 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns5__Duration * SOAP_FMAC4 soap_in_ns5__Duration(struct soap *soap, const char *tag, struct ns5__Duration *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct ns5__Duration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Duration, sizeof(struct ns5__Duration), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default_ns5__Duration(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "type", 1), &a->type, -1, -1))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, "ns5:Duration"))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__Duration(struct soap *soap, const struct ns5__Duration *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__Duration);
  if (soap_out_ns5__Duration(soap, tag?tag:"ns5:Duration", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__Duration * SOAP_FMAC4 soap_get_ns5__Duration(struct soap *soap, struct ns5__Duration *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__Duration(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__TimeContent(struct soap *soap, struct ns5__TimeContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_string(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__TimeContent(struct soap *soap, const struct ns5__TimeContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TimeContent(struct soap *soap, const char *tag, int id, const struct ns5__TimeContent *a, const char *type) {
  if (a->type)
    soap_set_attr(soap, "type", a->type, 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns5__TimeContent * SOAP_FMAC4 soap_in_ns5__TimeContent(struct soap *soap, const char *tag, struct ns5__TimeContent *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct ns5__TimeContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__TimeContent, sizeof(struct ns5__TimeContent), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default_ns5__TimeContent(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "type", 1), &a->type, -1, -1))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, "ns5:TimeContent"))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__TimeContent(struct soap *soap, const struct ns5__TimeContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__TimeContent);
  if (soap_out_ns5__TimeContent(soap, tag?tag:"ns5:TimeContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__TimeContent * SOAP_FMAC4 soap_get_ns5__TimeContent(struct soap *soap, struct ns5__TimeContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__TimeContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlaneNextHopContent(struct soap *soap, struct ns5__CtrlPlaneNextHopContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  a->weight = NULL;
  a->optional = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlaneNextHopContent(struct soap *soap, const struct ns5__CtrlPlaneNextHopContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlaneNextHopContent(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlaneNextHopContent *a, const char *type) {
  if (a->weight)
    soap_set_attr(soap, "weight", soap_int2s(soap, *a->weight), 1);
  if (a->optional)
    soap_set_attr(soap, "optional", soap_xsd__boolean_2s(soap, *a->optional), 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns5__CtrlPlaneNextHopContent * SOAP_FMAC4 soap_in_ns5__CtrlPlaneNextHopContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneNextHopContent *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct ns5__CtrlPlaneNextHopContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlaneNextHopContent, sizeof(struct ns5__CtrlPlaneNextHopContent), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default_ns5__CtrlPlaneNextHopContent(soap, a);
  {
    const char *t = soap_attr_value(soap, "weight", 0);
    if (t) {
      if (!(a->weight = (int *)soap_malloc(soap, sizeof(int)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2int(soap, t, a->weight))
        return NULL;
    }
    else if (soap->error)
      return NULL;
  }
  {
    const char *t = soap_attr_value(soap, "optional", 0);
    if (t) {
      if (!(a->optional = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_)))) {
        soap->error = SOAP_EOM;
        return NULL;
      }
      if (soap_s2xsd__boolean_(soap, t, a->optional))
        return NULL;
    }
    else if (soap->error)
      return NULL;
  }
  if (!soap_in_string(soap, tag, &a->__item, "ns5:CtrlPlaneNextHopContent"))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlaneNextHopContent(struct soap *soap, const struct ns5__CtrlPlaneNextHopContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlaneNextHopContent);
  if (soap_out_ns5__CtrlPlaneNextHopContent(soap, tag?tag:"ns5:CtrlPlaneNextHopContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneNextHopContent * SOAP_FMAC4 soap_get_ns5__CtrlPlaneNextHopContent(struct soap *soap, struct ns5__CtrlPlaneNextHopContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlaneNextHopContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlaneHopContent(struct soap *soap, struct ns5__CtrlPlaneHopContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->domainIdRef);
  soap_default_string(soap, &a->nodeIdRef);
  soap_default_string(soap, &a->portIdRef);
  soap_default_string(soap, &a->linkIdRef);
  a->domain = NULL;
  a->node = NULL;
  a->port = NULL;
  a->link = NULL;
  a->__sizenextHop = 0;
  a->nextHop = NULL;
  soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlaneHopContent(struct soap *soap, const struct ns5__CtrlPlaneHopContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->domainIdRef);
  soap_serialize_string(soap, &a->nodeIdRef);
  soap_serialize_string(soap, &a->portIdRef);
  soap_serialize_string(soap, &a->linkIdRef);
  soap_serialize_PointerTons5__CtrlPlaneDomainContent(soap, &a->domain);
  soap_serialize_PointerTons5__CtrlPlaneNodeContent(soap, &a->node);
  soap_serialize_PointerTons5__CtrlPlanePortContent(soap, &a->port);
  soap_serialize_PointerTons5__CtrlPlaneLinkContent(soap, &a->link);
  if (a->nextHop) {
    int i;
    for (i = 0; i < a->__sizenextHop; i++) {
      soap_serialize_PointerTons5__CtrlPlaneNextHopContent(soap, a->nextHop + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlaneHopContent(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlaneHopContent *a, const char *type) {
  if (a->id)
    soap_set_attr(soap, "id", a->id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CtrlPlaneHopContent), type))
    return soap->error;
  if (soap_out_string(soap, "ns5:domainIdRef", -1, &a->domainIdRef, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:nodeIdRef", -1, &a->nodeIdRef, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:portIdRef", -1, &a->portIdRef, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:linkIdRef", -1, &a->linkIdRef, ""))
    return soap->error;
  if (soap_out_PointerTons5__CtrlPlaneDomainContent(soap, "ns5:domain", -1, &a->domain, ""))
    return soap->error;
  if (soap_out_PointerTons5__CtrlPlaneNodeContent(soap, "ns5:node", -1, &a->node, ""))
    return soap->error;
  if (soap_out_PointerTons5__CtrlPlanePortContent(soap, "ns5:port", -1, &a->port, ""))
    return soap->error;
  if (soap_out_PointerTons5__CtrlPlaneLinkContent(soap, "ns5:link", -1, &a->link, ""))
    return soap->error;
  if (a->nextHop) {
    int i;
    for (i = 0; i < a->__sizenextHop; i++)
      if (soap_out_PointerTons5__CtrlPlaneNextHopContent(soap, "ns5:nextHop", -1, a->nextHop + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__CtrlPlaneHopContent * SOAP_FMAC4 soap_in_ns5__CtrlPlaneHopContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneHopContent *a, const char *type) {
  size_t soap_flag_domainIdRef = 1;
  size_t soap_flag_nodeIdRef = 1;
  size_t soap_flag_portIdRef = 1;
  size_t soap_flag_linkIdRef = 1;
  size_t soap_flag_domain = 1;
  size_t soap_flag_node = 1;
  size_t soap_flag_port = 1;
  size_t soap_flag_link = 1;
  struct soap_blist *soap_blist_nextHop = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns5__CtrlPlaneHopContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlaneHopContent, sizeof(struct ns5__CtrlPlaneHopContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns5__CtrlPlaneHopContent(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_domainIdRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:domainIdRef", &a->domainIdRef, "xsd:string")) {
          soap_flag_domainIdRef--;
          continue;
        }
      if (soap_flag_nodeIdRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:nodeIdRef", &a->nodeIdRef, "xsd:string")) {
          soap_flag_nodeIdRef--;
          continue;
        }
      if (soap_flag_portIdRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:portIdRef", &a->portIdRef, "xsd:string")) {
          soap_flag_portIdRef--;
          continue;
        }
      if (soap_flag_linkIdRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:linkIdRef", &a->linkIdRef, "xsd:string")) {
          soap_flag_linkIdRef--;
          continue;
        }
      if (soap_flag_domain && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__CtrlPlaneDomainContent(soap, "ns5:domain", &a->domain, "ns5:CtrlPlaneDomainContent")) {
          soap_flag_domain--;
          continue;
        }
      if (soap_flag_node && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__CtrlPlaneNodeContent(soap, "ns5:node", &a->node, "ns5:CtrlPlaneNodeContent")) {
          soap_flag_node--;
          continue;
        }
      if (soap_flag_port && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__CtrlPlanePortContent(soap, "ns5:port", &a->port, "ns5:CtrlPlanePortContent")) {
          soap_flag_port--;
          continue;
        }
      if (soap_flag_link && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__CtrlPlaneLinkContent(soap, "ns5:link", &a->link, "ns5:CtrlPlaneLinkContent")) {
          soap_flag_link--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:nextHop", 1, NULL)) {
        if (a->nextHop == NULL) {
          if (soap_blist_nextHop == NULL)
            soap_blist_nextHop = soap_new_block(soap);
          a->nextHop = (struct ns5__CtrlPlaneNextHopContent **)soap_push_block(soap, soap_blist_nextHop, sizeof(struct ns5__CtrlPlaneNextHopContent *));
          if (a->nextHop == NULL)
            return NULL;
          *a->nextHop = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons5__CtrlPlaneNextHopContent(soap, "ns5:nextHop", a->nextHop, "ns5:CtrlPlaneNextHopContent")) {
          a->__sizenextHop++;
          a->nextHop = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->nextHop)
      soap_pop_block(soap, soap_blist_nextHop);
    if (a->__sizenextHop)
      a->nextHop = (struct ns5__CtrlPlaneNextHopContent **)soap_save_block(soap, soap_blist_nextHop, NULL, 1);
    else {
      a->nextHop = NULL;
      if (soap_blist_nextHop)
        soap_end_block(soap, soap_blist_nextHop);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneHopContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CtrlPlaneHopContent, 0, sizeof(struct ns5__CtrlPlaneHopContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlaneHopContent(struct soap *soap, const struct ns5__CtrlPlaneHopContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlaneHopContent);
  if (soap_out_ns5__CtrlPlaneHopContent(soap, tag?tag:"ns5:CtrlPlaneHopContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneHopContent * SOAP_FMAC4 soap_get_ns5__CtrlPlaneHopContent(struct soap *soap, struct ns5__CtrlPlaneHopContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlaneHopContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlaneSwcapContent(struct soap *soap, struct ns5__CtrlPlaneSwcapContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->switchingcapType);
  soap_default_string(soap, &a->encodingType);
  a->switchingCapabilitySpecificInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlaneSwcapContent(struct soap *soap, const struct ns5__CtrlPlaneSwcapContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->switchingcapType);
  soap_serialize_string(soap, &a->encodingType);
  soap_serialize_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, &a->switchingCapabilitySpecificInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlaneSwcapContent(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlaneSwcapContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CtrlPlaneSwcapContent), type))
    return soap->error;
  if (a->switchingcapType) {
    if (soap_out_string(soap, "ns5:switchingcapType", -1, &a->switchingcapType, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns5:switchingcapType"))
    return soap->error;
  if (a->encodingType) {
    if (soap_out_string(soap, "ns5:encodingType", -1, &a->encodingType, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns5:encodingType"))
    return soap->error;
  if (a->switchingCapabilitySpecificInfo) {
    if (soap_out_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, "ns5:switchingCapabilitySpecificInfo", -1, &a->switchingCapabilitySpecificInfo, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns5:switchingCapabilitySpecificInfo"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__CtrlPlaneSwcapContent * SOAP_FMAC4 soap_in_ns5__CtrlPlaneSwcapContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneSwcapContent *a, const char *type) {
  size_t soap_flag_switchingcapType = 1;
  size_t soap_flag_encodingType = 1;
  size_t soap_flag_switchingCapabilitySpecificInfo = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns5__CtrlPlaneSwcapContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlaneSwcapContent, sizeof(struct ns5__CtrlPlaneSwcapContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns5__CtrlPlaneSwcapContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_switchingcapType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:switchingcapType", &a->switchingcapType, "xsd:string")) {
          soap_flag_switchingcapType--;
          continue;
        }
      if (soap_flag_encodingType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:encodingType", &a->encodingType, "xsd:string")) {
          soap_flag_encodingType--;
          continue;
        }
      if (soap_flag_switchingCapabilitySpecificInfo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, "ns5:switchingCapabilitySpecificInfo", &a->switchingCapabilitySpecificInfo, "ns5:CtrlPlaneSwitchingCapabilitySpecificInfo")) {
          soap_flag_switchingCapabilitySpecificInfo--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneSwcapContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CtrlPlaneSwcapContent, 0, sizeof(struct ns5__CtrlPlaneSwcapContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_switchingcapType > 0 || soap_flag_encodingType > 0 || soap_flag_switchingCapabilitySpecificInfo > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlaneSwcapContent(struct soap *soap, const struct ns5__CtrlPlaneSwcapContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlaneSwcapContent);
  if (soap_out_ns5__CtrlPlaneSwcapContent(soap, tag?tag:"ns5:CtrlPlaneSwcapContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneSwcapContent * SOAP_FMAC4 soap_get_ns5__CtrlPlaneSwcapContent(struct soap *soap, struct ns5__CtrlPlaneSwcapContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlaneSwcapContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns5__CtrlPlaneAdministrativeGroup *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_int(soap, &a->group);
  soap_default_string(soap, &a->groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlaneAdministrativeGroup(struct soap *soap, const struct ns5__CtrlPlaneAdministrativeGroup *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->group, SOAP_TYPE_int);
  soap_serialize_string(soap, &a->groupID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlaneAdministrativeGroup(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlaneAdministrativeGroup *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CtrlPlaneAdministrativeGroup), type))
    return soap->error;
  if (soap_out_int(soap, "ns5:group", -1, &a->group, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:groupID", -1, &a->groupID, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__CtrlPlaneAdministrativeGroup * SOAP_FMAC4 soap_in_ns5__CtrlPlaneAdministrativeGroup(struct soap *soap, const char *tag, struct ns5__CtrlPlaneAdministrativeGroup *a, const char *type) {
  size_t soap_flag_group = 1;
  size_t soap_flag_groupID = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns5__CtrlPlaneAdministrativeGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlaneAdministrativeGroup, sizeof(struct ns5__CtrlPlaneAdministrativeGroup), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns5__CtrlPlaneAdministrativeGroup(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_group && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_int(soap, "ns5:group", &a->group, "xsd:int")) {
          soap_flag_group--;
          continue;
        }
      if (soap_flag_groupID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:groupID", &a->groupID, "xsd:string")) {
          soap_flag_groupID--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneAdministrativeGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CtrlPlaneAdministrativeGroup, 0, sizeof(struct ns5__CtrlPlaneAdministrativeGroup), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlaneAdministrativeGroup(struct soap *soap, const struct ns5__CtrlPlaneAdministrativeGroup *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlaneAdministrativeGroup);
  if (soap_out_ns5__CtrlPlaneAdministrativeGroup(soap, tag?tag:"ns5:CtrlPlaneAdministrativeGroup", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneAdministrativeGroup * SOAP_FMAC4 soap_get_ns5__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns5__CtrlPlaneAdministrativeGroup *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlaneAdministrativeGroup(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlaneAddressContent(struct soap *soap, struct ns5__CtrlPlaneAddressContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_string(soap, &a->value);
  soap_default_string(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlaneAddressContent(struct soap *soap, const struct ns5__CtrlPlaneAddressContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlaneAddressContent(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlaneAddressContent *a, const char *type) {
  if (a->value)
    soap_set_attr(soap, "value", a->value, 1);
  if (a->type)
    soap_set_attr(soap, "type", a->type, 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns5__CtrlPlaneAddressContent * SOAP_FMAC4 soap_in_ns5__CtrlPlaneAddressContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneAddressContent *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct ns5__CtrlPlaneAddressContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlaneAddressContent, sizeof(struct ns5__CtrlPlaneAddressContent), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default_ns5__CtrlPlaneAddressContent(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "value", 0), &a->value, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "type", 0), &a->type, -1, -1))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, "ns5:CtrlPlaneAddressContent"))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlaneAddressContent(struct soap *soap, const struct ns5__CtrlPlaneAddressContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlaneAddressContent);
  if (soap_out_ns5__CtrlPlaneAddressContent(soap, tag?tag:"ns5:CtrlPlaneAddressContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneAddressContent * SOAP_FMAC4 soap_get_ns5__CtrlPlaneAddressContent(struct soap *soap, struct ns5__CtrlPlaneAddressContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlaneAddressContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlaneLinkContent(struct soap *soap, struct ns5__CtrlPlaneLinkContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->remoteLinkId);
  soap_default_string(soap, &a->trafficEngineeringMetric);
  soap_default_string(soap, &a->capacity);
  soap_default_string(soap, &a->maximumReservableCapacity);
  soap_default_string(soap, &a->minimumReservableCapacity);
  soap_default_string(soap, &a->granularity);
  soap_default_string(soap, &a->unreservedCapacity);
  a->__sizelinkProtectionTypes = 0;
  a->linkProtectionTypes = NULL;
  a->__sizeadministrativeGroups = 0;
  a->administrativeGroups = NULL;
  a->SwitchingCapabilityDescriptors = NULL;
  soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlaneLinkContent(struct soap *soap, const struct ns5__CtrlPlaneLinkContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->remoteLinkId);
  soap_serialize_string(soap, &a->trafficEngineeringMetric);
  soap_serialize_string(soap, &a->capacity);
  soap_serialize_string(soap, &a->maximumReservableCapacity);
  soap_serialize_string(soap, &a->minimumReservableCapacity);
  soap_serialize_string(soap, &a->granularity);
  soap_serialize_string(soap, &a->unreservedCapacity);
  if (a->linkProtectionTypes) {
    int i;
    for (i = 0; i < a->__sizelinkProtectionTypes; i++) {
      soap_serialize_string(soap, a->linkProtectionTypes + i);
    }
  }
  if (a->administrativeGroups) {
    int i;
    for (i = 0; i < a->__sizeadministrativeGroups; i++) {
      soap_serialize_PointerTons5__CtrlPlaneAdministrativeGroup(soap, a->administrativeGroups + i);
    }
  }
  soap_serialize_PointerTons5__CtrlPlaneSwcapContent(soap, &a->SwitchingCapabilityDescriptors);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlaneLinkContent(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlaneLinkContent *a, const char *type) {
  if (a->id)
    soap_set_attr(soap, "id", a->id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CtrlPlaneLinkContent), type))
    return soap->error;
  if (soap_out_string(soap, "ns5:remoteLinkId", -1, &a->remoteLinkId, ""))
    return soap->error;
  if (a->trafficEngineeringMetric) {
    if (soap_out_string(soap, "ns5:trafficEngineeringMetric", -1, &a->trafficEngineeringMetric, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns5:trafficEngineeringMetric"))
    return soap->error;
  if (soap_out_string(soap, "ns5:capacity", -1, &a->capacity, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:maximumReservableCapacity", -1, &a->maximumReservableCapacity, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:minimumReservableCapacity", -1, &a->minimumReservableCapacity, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:granularity", -1, &a->granularity, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:unreservedCapacity", -1, &a->unreservedCapacity, ""))
    return soap->error;
  if (a->linkProtectionTypes) {
    int i;
    for (i = 0; i < a->__sizelinkProtectionTypes; i++)
      if (soap_out_string(soap, "ns5:linkProtectionTypes", -1, a->linkProtectionTypes + i, ""))
        return soap->error;
  }
  if (a->administrativeGroups) {
    int i;
    for (i = 0; i < a->__sizeadministrativeGroups; i++)
      if (soap_out_PointerTons5__CtrlPlaneAdministrativeGroup(soap, "ns5:administrativeGroups", -1, a->administrativeGroups + i, ""))
        return soap->error;
  }
  if (a->SwitchingCapabilityDescriptors) {
    if (soap_out_PointerTons5__CtrlPlaneSwcapContent(soap, "ns5:SwitchingCapabilityDescriptors", -1, &a->SwitchingCapabilityDescriptors, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns5:SwitchingCapabilityDescriptors"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__CtrlPlaneLinkContent * SOAP_FMAC4 soap_in_ns5__CtrlPlaneLinkContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneLinkContent *a, const char *type) {
  size_t soap_flag_remoteLinkId = 1;
  size_t soap_flag_trafficEngineeringMetric = 1;
  size_t soap_flag_capacity = 1;
  size_t soap_flag_maximumReservableCapacity = 1;
  size_t soap_flag_minimumReservableCapacity = 1;
  size_t soap_flag_granularity = 1;
  size_t soap_flag_unreservedCapacity = 1;
  struct soap_blist *soap_blist_linkProtectionTypes = NULL;
  struct soap_blist *soap_blist_administrativeGroups = NULL;
  size_t soap_flag_SwitchingCapabilityDescriptors = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns5__CtrlPlaneLinkContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlaneLinkContent, sizeof(struct ns5__CtrlPlaneLinkContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns5__CtrlPlaneLinkContent(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_remoteLinkId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:remoteLinkId", &a->remoteLinkId, "xsd:string")) {
          soap_flag_remoteLinkId--;
          continue;
        }
      if (soap_flag_trafficEngineeringMetric && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:trafficEngineeringMetric", &a->trafficEngineeringMetric, "xsd:string")) {
          soap_flag_trafficEngineeringMetric--;
          continue;
        }
      if (soap_flag_capacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:capacity", &a->capacity, "xsd:string")) {
          soap_flag_capacity--;
          continue;
        }
      if (soap_flag_maximumReservableCapacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:maximumReservableCapacity", &a->maximumReservableCapacity, "xsd:string")) {
          soap_flag_maximumReservableCapacity--;
          continue;
        }
      if (soap_flag_minimumReservableCapacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:minimumReservableCapacity", &a->minimumReservableCapacity, "xsd:string")) {
          soap_flag_minimumReservableCapacity--;
          continue;
        }
      if (soap_flag_granularity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:granularity", &a->granularity, "xsd:string")) {
          soap_flag_granularity--;
          continue;
        }
      if (soap_flag_unreservedCapacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:unreservedCapacity", &a->unreservedCapacity, "xsd:string")) {
          soap_flag_unreservedCapacity--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:linkProtectionTypes", 1, NULL)) {
        if (a->linkProtectionTypes == NULL) {
          if (soap_blist_linkProtectionTypes == NULL)
            soap_blist_linkProtectionTypes = soap_new_block(soap);
          a->linkProtectionTypes = (char **)soap_push_block(soap, soap_blist_linkProtectionTypes, sizeof(char *));
          if (a->linkProtectionTypes == NULL)
            return NULL;
          *a->linkProtectionTypes = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns5:linkProtectionTypes", a->linkProtectionTypes, "xsd:string")) {
          a->__sizelinkProtectionTypes++;
          a->linkProtectionTypes = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:administrativeGroups", 1, NULL)) {
        if (a->administrativeGroups == NULL) {
          if (soap_blist_administrativeGroups == NULL)
            soap_blist_administrativeGroups = soap_new_block(soap);
          a->administrativeGroups = (struct ns5__CtrlPlaneAdministrativeGroup **)soap_push_block(soap, soap_blist_administrativeGroups, sizeof(struct ns5__CtrlPlaneAdministrativeGroup *));
          if (a->administrativeGroups == NULL)
            return NULL;
          *a->administrativeGroups = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons5__CtrlPlaneAdministrativeGroup(soap, "ns5:administrativeGroups", a->administrativeGroups, "ns5:CtrlPlaneAdministrativeGroup")) {
          a->__sizeadministrativeGroups++;
          a->administrativeGroups = NULL;
          continue;
        }
      }
      if (soap_flag_SwitchingCapabilityDescriptors && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__CtrlPlaneSwcapContent(soap, "ns5:SwitchingCapabilityDescriptors", &a->SwitchingCapabilityDescriptors, "ns5:CtrlPlaneSwcapContent")) {
          soap_flag_SwitchingCapabilityDescriptors--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->linkProtectionTypes)
      soap_pop_block(soap, soap_blist_linkProtectionTypes);
    if (a->__sizelinkProtectionTypes)
      a->linkProtectionTypes = (char **)soap_save_block(soap, soap_blist_linkProtectionTypes, NULL, 1);
    else {
      a->linkProtectionTypes = NULL;
      if (soap_blist_linkProtectionTypes)
        soap_end_block(soap, soap_blist_linkProtectionTypes);
    }
    if (a->administrativeGroups)
      soap_pop_block(soap, soap_blist_administrativeGroups);
    if (a->__sizeadministrativeGroups)
      a->administrativeGroups = (struct ns5__CtrlPlaneAdministrativeGroup **)soap_save_block(soap, soap_blist_administrativeGroups, NULL, 1);
    else {
      a->administrativeGroups = NULL;
      if (soap_blist_administrativeGroups)
        soap_end_block(soap, soap_blist_administrativeGroups);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneLinkContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CtrlPlaneLinkContent, 0, sizeof(struct ns5__CtrlPlaneLinkContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trafficEngineeringMetric > 0 || soap_flag_SwitchingCapabilityDescriptors > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlaneLinkContent(struct soap *soap, const struct ns5__CtrlPlaneLinkContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlaneLinkContent);
  if (soap_out_ns5__CtrlPlaneLinkContent(soap, tag?tag:"ns5:CtrlPlaneLinkContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneLinkContent * SOAP_FMAC4 soap_get_ns5__CtrlPlaneLinkContent(struct soap *soap, struct ns5__CtrlPlaneLinkContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlaneLinkContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlanePortContent(struct soap *soap, struct ns5__CtrlPlanePortContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->lifetime = NULL;
  soap_default_string(soap, &a->capacity);
  soap_default_string(soap, &a->maximumReservableCapacity);
  soap_default_string(soap, &a->minimumReservableCapacity);
  soap_default_string(soap, &a->granularity);
  soap_default_string(soap, &a->unreservedCapacity);
  a->__sizelink = 0;
  a->link = NULL;
  soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlanePortContent(struct soap *soap, const struct ns5__CtrlPlanePortContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons5__Lifetime(soap, &a->lifetime);
  soap_serialize_string(soap, &a->capacity);
  soap_serialize_string(soap, &a->maximumReservableCapacity);
  soap_serialize_string(soap, &a->minimumReservableCapacity);
  soap_serialize_string(soap, &a->granularity);
  soap_serialize_string(soap, &a->unreservedCapacity);
  if (a->link) {
    int i;
    for (i = 0; i < a->__sizelink; i++) {
      soap_serialize_PointerTons5__CtrlPlaneLinkContent(soap, a->link + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlanePortContent(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlanePortContent *a, const char *type) {
  if (a->id)
    soap_set_attr(soap, "id", a->id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CtrlPlanePortContent), type))
    return soap->error;
  if (soap_out_PointerTons5__Lifetime(soap, "ns5:lifetime", -1, &a->lifetime, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:capacity", -1, &a->capacity, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:maximumReservableCapacity", -1, &a->maximumReservableCapacity, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:minimumReservableCapacity", -1, &a->minimumReservableCapacity, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:granularity", -1, &a->granularity, ""))
    return soap->error;
  if (soap_out_string(soap, "ns5:unreservedCapacity", -1, &a->unreservedCapacity, ""))
    return soap->error;
  if (a->link) {
    int i;
    for (i = 0; i < a->__sizelink; i++)
      if (soap_out_PointerTons5__CtrlPlaneLinkContent(soap, "ns5:link", -1, a->link + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__CtrlPlanePortContent * SOAP_FMAC4 soap_in_ns5__CtrlPlanePortContent(struct soap *soap, const char *tag, struct ns5__CtrlPlanePortContent *a, const char *type) {
  size_t soap_flag_lifetime = 1;
  size_t soap_flag_capacity = 1;
  size_t soap_flag_maximumReservableCapacity = 1;
  size_t soap_flag_minimumReservableCapacity = 1;
  size_t soap_flag_granularity = 1;
  size_t soap_flag_unreservedCapacity = 1;
  struct soap_blist *soap_blist_link = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns5__CtrlPlanePortContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlanePortContent, sizeof(struct ns5__CtrlPlanePortContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns5__CtrlPlanePortContent(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_lifetime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__Lifetime(soap, "ns5:lifetime", &a->lifetime, "ns5:Lifetime")) {
          soap_flag_lifetime--;
          continue;
        }
      if (soap_flag_capacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:capacity", &a->capacity, "xsd:string")) {
          soap_flag_capacity--;
          continue;
        }
      if (soap_flag_maximumReservableCapacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:maximumReservableCapacity", &a->maximumReservableCapacity, "xsd:string")) {
          soap_flag_maximumReservableCapacity--;
          continue;
        }
      if (soap_flag_minimumReservableCapacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:minimumReservableCapacity", &a->minimumReservableCapacity, "xsd:string")) {
          soap_flag_minimumReservableCapacity--;
          continue;
        }
      if (soap_flag_granularity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:granularity", &a->granularity, "xsd:string")) {
          soap_flag_granularity--;
          continue;
        }
      if (soap_flag_unreservedCapacity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:unreservedCapacity", &a->unreservedCapacity, "xsd:string")) {
          soap_flag_unreservedCapacity--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:link", 1, NULL)) {
        if (a->link == NULL) {
          if (soap_blist_link == NULL)
            soap_blist_link = soap_new_block(soap);
          a->link = (struct ns5__CtrlPlaneLinkContent **)soap_push_block(soap, soap_blist_link, sizeof(struct ns5__CtrlPlaneLinkContent *));
          if (a->link == NULL)
            return NULL;
          *a->link = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons5__CtrlPlaneLinkContent(soap, "ns5:link", a->link, "ns5:CtrlPlaneLinkContent")) {
          a->__sizelink++;
          a->link = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->link)
      soap_pop_block(soap, soap_blist_link);
    if (a->__sizelink)
      a->link = (struct ns5__CtrlPlaneLinkContent **)soap_save_block(soap, soap_blist_link, NULL, 1);
    else {
      a->link = NULL;
      if (soap_blist_link)
        soap_end_block(soap, soap_blist_link);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlanePortContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CtrlPlanePortContent, 0, sizeof(struct ns5__CtrlPlanePortContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlanePortContent(struct soap *soap, const struct ns5__CtrlPlanePortContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlanePortContent);
  if (soap_out_ns5__CtrlPlanePortContent(soap, tag?tag:"ns5:CtrlPlanePortContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlanePortContent * SOAP_FMAC4 soap_get_ns5__CtrlPlanePortContent(struct soap *soap, struct ns5__CtrlPlanePortContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlanePortContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlaneNodeContent(struct soap *soap, struct ns5__CtrlPlaneNodeContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->lifetime = NULL;
  a->address = NULL;
  a->__sizeport = 0;
  a->port = NULL;
  soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlaneNodeContent(struct soap *soap, const struct ns5__CtrlPlaneNodeContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons5__Lifetime(soap, &a->lifetime);
  soap_serialize_PointerTons5__CtrlPlaneAddressContent(soap, &a->address);
  if (a->port) {
    int i;
    for (i = 0; i < a->__sizeport; i++) {
      soap_serialize_PointerTons5__CtrlPlanePortContent(soap, a->port + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlaneNodeContent(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlaneNodeContent *a, const char *type) {
  if (a->id)
    soap_set_attr(soap, "id", a->id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CtrlPlaneNodeContent), type))
    return soap->error;
  if (soap_out_PointerTons5__Lifetime(soap, "ns5:lifetime", -1, &a->lifetime, ""))
    return soap->error;
  if (soap_out_PointerTons5__CtrlPlaneAddressContent(soap, "ns5:address", -1, &a->address, ""))
    return soap->error;
  if (a->port) {
    int i;
    for (i = 0; i < a->__sizeport; i++)
      if (soap_out_PointerTons5__CtrlPlanePortContent(soap, "ns5:port", -1, a->port + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__CtrlPlaneNodeContent * SOAP_FMAC4 soap_in_ns5__CtrlPlaneNodeContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneNodeContent *a, const char *type) {
  size_t soap_flag_lifetime = 1;
  size_t soap_flag_address = 1;
  struct soap_blist *soap_blist_port = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns5__CtrlPlaneNodeContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlaneNodeContent, sizeof(struct ns5__CtrlPlaneNodeContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns5__CtrlPlaneNodeContent(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_lifetime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__Lifetime(soap, "ns5:lifetime", &a->lifetime, "ns5:Lifetime")) {
          soap_flag_lifetime--;
          continue;
        }
      if (soap_flag_address && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__CtrlPlaneAddressContent(soap, "ns5:address", &a->address, "ns5:CtrlPlaneAddressContent")) {
          soap_flag_address--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:port", 1, NULL)) {
        if (a->port == NULL) {
          if (soap_blist_port == NULL)
            soap_blist_port = soap_new_block(soap);
          a->port = (struct ns5__CtrlPlanePortContent **)soap_push_block(soap, soap_blist_port, sizeof(struct ns5__CtrlPlanePortContent *));
          if (a->port == NULL)
            return NULL;
          *a->port = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons5__CtrlPlanePortContent(soap, "ns5:port", a->port, "ns5:CtrlPlanePortContent")) {
          a->__sizeport++;
          a->port = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->port)
      soap_pop_block(soap, soap_blist_port);
    if (a->__sizeport)
      a->port = (struct ns5__CtrlPlanePortContent **)soap_save_block(soap, soap_blist_port, NULL, 1);
    else {
      a->port = NULL;
      if (soap_blist_port)
        soap_end_block(soap, soap_blist_port);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneNodeContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CtrlPlaneNodeContent, 0, sizeof(struct ns5__CtrlPlaneNodeContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlaneNodeContent(struct soap *soap, const struct ns5__CtrlPlaneNodeContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlaneNodeContent);
  if (soap_out_ns5__CtrlPlaneNodeContent(soap, tag?tag:"ns5:CtrlPlaneNodeContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneNodeContent * SOAP_FMAC4 soap_get_ns5__CtrlPlaneNodeContent(struct soap *soap, struct ns5__CtrlPlaneNodeContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlaneNodeContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__Lifetime(struct soap *soap, struct ns5__Lifetime *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->start = NULL;
  a->end = NULL;
  a->duration = NULL;
  soap_default_string(soap, &a->id);
  soap_default_string(soap, &a->direction);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__Lifetime(struct soap *soap, const struct ns5__Lifetime *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons5__TimeContent(soap, &a->start);
  soap_serialize_PointerTons5__TimeContent(soap, &a->end);
  soap_serialize_PointerTons5__Duration(soap, &a->duration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Lifetime(struct soap *soap, const char *tag, int id, const struct ns5__Lifetime *a, const char *type) {
  if (a->id)
    soap_set_attr(soap, "id", a->id, 1);
  if (a->direction)
    soap_set_attr(soap, "direction", a->direction, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Lifetime), type))
    return soap->error;
  if (soap_out_PointerTons5__TimeContent(soap, "ns5:start", -1, &a->start, ""))
    return soap->error;
  if (soap_out_PointerTons5__TimeContent(soap, "ns5:end", -1, &a->end, ""))
    return soap->error;
  if (soap_out_PointerTons5__Duration(soap, "ns5:duration", -1, &a->duration, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__Lifetime * SOAP_FMAC4 soap_in_ns5__Lifetime(struct soap *soap, const char *tag, struct ns5__Lifetime *a, const char *type) {
  size_t soap_flag_start = 1;
  size_t soap_flag_end = 1;
  size_t soap_flag_duration = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns5__Lifetime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Lifetime, sizeof(struct ns5__Lifetime), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns5__Lifetime(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "direction", 0), &a->direction, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__TimeContent(soap, "ns5:start", &a->start, "ns5:TimeContent")) {
          soap_flag_start--;
          continue;
        }
      if (soap_flag_end && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__TimeContent(soap, "ns5:end", &a->end, "ns5:TimeContent")) {
          soap_flag_end--;
          continue;
        }
      if (soap_flag_duration && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__Duration(soap, "ns5:duration", &a->duration, "ns5:Duration")) {
          soap_flag_duration--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns5__Lifetime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Lifetime, 0, sizeof(struct ns5__Lifetime), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__Lifetime(struct soap *soap, const struct ns5__Lifetime *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__Lifetime);
  if (soap_out_ns5__Lifetime(soap, tag?tag:"ns5:Lifetime", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__Lifetime * SOAP_FMAC4 soap_get_ns5__Lifetime(struct soap *soap, struct ns5__Lifetime *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__Lifetime(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns5__CtrlPlaneDomainSignatureContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->domainId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlaneDomainSignatureContent(struct soap *soap, const struct ns5__CtrlPlaneDomainSignatureContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlaneDomainSignatureContent(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlaneDomainSignatureContent *a, const char *type) {
  if (a->domainId)
    soap_set_attr(soap, "domainId", a->domainId, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CtrlPlaneDomainSignatureContent), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__CtrlPlaneDomainSignatureContent * SOAP_FMAC4 soap_in_ns5__CtrlPlaneDomainSignatureContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneDomainSignatureContent *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns5__CtrlPlaneDomainSignatureContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlaneDomainSignatureContent, sizeof(struct ns5__CtrlPlaneDomainSignatureContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns5__CtrlPlaneDomainSignatureContent(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "domainId", 1), &a->domainId, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneDomainSignatureContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CtrlPlaneDomainSignatureContent, 0, sizeof(struct ns5__CtrlPlaneDomainSignatureContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlaneDomainSignatureContent(struct soap *soap, const struct ns5__CtrlPlaneDomainSignatureContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlaneDomainSignatureContent);
  if (soap_out_ns5__CtrlPlaneDomainSignatureContent(soap, tag?tag:"ns5:CtrlPlaneDomainSignatureContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneDomainSignatureContent * SOAP_FMAC4 soap_get_ns5__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns5__CtrlPlaneDomainSignatureContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlaneDomainSignatureContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlaneDomainContent(struct soap *soap, struct ns5__CtrlPlaneDomainContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->lifetime = NULL;
  a->__sizenode = 0;
  a->node = NULL;
  a->__sizeport = 0;
  a->port = NULL;
  a->__sizelink = 0;
  a->link = NULL;
  soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlaneDomainContent(struct soap *soap, const struct ns5__CtrlPlaneDomainContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons5__Lifetime(soap, &a->lifetime);
  if (a->node) {
    int i;
    for (i = 0; i < a->__sizenode; i++) {
      soap_serialize_PointerTons5__CtrlPlaneNodeContent(soap, a->node + i);
    }
  }
  if (a->port) {
    int i;
    for (i = 0; i < a->__sizeport; i++) {
      soap_serialize_PointerTons5__CtrlPlanePortContent(soap, a->port + i);
    }
  }
  if (a->link) {
    int i;
    for (i = 0; i < a->__sizelink; i++) {
      soap_serialize_PointerTons5__CtrlPlaneLinkContent(soap, a->link + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlaneDomainContent(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlaneDomainContent *a, const char *type) {
  if (a->id)
    soap_set_attr(soap, "id", a->id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CtrlPlaneDomainContent), type))
    return soap->error;
  if (soap_out_PointerTons5__Lifetime(soap, "ns5:lifetime", -1, &a->lifetime, ""))
    return soap->error;
  if (a->node) {
    int i;
    for (i = 0; i < a->__sizenode; i++)
      if (soap_out_PointerTons5__CtrlPlaneNodeContent(soap, "ns5:node", -1, a->node + i, ""))
        return soap->error;
  }
  if (a->port) {
    int i;
    for (i = 0; i < a->__sizeport; i++)
      if (soap_out_PointerTons5__CtrlPlanePortContent(soap, "ns5:port", -1, a->port + i, ""))
        return soap->error;
  }
  if (a->link) {
    int i;
    for (i = 0; i < a->__sizelink; i++)
      if (soap_out_PointerTons5__CtrlPlaneLinkContent(soap, "ns5:link", -1, a->link + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__CtrlPlaneDomainContent * SOAP_FMAC4 soap_in_ns5__CtrlPlaneDomainContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneDomainContent *a, const char *type) {
  size_t soap_flag_lifetime = 1;
  struct soap_blist *soap_blist_node = NULL;
  struct soap_blist *soap_blist_port = NULL;
  struct soap_blist *soap_blist_link = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns5__CtrlPlaneDomainContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlaneDomainContent, sizeof(struct ns5__CtrlPlaneDomainContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns5__CtrlPlaneDomainContent(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_lifetime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__Lifetime(soap, "ns5:lifetime", &a->lifetime, "ns5:Lifetime")) {
          soap_flag_lifetime--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:node", 1, NULL)) {
        if (a->node == NULL) {
          if (soap_blist_node == NULL)
            soap_blist_node = soap_new_block(soap);
          a->node = (struct ns5__CtrlPlaneNodeContent **)soap_push_block(soap, soap_blist_node, sizeof(struct ns5__CtrlPlaneNodeContent *));
          if (a->node == NULL)
            return NULL;
          *a->node = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons5__CtrlPlaneNodeContent(soap, "ns5:node", a->node, "ns5:CtrlPlaneNodeContent")) {
          a->__sizenode++;
          a->node = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:port", 1, NULL)) {
        if (a->port == NULL) {
          if (soap_blist_port == NULL)
            soap_blist_port = soap_new_block(soap);
          a->port = (struct ns5__CtrlPlanePortContent **)soap_push_block(soap, soap_blist_port, sizeof(struct ns5__CtrlPlanePortContent *));
          if (a->port == NULL)
            return NULL;
          *a->port = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons5__CtrlPlanePortContent(soap, "ns5:port", a->port, "ns5:CtrlPlanePortContent")) {
          a->__sizeport++;
          a->port = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:link", 1, NULL)) {
        if (a->link == NULL) {
          if (soap_blist_link == NULL)
            soap_blist_link = soap_new_block(soap);
          a->link = (struct ns5__CtrlPlaneLinkContent **)soap_push_block(soap, soap_blist_link, sizeof(struct ns5__CtrlPlaneLinkContent *));
          if (a->link == NULL)
            return NULL;
          *a->link = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons5__CtrlPlaneLinkContent(soap, "ns5:link", a->link, "ns5:CtrlPlaneLinkContent")) {
          a->__sizelink++;
          a->link = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->node)
      soap_pop_block(soap, soap_blist_node);
    if (a->__sizenode)
      a->node = (struct ns5__CtrlPlaneNodeContent **)soap_save_block(soap, soap_blist_node, NULL, 1);
    else {
      a->node = NULL;
      if (soap_blist_node)
        soap_end_block(soap, soap_blist_node);
    }
    if (a->port)
      soap_pop_block(soap, soap_blist_port);
    if (a->__sizeport)
      a->port = (struct ns5__CtrlPlanePortContent **)soap_save_block(soap, soap_blist_port, NULL, 1);
    else {
      a->port = NULL;
      if (soap_blist_port)
        soap_end_block(soap, soap_blist_port);
    }
    if (a->link)
      soap_pop_block(soap, soap_blist_link);
    if (a->__sizelink)
      a->link = (struct ns5__CtrlPlaneLinkContent **)soap_save_block(soap, soap_blist_link, NULL, 1);
    else {
      a->link = NULL;
      if (soap_blist_link)
        soap_end_block(soap, soap_blist_link);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneDomainContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CtrlPlaneDomainContent, 0, sizeof(struct ns5__CtrlPlaneDomainContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlaneDomainContent(struct soap *soap, const struct ns5__CtrlPlaneDomainContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlaneDomainContent);
  if (soap_out_ns5__CtrlPlaneDomainContent(soap, tag?tag:"ns5:CtrlPlaneDomainContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneDomainContent * SOAP_FMAC4 soap_get_ns5__CtrlPlaneDomainContent(struct soap *soap, struct ns5__CtrlPlaneDomainContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlaneDomainContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__ResumeSubscriptionResponse(struct soap *soap, struct _ns3__ResumeSubscriptionResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->SubscriptionReference = NULL;
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__ResumeSubscriptionResponse(struct soap *soap, const struct _ns3__ResumeSubscriptionResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _ns3__ResumeSubscriptionResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__ResumeSubscriptionResponse), type))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", -1, &a->SubscriptionReference, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__ResumeSubscriptionResponse * SOAP_FMAC4 soap_in__ns3__ResumeSubscriptionResponse(struct soap *soap, const char *tag, struct _ns3__ResumeSubscriptionResponse *a, const char *type) {
  size_t soap_flag_SubscriptionReference = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__ResumeSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__ResumeSubscriptionResponse, sizeof(struct _ns3__ResumeSubscriptionResponse), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__ResumeSubscriptionResponse(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType")) {
          soap_flag_SubscriptionReference--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__ResumeSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__ResumeSubscriptionResponse, 0, sizeof(struct _ns3__ResumeSubscriptionResponse), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__ResumeSubscriptionResponse(struct soap *soap, const struct _ns3__ResumeSubscriptionResponse *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__ResumeSubscriptionResponse);
  if (soap_out__ns3__ResumeSubscriptionResponse(soap, tag?tag:"ns3:ResumeSubscriptionResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__ResumeSubscriptionResponse * SOAP_FMAC4 soap_get__ns3__ResumeSubscriptionResponse(struct soap *soap, struct _ns3__ResumeSubscriptionResponse *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__ResumeSubscriptionResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__ResumeSubscription(struct soap *soap, struct _ns3__ResumeSubscription *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__ResumeSubscription(struct soap *soap, const struct _ns3__ResumeSubscription *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
  soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ResumeSubscription(struct soap *soap, const char *tag, int id, const struct _ns3__ResumeSubscription *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__ResumeSubscription), type))
    return soap->error;
  if (soap_out_wsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", -1, &a->SubscriptionReference, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__ResumeSubscription * SOAP_FMAC4 soap_in__ns3__ResumeSubscription(struct soap *soap, const char *tag, struct _ns3__ResumeSubscription *a, const char *type) {
  size_t soap_flag_SubscriptionReference = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__ResumeSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__ResumeSubscription, sizeof(struct _ns3__ResumeSubscription), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__ResumeSubscription(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_wsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType")) {
          soap_flag_SubscriptionReference--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__ResumeSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__ResumeSubscription, 0, sizeof(struct _ns3__ResumeSubscription), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__ResumeSubscription(struct soap *soap, const struct _ns3__ResumeSubscription *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__ResumeSubscription);
  if (soap_out__ns3__ResumeSubscription(soap, tag?tag:"ns3:ResumeSubscription", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__ResumeSubscription * SOAP_FMAC4 soap_get__ns3__ResumeSubscription(struct soap *soap, struct _ns3__ResumeSubscription *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__ResumeSubscription(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__PauseSubscriptionResponse(struct soap *soap, struct _ns3__PauseSubscriptionResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->SubscriptionReference = NULL;
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__PauseSubscriptionResponse(struct soap *soap, const struct _ns3__PauseSubscriptionResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _ns3__PauseSubscriptionResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__PauseSubscriptionResponse), type))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", -1, &a->SubscriptionReference, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__PauseSubscriptionResponse * SOAP_FMAC4 soap_in__ns3__PauseSubscriptionResponse(struct soap *soap, const char *tag, struct _ns3__PauseSubscriptionResponse *a, const char *type) {
  size_t soap_flag_SubscriptionReference = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__PauseSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__PauseSubscriptionResponse, sizeof(struct _ns3__PauseSubscriptionResponse), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__PauseSubscriptionResponse(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType")) {
          soap_flag_SubscriptionReference--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__PauseSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__PauseSubscriptionResponse, 0, sizeof(struct _ns3__PauseSubscriptionResponse), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__PauseSubscriptionResponse(struct soap *soap, const struct _ns3__PauseSubscriptionResponse *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__PauseSubscriptionResponse);
  if (soap_out__ns3__PauseSubscriptionResponse(soap, tag?tag:"ns3:PauseSubscriptionResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__PauseSubscriptionResponse * SOAP_FMAC4 soap_get__ns3__PauseSubscriptionResponse(struct soap *soap, struct _ns3__PauseSubscriptionResponse *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__PauseSubscriptionResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__PauseSubscription(struct soap *soap, struct _ns3__PauseSubscription *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__PauseSubscription(struct soap *soap, const struct _ns3__PauseSubscription *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
  soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__PauseSubscription(struct soap *soap, const char *tag, int id, const struct _ns3__PauseSubscription *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__PauseSubscription), type))
    return soap->error;
  if (soap_out_wsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", -1, &a->SubscriptionReference, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__PauseSubscription * SOAP_FMAC4 soap_in__ns3__PauseSubscription(struct soap *soap, const char *tag, struct _ns3__PauseSubscription *a, const char *type) {
  size_t soap_flag_SubscriptionReference = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__PauseSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__PauseSubscription, sizeof(struct _ns3__PauseSubscription), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__PauseSubscription(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_wsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType")) {
          soap_flag_SubscriptionReference--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__PauseSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__PauseSubscription, 0, sizeof(struct _ns3__PauseSubscription), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__PauseSubscription(struct soap *soap, const struct _ns3__PauseSubscription *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__PauseSubscription);
  if (soap_out__ns3__PauseSubscription(soap, tag?tag:"ns3:PauseSubscription", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__PauseSubscription * SOAP_FMAC4 soap_get__ns3__PauseSubscription(struct soap *soap, struct _ns3__PauseSubscription *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__PauseSubscription(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__UnsubscribeResponse(struct soap *soap, struct _ns3__UnsubscribeResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->SubscriptionReference = NULL;
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__UnsubscribeResponse(struct soap *soap, const struct _ns3__UnsubscribeResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UnsubscribeResponse(struct soap *soap, const char *tag, int id, const struct _ns3__UnsubscribeResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UnsubscribeResponse), type))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", -1, &a->SubscriptionReference, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__UnsubscribeResponse * SOAP_FMAC4 soap_in__ns3__UnsubscribeResponse(struct soap *soap, const char *tag, struct _ns3__UnsubscribeResponse *a, const char *type) {
  size_t soap_flag_SubscriptionReference = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__UnsubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UnsubscribeResponse, sizeof(struct _ns3__UnsubscribeResponse), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__UnsubscribeResponse(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType")) {
          soap_flag_SubscriptionReference--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UnsubscribeResponse, 0, sizeof(struct _ns3__UnsubscribeResponse), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__UnsubscribeResponse(struct soap *soap, const struct _ns3__UnsubscribeResponse *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__UnsubscribeResponse);
  if (soap_out__ns3__UnsubscribeResponse(soap, tag?tag:"ns3:UnsubscribeResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__UnsubscribeResponse * SOAP_FMAC4 soap_get__ns3__UnsubscribeResponse(struct soap *soap, struct _ns3__UnsubscribeResponse *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__UnsubscribeResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__Unsubscribe(struct soap *soap, struct _ns3__Unsubscribe *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__Unsubscribe(struct soap *soap, const struct _ns3__Unsubscribe *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
  soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Unsubscribe(struct soap *soap, const char *tag, int id, const struct _ns3__Unsubscribe *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Unsubscribe), type))
    return soap->error;
  if (soap_out_wsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", -1, &a->SubscriptionReference, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__Unsubscribe * SOAP_FMAC4 soap_in__ns3__Unsubscribe(struct soap *soap, const char *tag, struct _ns3__Unsubscribe *a, const char *type) {
  size_t soap_flag_SubscriptionReference = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__Unsubscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Unsubscribe, sizeof(struct _ns3__Unsubscribe), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__Unsubscribe(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_wsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType")) {
          soap_flag_SubscriptionReference--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Unsubscribe, 0, sizeof(struct _ns3__Unsubscribe), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__Unsubscribe(struct soap *soap, const struct _ns3__Unsubscribe *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__Unsubscribe);
  if (soap_out__ns3__Unsubscribe(soap, tag?tag:"ns3:Unsubscribe", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__Unsubscribe * SOAP_FMAC4 soap_get__ns3__Unsubscribe(struct soap *soap, struct _ns3__Unsubscribe *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__Unsubscribe(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__RenewResponse(struct soap *soap, struct _ns3__RenewResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_time(soap, &a->TerminationTime);
  a->CurrentTime = NULL;
  a->SubscriptionReference = NULL;
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__RenewResponse(struct soap *soap, const struct _ns3__RenewResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->TerminationTime, SOAP_TYPE_time);
  soap_serialize_PointerTotime(soap, &a->CurrentTime);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RenewResponse(struct soap *soap, const char *tag, int id, const struct _ns3__RenewResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__RenewResponse), type))
    return soap->error;
  if (soap_out_time(soap, "ns3:TerminationTime", -1, &a->TerminationTime, ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "ns3:CurrentTime", -1, &a->CurrentTime, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", -1, &a->SubscriptionReference, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__RenewResponse * SOAP_FMAC4 soap_in__ns3__RenewResponse(struct soap *soap, const char *tag, struct _ns3__RenewResponse *a, const char *type) {
  size_t soap_flag_TerminationTime = 1;
  size_t soap_flag_CurrentTime = 1;
  size_t soap_flag_SubscriptionReference = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__RenewResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__RenewResponse, sizeof(struct _ns3__RenewResponse), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__RenewResponse(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_time(soap, "ns3:TerminationTime", &a->TerminationTime, "xsd:dateTime")) {
          soap_flag_TerminationTime--;
          continue;
        }
      if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "ns3:CurrentTime", &a->CurrentTime, "xsd:dateTime")) {
          soap_flag_CurrentTime--;
          continue;
        }
      if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType")) {
          soap_flag_SubscriptionReference--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__RenewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__RenewResponse, 0, sizeof(struct _ns3__RenewResponse), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__RenewResponse(struct soap *soap, const struct _ns3__RenewResponse *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__RenewResponse);
  if (soap_out__ns3__RenewResponse(soap, tag?tag:"ns3:RenewResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__RenewResponse * SOAP_FMAC4 soap_get__ns3__RenewResponse(struct soap *soap, struct _ns3__RenewResponse *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__RenewResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__Renew(struct soap *soap, struct _ns3__Renew *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->TerminationTime);
  soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__Renew(struct soap *soap, const struct _ns3__Renew *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->TerminationTime);
  soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
  soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Renew(struct soap *soap, const char *tag, int id, const struct _ns3__Renew *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Renew), type))
    return soap->error;
  if (a->TerminationTime) {
    if (soap_out_string(soap, "ns3:TerminationTime", -1, &a->TerminationTime, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns3:TerminationTime"))
    return soap->error;
  if (soap_out_wsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", -1, &a->SubscriptionReference, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__Renew * SOAP_FMAC4 soap_in__ns3__Renew(struct soap *soap, const char *tag, struct _ns3__Renew *a, const char *type) {
  size_t soap_flag_TerminationTime = 1;
  size_t soap_flag_SubscriptionReference = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__Renew *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Renew, sizeof(struct _ns3__Renew), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__Renew(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_TerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns3:TerminationTime", &a->TerminationTime, "xsd:string")) {
          soap_flag_TerminationTime--;
          continue;
        }
      if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_wsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType")) {
          soap_flag_SubscriptionReference--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__Renew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Renew, 0, sizeof(struct _ns3__Renew), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0 || soap_flag_SubscriptionReference > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__Renew(struct soap *soap, const struct _ns3__Renew *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__Renew);
  if (soap_out__ns3__Renew(soap, tag?tag:"ns3:Renew", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__Renew * SOAP_FMAC4 soap_get__ns3__Renew(struct soap *soap, struct _ns3__Renew *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__Renew(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__CreatePullPointResponse(struct soap *soap, struct _ns3__CreatePullPointResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_wsa5__EndpointReferenceType(soap, &a->PullPoint);
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__CreatePullPointResponse(struct soap *soap, const struct _ns3__CreatePullPointResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->PullPoint, SOAP_TYPE_wsa5__EndpointReferenceType);
  soap_serialize_wsa5__EndpointReferenceType(soap, &a->PullPoint);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CreatePullPointResponse(struct soap *soap, const char *tag, int id, const struct _ns3__CreatePullPointResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CreatePullPointResponse), type))
    return soap->error;
  if (soap_out_wsa5__EndpointReferenceType(soap, "ns3:PullPoint", -1, &a->PullPoint, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__CreatePullPointResponse * SOAP_FMAC4 soap_in__ns3__CreatePullPointResponse(struct soap *soap, const char *tag, struct _ns3__CreatePullPointResponse *a, const char *type) {
  size_t soap_flag_PullPoint = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__CreatePullPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CreatePullPointResponse, sizeof(struct _ns3__CreatePullPointResponse), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__CreatePullPointResponse(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_PullPoint && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_wsa5__EndpointReferenceType(soap, "ns3:PullPoint", &a->PullPoint, "wsa5:EndpointReferenceType")) {
          soap_flag_PullPoint--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__CreatePullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CreatePullPointResponse, 0, sizeof(struct _ns3__CreatePullPointResponse), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PullPoint > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__CreatePullPointResponse(struct soap *soap, const struct _ns3__CreatePullPointResponse *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__CreatePullPointResponse);
  if (soap_out__ns3__CreatePullPointResponse(soap, tag?tag:"ns3:CreatePullPointResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__CreatePullPointResponse * SOAP_FMAC4 soap_get__ns3__CreatePullPointResponse(struct soap *soap, struct _ns3__CreatePullPointResponse *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__CreatePullPointResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__CreatePullPoint(struct soap *soap, struct _ns3__CreatePullPoint *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__CreatePullPoint(struct soap *soap, const struct _ns3__CreatePullPoint *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CreatePullPoint(struct soap *soap, const char *tag, int id, const struct _ns3__CreatePullPoint *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CreatePullPoint), type))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__CreatePullPoint * SOAP_FMAC4 soap_in__ns3__CreatePullPoint(struct soap *soap, const char *tag, struct _ns3__CreatePullPoint *a, const char *type) {
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__CreatePullPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CreatePullPoint, sizeof(struct _ns3__CreatePullPoint), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__CreatePullPoint(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__CreatePullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CreatePullPoint, 0, sizeof(struct _ns3__CreatePullPoint), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__CreatePullPoint(struct soap *soap, const struct _ns3__CreatePullPoint *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__CreatePullPoint);
  if (soap_out__ns3__CreatePullPoint(soap, tag?tag:"ns3:CreatePullPoint", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__CreatePullPoint * SOAP_FMAC4 soap_get__ns3__CreatePullPoint(struct soap *soap, struct _ns3__CreatePullPoint *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__CreatePullPoint(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__DestroyPullPointResponse(struct soap *soap, struct _ns3__DestroyPullPointResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__DestroyPullPointResponse(struct soap *soap, const struct _ns3__DestroyPullPointResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, const struct _ns3__DestroyPullPointResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__DestroyPullPointResponse), type))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__DestroyPullPointResponse * SOAP_FMAC4 soap_in__ns3__DestroyPullPointResponse(struct soap *soap, const char *tag, struct _ns3__DestroyPullPointResponse *a, const char *type) {
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__DestroyPullPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__DestroyPullPointResponse, sizeof(struct _ns3__DestroyPullPointResponse), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__DestroyPullPointResponse(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__DestroyPullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__DestroyPullPointResponse, 0, sizeof(struct _ns3__DestroyPullPointResponse), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__DestroyPullPointResponse(struct soap *soap, const struct _ns3__DestroyPullPointResponse *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__DestroyPullPointResponse);
  if (soap_out__ns3__DestroyPullPointResponse(soap, tag?tag:"ns3:DestroyPullPointResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__DestroyPullPointResponse * SOAP_FMAC4 soap_get__ns3__DestroyPullPointResponse(struct soap *soap, struct _ns3__DestroyPullPointResponse *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__DestroyPullPointResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__DestroyPullPoint(struct soap *soap, struct _ns3__DestroyPullPoint *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__DestroyPullPoint(struct soap *soap, const struct _ns3__DestroyPullPoint *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__DestroyPullPoint(struct soap *soap, const char *tag, int id, const struct _ns3__DestroyPullPoint *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__DestroyPullPoint), type))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__DestroyPullPoint * SOAP_FMAC4 soap_in__ns3__DestroyPullPoint(struct soap *soap, const char *tag, struct _ns3__DestroyPullPoint *a, const char *type) {
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__DestroyPullPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__DestroyPullPoint, sizeof(struct _ns3__DestroyPullPoint), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__DestroyPullPoint(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__DestroyPullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__DestroyPullPoint, 0, sizeof(struct _ns3__DestroyPullPoint), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__DestroyPullPoint(struct soap *soap, const struct _ns3__DestroyPullPoint *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__DestroyPullPoint);
  if (soap_out__ns3__DestroyPullPoint(soap, tag?tag:"ns3:DestroyPullPoint", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__DestroyPullPoint * SOAP_FMAC4 soap_get__ns3__DestroyPullPoint(struct soap *soap, struct _ns3__DestroyPullPoint *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__DestroyPullPoint(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetMessagesResponse(struct soap *soap, struct _ns3__GetMessagesResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__sizeNotificationMessage = 0;
  a->NotificationMessage = NULL;
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetMessagesResponse(struct soap *soap, const struct _ns3__GetMessagesResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->NotificationMessage) {
    int i;
    for (i = 0; i < a->__sizeNotificationMessage; i++) {
      soap_serialize_PointerTons3__NotificationMessageHolderType(soap, a->NotificationMessage + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetMessagesResponse(struct soap *soap, const char *tag, int id, const struct _ns3__GetMessagesResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetMessagesResponse), type))
    return soap->error;
  if (a->NotificationMessage) {
    int i;
    for (i = 0; i < a->__sizeNotificationMessage; i++)
      if (soap_out_PointerTons3__NotificationMessageHolderType(soap, "ns3:NotificationMessage", -1, a->NotificationMessage + i, ""))
        return soap->error;
  }
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetMessagesResponse * SOAP_FMAC4 soap_in__ns3__GetMessagesResponse(struct soap *soap, const char *tag, struct _ns3__GetMessagesResponse *a, const char *type) {
  struct soap_blist *soap_blist_NotificationMessage = NULL;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__GetMessagesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetMessagesResponse, sizeof(struct _ns3__GetMessagesResponse), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__GetMessagesResponse(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:NotificationMessage", 1, NULL)) {
        if (a->NotificationMessage == NULL) {
          if (soap_blist_NotificationMessage == NULL)
            soap_blist_NotificationMessage = soap_new_block(soap);
          a->NotificationMessage = (struct ns3__NotificationMessageHolderType **)soap_push_block(soap, soap_blist_NotificationMessage, sizeof(struct ns3__NotificationMessageHolderType *));
          if (a->NotificationMessage == NULL)
            return NULL;
          *a->NotificationMessage = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons3__NotificationMessageHolderType(soap, "ns3:NotificationMessage", a->NotificationMessage, "ns3:NotificationMessageHolderType")) {
          a->__sizeNotificationMessage++;
          a->NotificationMessage = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->NotificationMessage)
      soap_pop_block(soap, soap_blist_NotificationMessage);
    if (a->__sizeNotificationMessage)
      a->NotificationMessage = (struct ns3__NotificationMessageHolderType **)soap_save_block(soap, soap_blist_NotificationMessage, NULL, 1);
    else {
      a->NotificationMessage = NULL;
      if (soap_blist_NotificationMessage)
        soap_end_block(soap, soap_blist_NotificationMessage);
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__GetMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetMessagesResponse, 0, sizeof(struct _ns3__GetMessagesResponse), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetMessagesResponse(struct soap *soap, const struct _ns3__GetMessagesResponse *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__GetMessagesResponse);
  if (soap_out__ns3__GetMessagesResponse(soap, tag?tag:"ns3:GetMessagesResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetMessagesResponse * SOAP_FMAC4 soap_get__ns3__GetMessagesResponse(struct soap *soap, struct _ns3__GetMessagesResponse *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__GetMessagesResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetMessages(struct soap *soap, struct _ns3__GetMessages *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->MaximumNumber = NULL;
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetMessages(struct soap *soap, const struct _ns3__GetMessages *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTounsignedInt(soap, &a->MaximumNumber);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetMessages(struct soap *soap, const char *tag, int id, const struct _ns3__GetMessages *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetMessages), type))
    return soap->error;
  if (soap_out_PointerTounsignedInt(soap, "ns3:MaximumNumber", -1, &a->MaximumNumber, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetMessages * SOAP_FMAC4 soap_in__ns3__GetMessages(struct soap *soap, const char *tag, struct _ns3__GetMessages *a, const char *type) {
  size_t soap_flag_MaximumNumber = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__GetMessages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetMessages, sizeof(struct _ns3__GetMessages), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__GetMessages(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_MaximumNumber && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTounsignedInt(soap, "ns3:MaximumNumber", &a->MaximumNumber, "xsd:unsignedInt")) {
          soap_flag_MaximumNumber--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__GetMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetMessages, 0, sizeof(struct _ns3__GetMessages), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetMessages(struct soap *soap, const struct _ns3__GetMessages *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__GetMessages);
  if (soap_out__ns3__GetMessages(soap, tag?tag:"ns3:GetMessages", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetMessages * SOAP_FMAC4 soap_get__ns3__GetMessages(struct soap *soap, struct _ns3__GetMessages *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__GetMessages(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetCurrentMessageResponse(struct soap *soap, struct _ns3__GetCurrentMessageResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetCurrentMessageResponse(struct soap *soap, const struct _ns3__GetCurrentMessageResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, const struct _ns3__GetCurrentMessageResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetCurrentMessageResponse), type))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetCurrentMessageResponse * SOAP_FMAC4 soap_in__ns3__GetCurrentMessageResponse(struct soap *soap, const char *tag, struct _ns3__GetCurrentMessageResponse *a, const char *type) {
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__GetCurrentMessageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetCurrentMessageResponse, sizeof(struct _ns3__GetCurrentMessageResponse), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__GetCurrentMessageResponse(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__GetCurrentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetCurrentMessageResponse, 0, sizeof(struct _ns3__GetCurrentMessageResponse), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetCurrentMessageResponse(struct soap *soap, const struct _ns3__GetCurrentMessageResponse *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__GetCurrentMessageResponse);
  if (soap_out__ns3__GetCurrentMessageResponse(soap, tag?tag:"ns3:GetCurrentMessageResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetCurrentMessageResponse * SOAP_FMAC4 soap_get__ns3__GetCurrentMessageResponse(struct soap *soap, struct _ns3__GetCurrentMessageResponse *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__GetCurrentMessageResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetCurrentMessage(struct soap *soap, struct _ns3__GetCurrentMessage *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->Topic = NULL;
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetCurrentMessage(struct soap *soap, const struct _ns3__GetCurrentMessage *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons3__TopicExpressionType(soap, &a->Topic);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetCurrentMessage(struct soap *soap, const char *tag, int id, const struct _ns3__GetCurrentMessage *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetCurrentMessage), type))
    return soap->error;
  if (a->Topic) {
    if (soap_out_PointerTons3__TopicExpressionType(soap, "ns3:Topic", -1, &a->Topic, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns3:Topic"))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetCurrentMessage * SOAP_FMAC4 soap_in__ns3__GetCurrentMessage(struct soap *soap, const char *tag, struct _ns3__GetCurrentMessage *a, const char *type) {
  size_t soap_flag_Topic = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__GetCurrentMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetCurrentMessage, sizeof(struct _ns3__GetCurrentMessage), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__GetCurrentMessage(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons3__TopicExpressionType(soap, "ns3:Topic", &a->Topic, "ns3:TopicExpressionType")) {
          soap_flag_Topic--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__GetCurrentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetCurrentMessage, 0, sizeof(struct _ns3__GetCurrentMessage), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Topic > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetCurrentMessage(struct soap *soap, const struct _ns3__GetCurrentMessage *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__GetCurrentMessage);
  if (soap_out__ns3__GetCurrentMessage(soap, tag?tag:"ns3:GetCurrentMessage", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetCurrentMessage * SOAP_FMAC4 soap_get__ns3__GetCurrentMessage(struct soap *soap, struct _ns3__GetCurrentMessage *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__GetCurrentMessage(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__SubscribeResponse(struct soap *soap, struct _ns3__SubscribeResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
  a->CurrentTime = NULL;
  a->TerminationTime = NULL;
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__SubscribeResponse(struct soap *soap, const struct _ns3__SubscribeResponse *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
  soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
  soap_serialize_PointerTotime(soap, &a->CurrentTime);
  soap_serialize_PointerTotime(soap, &a->TerminationTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__SubscribeResponse(struct soap *soap, const char *tag, int id, const struct _ns3__SubscribeResponse *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__SubscribeResponse), type))
    return soap->error;
  if (soap_out_wsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", -1, &a->SubscriptionReference, ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "ns3:CurrentTime", -1, &a->CurrentTime, ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "ns3:TerminationTime", -1, &a->TerminationTime, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__SubscribeResponse * SOAP_FMAC4 soap_in__ns3__SubscribeResponse(struct soap *soap, const char *tag, struct _ns3__SubscribeResponse *a, const char *type) {
  size_t soap_flag_SubscriptionReference = 1;
  size_t soap_flag_CurrentTime = 1;
  size_t soap_flag_TerminationTime = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__SubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__SubscribeResponse, sizeof(struct _ns3__SubscribeResponse), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__SubscribeResponse(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_wsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType")) {
          soap_flag_SubscriptionReference--;
          continue;
        }
      if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "ns3:CurrentTime", &a->CurrentTime, "xsd:dateTime")) {
          soap_flag_CurrentTime--;
          continue;
        }
      if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "ns3:TerminationTime", &a->TerminationTime, "xsd:dateTime")) {
          soap_flag_TerminationTime--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__SubscribeResponse, 0, sizeof(struct _ns3__SubscribeResponse), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__SubscribeResponse(struct soap *soap, const struct _ns3__SubscribeResponse *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__SubscribeResponse);
  if (soap_out__ns3__SubscribeResponse(soap, tag?tag:"ns3:SubscribeResponse", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__SubscribeResponse * SOAP_FMAC4 soap_get__ns3__SubscribeResponse(struct soap *soap, struct _ns3__SubscribeResponse *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__SubscribeResponse(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__Subscribe_SubscriptionPolicy(struct soap *soap, struct _ns3__Subscribe_SubscriptionPolicy *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__Subscribe_SubscriptionPolicy(struct soap *soap, const struct _ns3__Subscribe_SubscriptionPolicy *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _ns3__Subscribe_SubscriptionPolicy *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy), type))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_in__ns3__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _ns3__Subscribe_SubscriptionPolicy *a, const char *type) {
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__Subscribe_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy, sizeof(struct _ns3__Subscribe_SubscriptionPolicy), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__Subscribe_SubscriptionPolicy(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__Subscribe_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy, 0, sizeof(struct _ns3__Subscribe_SubscriptionPolicy), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__Subscribe_SubscriptionPolicy(struct soap *soap, const struct _ns3__Subscribe_SubscriptionPolicy *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy);
  if (soap_out__ns3__Subscribe_SubscriptionPolicy(soap, tag?tag:"ns3:Subscribe-SubscriptionPolicy", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_get__ns3__Subscribe_SubscriptionPolicy(struct soap *soap, struct _ns3__Subscribe_SubscriptionPolicy *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__Subscribe(struct soap *soap, struct _ns3__Subscribe *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
  a->Filter = NULL;
  soap_default_ns3__AbsoluteOrRelativeTimeType(soap, &a->InitialTerminationTime);
  a->SubscriptionPolicy = NULL;
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__Subscribe(struct soap *soap, const struct _ns3__Subscribe *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
  soap_serialize_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
  soap_serialize_PointerTons3__FilterType(soap, &a->Filter);
  soap_serialize_ns3__AbsoluteOrRelativeTimeType(soap, &a->InitialTerminationTime);
  soap_serialize_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Subscribe(struct soap *soap, const char *tag, int id, const struct _ns3__Subscribe *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Subscribe), type))
    return soap->error;
  if (soap_out_wsa5__EndpointReferenceType(soap, "ns3:ConsumerReference", -1, &a->ConsumerReference, ""))
    return soap->error;
  if (soap_out_PointerTons3__FilterType(soap, "ns3:Filter", -1, &a->Filter, ""))
    return soap->error;
  if (soap_out_ns3__AbsoluteOrRelativeTimeType(soap, "ns3:InitialTerminationTime", -1, &a->InitialTerminationTime, ""))
    return soap->error;
  if (soap_out_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, "ns3:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__Subscribe * SOAP_FMAC4 soap_in__ns3__Subscribe(struct soap *soap, const char *tag, struct _ns3__Subscribe *a, const char *type) {
  size_t soap_flag_ConsumerReference = 1;
  size_t soap_flag_Filter = 1;
  size_t soap_flag_InitialTerminationTime = 1;
  size_t soap_flag_SubscriptionPolicy = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__Subscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Subscribe, sizeof(struct _ns3__Subscribe), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__Subscribe(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_wsa5__EndpointReferenceType(soap, "ns3:ConsumerReference", &a->ConsumerReference, "wsa5:EndpointReferenceType")) {
          soap_flag_ConsumerReference--;
          continue;
        }
      if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons3__FilterType(soap, "ns3:Filter", &a->Filter, "ns3:FilterType")) {
          soap_flag_Filter--;
          continue;
        }
      if (soap_flag_InitialTerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_ns3__AbsoluteOrRelativeTimeType(soap, "ns3:InitialTerminationTime", &a->InitialTerminationTime, "ns3:AbsoluteOrRelativeTimeType")) {
          soap_flag_InitialTerminationTime--;
          continue;
        }
      if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, "ns3:SubscriptionPolicy", &a->SubscriptionPolicy, "")) {
          soap_flag_SubscriptionPolicy--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Subscribe, 0, sizeof(struct _ns3__Subscribe), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__Subscribe(struct soap *soap, const struct _ns3__Subscribe *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__Subscribe);
  if (soap_out__ns3__Subscribe(soap, tag?tag:"ns3:Subscribe", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__Subscribe * SOAP_FMAC4 soap_get__ns3__Subscribe(struct soap *soap, struct _ns3__Subscribe *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__Subscribe(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__UseRaw(struct soap *soap, struct _ns3__UseRaw *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__UseRaw(struct soap *soap, const struct _ns3__UseRaw *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UseRaw(struct soap *soap, const char *tag, int id, const struct _ns3__UseRaw *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UseRaw), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__UseRaw * SOAP_FMAC4 soap_in__ns3__UseRaw(struct soap *soap, const char *tag, struct _ns3__UseRaw *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__UseRaw *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UseRaw, sizeof(struct _ns3__UseRaw), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__UseRaw(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__UseRaw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UseRaw, 0, sizeof(struct _ns3__UseRaw), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__UseRaw(struct soap *soap, const struct _ns3__UseRaw *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__UseRaw);
  if (soap_out__ns3__UseRaw(soap, tag?tag:"ns3:UseRaw", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__UseRaw * SOAP_FMAC4 soap_get__ns3__UseRaw(struct soap *soap, struct _ns3__UseRaw *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__UseRaw(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__Notify(struct soap *soap, struct _ns3__Notify *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__sizeNotificationMessage = 0;
  a->NotificationMessage = NULL;
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__Notify(struct soap *soap, const struct _ns3__Notify *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->NotificationMessage) {
    int i;
    for (i = 0; i < a->__sizeNotificationMessage; i++) {
      soap_serialize_PointerTons3__NotificationMessageHolderType(soap, a->NotificationMessage + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Notify(struct soap *soap, const char *tag, int id, const struct _ns3__Notify *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Notify), type))
    return soap->error;
  if (a->NotificationMessage) {
    int i;
    for (i = 0; i < a->__sizeNotificationMessage; i++)
      if (soap_out_PointerTons3__NotificationMessageHolderType(soap, "ns3:NotificationMessage", -1, a->NotificationMessage + i, ""))
        return soap->error;
  }
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__Notify * SOAP_FMAC4 soap_in__ns3__Notify(struct soap *soap, const char *tag, struct _ns3__Notify *a, const char *type) {
  struct soap_blist *soap_blist_NotificationMessage = NULL;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__Notify *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Notify, sizeof(struct _ns3__Notify), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__Notify(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:NotificationMessage", 1, NULL)) {
        if (a->NotificationMessage == NULL) {
          if (soap_blist_NotificationMessage == NULL)
            soap_blist_NotificationMessage = soap_new_block(soap);
          a->NotificationMessage = (struct ns3__NotificationMessageHolderType **)soap_push_block(soap, soap_blist_NotificationMessage, sizeof(struct ns3__NotificationMessageHolderType *));
          if (a->NotificationMessage == NULL)
            return NULL;
          *a->NotificationMessage = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons3__NotificationMessageHolderType(soap, "ns3:NotificationMessage", a->NotificationMessage, "ns3:NotificationMessageHolderType")) {
          a->__sizeNotificationMessage++;
          a->NotificationMessage = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->NotificationMessage)
      soap_pop_block(soap, soap_blist_NotificationMessage);
    if (a->__sizeNotificationMessage)
      a->NotificationMessage = (struct ns3__NotificationMessageHolderType **)soap_save_block(soap, soap_blist_NotificationMessage, NULL, 1);
    else {
      a->NotificationMessage = NULL;
      if (soap_blist_NotificationMessage)
        soap_end_block(soap, soap_blist_NotificationMessage);
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__Notify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Notify, 0, sizeof(struct _ns3__Notify), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNotificationMessage < 1)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__Notify(struct soap *soap, const struct _ns3__Notify *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__Notify);
  if (soap_out__ns3__Notify(soap, tag?tag:"ns3:Notify", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__Notify * SOAP_FMAC4 soap_get__ns3__Notify(struct soap *soap, struct _ns3__Notify *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__Notify(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__SubscriptionManagerRP(struct soap *soap, struct _ns3__SubscriptionManagerRP *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
  a->Filter = NULL;
  a->SubscriptionPolicy = NULL;
  a->CreationTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__SubscriptionManagerRP(struct soap *soap, const struct _ns3__SubscriptionManagerRP *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
  soap_serialize_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
  soap_serialize_PointerTons3__FilterType(soap, &a->Filter);
  soap_serialize_PointerTons3__SubscriptionPolicyType(soap, &a->SubscriptionPolicy);
  soap_serialize_PointerTotime(soap, &a->CreationTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__SubscriptionManagerRP(struct soap *soap, const char *tag, int id, const struct _ns3__SubscriptionManagerRP *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__SubscriptionManagerRP), type))
    return soap->error;
  if (soap_out_wsa5__EndpointReferenceType(soap, "ns3:ConsumerReference", -1, &a->ConsumerReference, ""))
    return soap->error;
  if (soap_out_PointerTons3__FilterType(soap, "ns3:Filter", -1, &a->Filter, ""))
    return soap->error;
  if (soap_out_PointerTons3__SubscriptionPolicyType(soap, "ns3:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
    return soap->error;
  if (soap_out_PointerTotime(soap, "ns3:CreationTime", -1, &a->CreationTime, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__SubscriptionManagerRP * SOAP_FMAC4 soap_in__ns3__SubscriptionManagerRP(struct soap *soap, const char *tag, struct _ns3__SubscriptionManagerRP *a, const char *type) {
  size_t soap_flag_ConsumerReference = 1;
  size_t soap_flag_Filter = 1;
  size_t soap_flag_SubscriptionPolicy = 1;
  size_t soap_flag_CreationTime = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns3__SubscriptionManagerRP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__SubscriptionManagerRP, sizeof(struct _ns3__SubscriptionManagerRP), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns3__SubscriptionManagerRP(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_wsa5__EndpointReferenceType(soap, "ns3:ConsumerReference", &a->ConsumerReference, "wsa5:EndpointReferenceType")) {
          soap_flag_ConsumerReference--;
          continue;
        }
      if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons3__FilterType(soap, "ns3:Filter", &a->Filter, "ns3:FilterType")) {
          soap_flag_Filter--;
          continue;
        }
      if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons3__SubscriptionPolicyType(soap, "ns3:SubscriptionPolicy", &a->SubscriptionPolicy, "ns3:SubscriptionPolicyType")) {
          soap_flag_SubscriptionPolicy--;
          continue;
        }
      if (soap_flag_CreationTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTotime(soap, "ns3:CreationTime", &a->CreationTime, "xsd:dateTime")) {
          soap_flag_CreationTime--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns3__SubscriptionManagerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__SubscriptionManagerRP, 0, sizeof(struct _ns3__SubscriptionManagerRP), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__SubscriptionManagerRP(struct soap *soap, const struct _ns3__SubscriptionManagerRP *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns3__SubscriptionManagerRP);
  if (soap_out__ns3__SubscriptionManagerRP(soap, tag?tag:"ns3:SubscriptionManagerRP", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__SubscriptionManagerRP * SOAP_FMAC4 soap_get__ns3__SubscriptionManagerRP(struct soap *soap, struct _ns3__SubscriptionManagerRP *p, const char *tag, const char *type) {
  if ((p = soap_in__ns3__SubscriptionManagerRP(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__MessageType(struct soap *soap, struct ns3__MessageType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__MessageType(struct soap *soap, const struct ns3__MessageType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__MessageType(struct soap *soap, const char *tag, int id, const struct ns3__MessageType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__MessageType), type))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__MessageType * SOAP_FMAC4 soap_in_ns3__MessageType(struct soap *soap, const char *tag, struct ns3__MessageType *a, const char *type) {
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__MessageType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__MessageType, sizeof(struct ns3__MessageType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__MessageType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__MessageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__MessageType, 0, sizeof(struct ns3__MessageType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__MessageType(struct soap *soap, const struct ns3__MessageType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__MessageType);
  if (soap_out_ns3__MessageType(soap, tag?tag:"ns3:MessageType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__MessageType * SOAP_FMAC4 soap_get_ns3__MessageType(struct soap *soap, struct ns3__MessageType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__MessageType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__NotificationMessageHolderType(struct soap *soap, struct ns3__NotificationMessageHolderType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->SubscriptionReference = NULL;
  a->Topic = NULL;
  a->ProducerReference = NULL;
  a->Message = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__NotificationMessageHolderType(struct soap *soap, const struct ns3__NotificationMessageHolderType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
  soap_serialize_PointerTons3__TopicExpressionType(soap, &a->Topic);
  soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ProducerReference);
  soap_serialize_PointerTons3__MessageType(soap, &a->Message);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const struct ns3__NotificationMessageHolderType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__NotificationMessageHolderType), type))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", -1, &a->SubscriptionReference, ""))
    return soap->error;
  if (soap_out_PointerTons3__TopicExpressionType(soap, "ns3:Topic", -1, &a->Topic, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns3:ProducerReference", -1, &a->ProducerReference, ""))
    return soap->error;
  if (a->Message) {
    if (soap_out_PointerTons3__MessageType(soap, "ns3:Message", -1, &a->Message, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns3:Message"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__NotificationMessageHolderType * SOAP_FMAC4 soap_in_ns3__NotificationMessageHolderType(struct soap *soap, const char *tag, struct ns3__NotificationMessageHolderType *a, const char *type) {
  size_t soap_flag_SubscriptionReference = 1;
  size_t soap_flag_Topic = 1;
  size_t soap_flag_ProducerReference = 1;
  size_t soap_flag_Message = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__NotificationMessageHolderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__NotificationMessageHolderType, sizeof(struct ns3__NotificationMessageHolderType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__NotificationMessageHolderType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns3:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType")) {
          soap_flag_SubscriptionReference--;
          continue;
        }
      if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons3__TopicExpressionType(soap, "ns3:Topic", &a->Topic, "ns3:TopicExpressionType")) {
          soap_flag_Topic--;
          continue;
        }
      if (soap_flag_ProducerReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns3:ProducerReference", &a->ProducerReference, "wsa5:EndpointReferenceType")) {
          soap_flag_ProducerReference--;
          continue;
        }
      if (soap_flag_Message && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons3__MessageType(soap, "ns3:Message", &a->Message, "ns3:MessageType")) {
          soap_flag_Message--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__NotificationMessageHolderType, 0, sizeof(struct ns3__NotificationMessageHolderType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__NotificationMessageHolderType(struct soap *soap, const struct ns3__NotificationMessageHolderType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__NotificationMessageHolderType);
  if (soap_out_ns3__NotificationMessageHolderType(soap, tag?tag:"ns3:NotificationMessageHolderType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__NotificationMessageHolderType * SOAP_FMAC4 soap_get_ns3__NotificationMessageHolderType(struct soap *soap, struct ns3__NotificationMessageHolderType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__NotificationMessageHolderType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__SubscriptionPolicyType(struct soap *soap, struct ns3__SubscriptionPolicyType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__SubscriptionPolicyType(struct soap *soap, const struct ns3__SubscriptionPolicyType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, const struct ns3__SubscriptionPolicyType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__SubscriptionPolicyType), type))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__SubscriptionPolicyType * SOAP_FMAC4 soap_in_ns3__SubscriptionPolicyType(struct soap *soap, const char *tag, struct ns3__SubscriptionPolicyType *a, const char *type) {
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__SubscriptionPolicyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__SubscriptionPolicyType, sizeof(struct ns3__SubscriptionPolicyType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__SubscriptionPolicyType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__SubscriptionPolicyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__SubscriptionPolicyType, 0, sizeof(struct ns3__SubscriptionPolicyType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__SubscriptionPolicyType(struct soap *soap, const struct ns3__SubscriptionPolicyType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__SubscriptionPolicyType);
  if (soap_out_ns3__SubscriptionPolicyType(soap, tag?tag:"ns3:SubscriptionPolicyType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__SubscriptionPolicyType * SOAP_FMAC4 soap_get_ns3__SubscriptionPolicyType(struct soap *soap, struct ns3__SubscriptionPolicyType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__SubscriptionPolicyType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__QueryExpressionType(struct soap *soap, struct ns3__QueryExpressionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_string(soap, &a->Dialect);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__QueryExpressionType(struct soap *soap, const struct ns3__QueryExpressionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__QueryExpressionType(struct soap *soap, const char *tag, int id, const struct ns3__QueryExpressionType *a, const char *type) {
  if (a->Dialect)
    soap_set_attr(soap, "Dialect", a->Dialect, 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns3__QueryExpressionType * SOAP_FMAC4 soap_in_ns3__QueryExpressionType(struct soap *soap, const char *tag, struct ns3__QueryExpressionType *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct ns3__QueryExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__QueryExpressionType, sizeof(struct ns3__QueryExpressionType), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default_ns3__QueryExpressionType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Dialect", 1), &a->Dialect, -1, -1))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, "ns3:QueryExpressionType"))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__QueryExpressionType(struct soap *soap, const struct ns3__QueryExpressionType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__QueryExpressionType);
  if (soap_out_ns3__QueryExpressionType(soap, tag?tag:"ns3:QueryExpressionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__QueryExpressionType * SOAP_FMAC4 soap_get_ns3__QueryExpressionType(struct soap *soap, struct ns3__QueryExpressionType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__QueryExpressionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__TopicExpressionType(struct soap *soap, struct ns3__TopicExpressionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_string(soap, &a->Dialect);
  a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__TopicExpressionType(struct soap *soap, const struct ns3__TopicExpressionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TopicExpressionType(struct soap *soap, const char *tag, int id, const struct ns3__TopicExpressionType *a, const char *type) {
  if (a->Dialect)
    soap_set_attr(soap, "Dialect", a->Dialect, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TopicExpressionType), type))
    return soap->error;
  if (soap_out_string(soap, "-item", -1, &a->__item, ""))
    return soap->error;
  soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__TopicExpressionType * SOAP_FMAC4 soap_in_ns3__TopicExpressionType(struct soap *soap, const char *tag, struct ns3__TopicExpressionType *a, const char *type) {
  size_t soap_flag___item = 1;
  size_t soap_flag___mixed = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__TopicExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TopicExpressionType, sizeof(struct ns3__TopicExpressionType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__TopicExpressionType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Dialect", 1), &a->Dialect, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag___item && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "-item", &a->__item, "xsd:string")) {
          soap_flag___item--;
          continue;
        }
      if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-mixed", &a->__mixed)) {
          soap_flag___mixed--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TopicExpressionType, 0, sizeof(struct ns3__TopicExpressionType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__TopicExpressionType(struct soap *soap, const struct ns3__TopicExpressionType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__TopicExpressionType);
  if (soap_out_ns3__TopicExpressionType(soap, tag?tag:"ns3:TopicExpressionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__TopicExpressionType * SOAP_FMAC4 soap_get_ns3__TopicExpressionType(struct soap *soap, struct ns3__TopicExpressionType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__TopicExpressionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__FilterType(struct soap *soap, struct ns3__FilterType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__sizeTopicExpression = 0;
  a->TopicExpression = NULL;
  a->__sizeProducerProperties = 0;
  a->ProducerProperties = NULL;
  a->__sizeMessageContent = 0;
  a->MessageContent = NULL;
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__FilterType(struct soap *soap, const struct ns3__FilterType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->TopicExpression) {
    int i;
    for (i = 0; i < a->__sizeTopicExpression; i++) {
      soap_serialize_PointerTons3__TopicExpressionType(soap, a->TopicExpression + i);
    }
  }
  if (a->ProducerProperties) {
    int i;
    for (i = 0; i < a->__sizeProducerProperties; i++) {
      soap_serialize_PointerTons3__QueryExpressionType(soap, a->ProducerProperties + i);
    }
  }
  if (a->MessageContent) {
    int i;
    for (i = 0; i < a->__sizeMessageContent; i++) {
      soap_serialize_PointerTons3__QueryExpressionType(soap, a->MessageContent + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FilterType(struct soap *soap, const char *tag, int id, const struct ns3__FilterType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__FilterType), type))
    return soap->error;
  if (a->TopicExpression) {
    int i;
    for (i = 0; i < a->__sizeTopicExpression; i++)
      if (soap_out_PointerTons3__TopicExpressionType(soap, "ns3:TopicExpression", -1, a->TopicExpression + i, ""))
        return soap->error;
  }
  if (a->ProducerProperties) {
    int i;
    for (i = 0; i < a->__sizeProducerProperties; i++)
      if (soap_out_PointerTons3__QueryExpressionType(soap, "ns3:ProducerProperties", -1, a->ProducerProperties + i, ""))
        return soap->error;
  }
  if (a->MessageContent) {
    int i;
    for (i = 0; i < a->__sizeMessageContent; i++)
      if (soap_out_PointerTons3__QueryExpressionType(soap, "ns3:MessageContent", -1, a->MessageContent + i, ""))
        return soap->error;
  }
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__FilterType * SOAP_FMAC4 soap_in_ns3__FilterType(struct soap *soap, const char *tag, struct ns3__FilterType *a, const char *type) {
  struct soap_blist *soap_blist_TopicExpression = NULL;
  struct soap_blist *soap_blist_ProducerProperties = NULL;
  struct soap_blist *soap_blist_MessageContent = NULL;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns3__FilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__FilterType, sizeof(struct ns3__FilterType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns3__FilterType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:TopicExpression", 1, NULL)) {
        if (a->TopicExpression == NULL) {
          if (soap_blist_TopicExpression == NULL)
            soap_blist_TopicExpression = soap_new_block(soap);
          a->TopicExpression = (struct ns3__TopicExpressionType **)soap_push_block(soap, soap_blist_TopicExpression, sizeof(struct ns3__TopicExpressionType *));
          if (a->TopicExpression == NULL)
            return NULL;
          *a->TopicExpression = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons3__TopicExpressionType(soap, "ns3:TopicExpression", a->TopicExpression, "ns3:TopicExpressionType")) {
          a->__sizeTopicExpression++;
          a->TopicExpression = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:ProducerProperties", 1, NULL)) {
        if (a->ProducerProperties == NULL) {
          if (soap_blist_ProducerProperties == NULL)
            soap_blist_ProducerProperties = soap_new_block(soap);
          a->ProducerProperties = (struct ns3__QueryExpressionType **)soap_push_block(soap, soap_blist_ProducerProperties, sizeof(struct ns3__QueryExpressionType *));
          if (a->ProducerProperties == NULL)
            return NULL;
          *a->ProducerProperties = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons3__QueryExpressionType(soap, "ns3:ProducerProperties", a->ProducerProperties, "ns3:QueryExpressionType")) {
          a->__sizeProducerProperties++;
          a->ProducerProperties = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:MessageContent", 1, NULL)) {
        if (a->MessageContent == NULL) {
          if (soap_blist_MessageContent == NULL)
            soap_blist_MessageContent = soap_new_block(soap);
          a->MessageContent = (struct ns3__QueryExpressionType **)soap_push_block(soap, soap_blist_MessageContent, sizeof(struct ns3__QueryExpressionType *));
          if (a->MessageContent == NULL)
            return NULL;
          *a->MessageContent = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons3__QueryExpressionType(soap, "ns3:MessageContent", a->MessageContent, "ns3:QueryExpressionType")) {
          a->__sizeMessageContent++;
          a->MessageContent = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->TopicExpression)
      soap_pop_block(soap, soap_blist_TopicExpression);
    if (a->__sizeTopicExpression)
      a->TopicExpression = (struct ns3__TopicExpressionType **)soap_save_block(soap, soap_blist_TopicExpression, NULL, 1);
    else {
      a->TopicExpression = NULL;
      if (soap_blist_TopicExpression)
        soap_end_block(soap, soap_blist_TopicExpression);
    }
    if (a->ProducerProperties)
      soap_pop_block(soap, soap_blist_ProducerProperties);
    if (a->__sizeProducerProperties)
      a->ProducerProperties = (struct ns3__QueryExpressionType **)soap_save_block(soap, soap_blist_ProducerProperties, NULL, 1);
    else {
      a->ProducerProperties = NULL;
      if (soap_blist_ProducerProperties)
        soap_end_block(soap, soap_blist_ProducerProperties);
    }
    if (a->MessageContent)
      soap_pop_block(soap, soap_blist_MessageContent);
    if (a->__sizeMessageContent)
      a->MessageContent = (struct ns3__QueryExpressionType **)soap_save_block(soap, soap_blist_MessageContent, NULL, 1);
    else {
      a->MessageContent = NULL;
      if (soap_blist_MessageContent)
        soap_end_block(soap, soap_blist_MessageContent);
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns3__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__FilterType, 0, sizeof(struct ns3__FilterType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__FilterType(struct soap *soap, const struct ns3__FilterType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__FilterType);
  if (soap_out_ns3__FilterType(soap, tag?tag:"ns3:FilterType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__FilterType * SOAP_FMAC4 soap_get_ns3__FilterType(struct soap *soap, struct ns3__FilterType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__FilterType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__OSCARSFault(struct soap *soap, struct _ns2__OSCARSFault *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->msg);
  soap_default_string(soap, &a->details);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__OSCARSFault(struct soap *soap, const struct _ns2__OSCARSFault *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->msg);
  soap_serialize_string(soap, &a->details);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__OSCARSFault(struct soap *soap, const char *tag, int id, const struct _ns2__OSCARSFault *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__OSCARSFault), type))
    return soap->error;
  if (a->msg) {
    if (soap_out_string(soap, "ns2:msg", -1, &a->msg, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns2:msg"))
    return soap->error;
  if (a->details) {
    if (soap_out_string(soap, "ns2:details", -1, &a->details, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns2:details"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__OSCARSFault * SOAP_FMAC4 soap_in__ns2__OSCARSFault(struct soap *soap, const char *tag, struct _ns2__OSCARSFault *a, const char *type) {
  size_t soap_flag_msg = 1;
  size_t soap_flag_details = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _ns2__OSCARSFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__OSCARSFault, sizeof(struct _ns2__OSCARSFault), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__ns2__OSCARSFault(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_msg && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns2:msg", &a->msg, "xsd:string")) {
          soap_flag_msg--;
          continue;
        }
      if (soap_flag_details && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns2:details", &a->details, "xsd:string")) {
          soap_flag_details--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _ns2__OSCARSFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__OSCARSFault, 0, sizeof(struct _ns2__OSCARSFault), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_msg > 0 || soap_flag_details > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__OSCARSFault(struct soap *soap, const struct _ns2__OSCARSFault *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__OSCARSFault);
  if (soap_out__ns2__OSCARSFault(soap, tag?tag:"ns2:OSCARSFault", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__OSCARSFault * SOAP_FMAC4 soap_get__ns2__OSCARSFault(struct soap *soap, struct _ns2__OSCARSFault *p, const char *tag, const char *type) {
  if ((p = soap_in__ns2__OSCARSFault(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__emptyArg(struct soap *soap, struct ns2__emptyArg *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->msg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__emptyArg(struct soap *soap, const struct ns2__emptyArg *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->msg);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__emptyArg(struct soap *soap, const char *tag, int id, const struct ns2__emptyArg *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__emptyArg), type))
    return soap->error;
  if (soap_out_string(soap, "ns2:msg", -1, &a->msg, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__emptyArg * SOAP_FMAC4 soap_in_ns2__emptyArg(struct soap *soap, const char *tag, struct ns2__emptyArg *a, const char *type) {
  size_t soap_flag_msg = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns2__emptyArg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__emptyArg, sizeof(struct ns2__emptyArg), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns2__emptyArg(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_msg && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns2:msg", &a->msg, "xsd:string")) {
          soap_flag_msg--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns2__emptyArg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__emptyArg, 0, sizeof(struct ns2__emptyArg), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__emptyArg(struct soap *soap, const struct ns2__emptyArg *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__emptyArg);
  if (soap_out_ns2__emptyArg(soap, tag?tag:"ns2:emptyArg", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__emptyArg * SOAP_FMAC4 soap_get_ns2__emptyArg(struct soap *soap, struct ns2__emptyArg *p, const char *tag, const char *type) {
  if ((p = soap_in_ns2__emptyArg(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__optionalConstraintValue(struct soap *soap, struct ns1__optionalConstraintValue *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__optionalConstraintValue(struct soap *soap, const struct ns1__optionalConstraintValue *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__optionalConstraintValue(struct soap *soap, const char *tag, int id, const struct ns1__optionalConstraintValue *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__optionalConstraintValue), type))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__optionalConstraintValue * SOAP_FMAC4 soap_in_ns1__optionalConstraintValue(struct soap *soap, const char *tag, struct ns1__optionalConstraintValue *a, const char *type) {
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__optionalConstraintValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__optionalConstraintValue, sizeof(struct ns1__optionalConstraintValue), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__optionalConstraintValue(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__optionalConstraintValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__optionalConstraintValue, 0, sizeof(struct ns1__optionalConstraintValue), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__optionalConstraintValue(struct soap *soap, const struct ns1__optionalConstraintValue *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__optionalConstraintValue);
  if (soap_out_ns1__optionalConstraintValue(soap, tag?tag:"ns1:optionalConstraintValue", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__optionalConstraintValue * SOAP_FMAC4 soap_get_ns1__optionalConstraintValue(struct soap *soap, struct ns1__optionalConstraintValue *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__optionalConstraintValue(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__globalReservationId(struct soap *soap, struct ns1__globalReservationId *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->gri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__globalReservationId(struct soap *soap, const struct ns1__globalReservationId *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->gri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__globalReservationId(struct soap *soap, const char *tag, int id, const struct ns1__globalReservationId *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__globalReservationId), type))
    return soap->error;
  if (a->gri) {
    if (soap_out_string(soap, "ns1:gri", -1, &a->gri, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:gri"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__globalReservationId * SOAP_FMAC4 soap_in_ns1__globalReservationId(struct soap *soap, const char *tag, struct ns1__globalReservationId *a, const char *type) {
  size_t soap_flag_gri = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__globalReservationId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__globalReservationId, sizeof(struct ns1__globalReservationId), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__globalReservationId(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_gri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:gri", &a->gri, "xsd:string")) {
          soap_flag_gri--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__globalReservationId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__globalReservationId, 0, sizeof(struct ns1__globalReservationId), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_gri > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__globalReservationId(struct soap *soap, const struct ns1__globalReservationId *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__globalReservationId);
  if (soap_out_ns1__globalReservationId(soap, tag?tag:"ns1:globalReservationId", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__globalReservationId * SOAP_FMAC4 soap_get_ns1__globalReservationId(struct soap *soap, struct ns1__globalReservationId *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__globalReservationId(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__localDetails(struct soap *soap, struct ns1__localDetails *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size = 0;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__localDetails(struct soap *soap, const struct ns1__localDetails *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__localDetails(struct soap *soap, const char *tag, int id, const struct ns1__localDetails *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__localDetails), type))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__localDetails * SOAP_FMAC4 soap_in_ns1__localDetails(struct soap *soap, const char *tag, struct ns1__localDetails *a, const char *type) {
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__localDetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__localDetails, sizeof(struct ns1__localDetails), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__localDetails(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__localDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__localDetails, 0, sizeof(struct ns1__localDetails), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__localDetails(struct soap *soap, const struct ns1__localDetails *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__localDetails);
  if (soap_out_ns1__localDetails(soap, tag?tag:"ns1:localDetails", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__localDetails * SOAP_FMAC4 soap_get_ns1__localDetails(struct soap *soap, struct ns1__localDetails *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__localDetails(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__eventContent(struct soap *soap, struct ns1__eventContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->type);
  soap_default_LONG64(soap, &a->timestamp);
  soap_default_string(soap, &a->errorSource);
  soap_default_string(soap, &a->errorCode);
  soap_default_string(soap, &a->errorMessage);
  a->resDetails = NULL;
  a->localDetails = NULL;
  soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__eventContent(struct soap *soap, const struct ns1__eventContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->type);
  soap_serialize_string(soap, &a->errorSource);
  soap_serialize_string(soap, &a->errorCode);
  soap_serialize_string(soap, &a->errorMessage);
  soap_serialize_PointerTons1__resDetails(soap, &a->resDetails);
  soap_serialize_PointerTons1__localDetails(soap, &a->localDetails);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__eventContent(struct soap *soap, const char *tag, int id, const struct ns1__eventContent *a, const char *type) {
  if (a->id)
    soap_set_attr(soap, "id", a->id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__eventContent), type))
    return soap->error;
  if (a->messageProperties) {
    if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:messageProperties"))
    return soap->error;
  if (a->type) {
    if (soap_out_string(soap, "ns1:type", -1, &a->type, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:type"))
    return soap->error;
  if (soap_out_LONG64(soap, "ns1:timestamp", -1, &a->timestamp, ""))
    return soap->error;
  if (soap_out_string(soap, "ns1:errorSource", -1, &a->errorSource, ""))
    return soap->error;
  if (soap_out_string(soap, "ns1:errorCode", -1, &a->errorCode, ""))
    return soap->error;
  if (soap_out_string(soap, "ns1:errorMessage", -1, &a->errorMessage, ""))
    return soap->error;
  if (soap_out_PointerTons1__resDetails(soap, "ns1:resDetails", -1, &a->resDetails, ""))
    return soap->error;
  if (soap_out_PointerTons1__localDetails(soap, "ns1:localDetails", -1, &a->localDetails, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__eventContent * SOAP_FMAC4 soap_in_ns1__eventContent(struct soap *soap, const char *tag, struct ns1__eventContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_type = 1;
  size_t soap_flag_timestamp = 1;
  size_t soap_flag_errorSource = 1;
  size_t soap_flag_errorCode = 1;
  size_t soap_flag_errorMessage = 1;
  size_t soap_flag_resDetails = 1;
  size_t soap_flag_localDetails = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__eventContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__eventContent, sizeof(struct ns1__eventContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__eventContent(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:type", &a->type, "xsd:string")) {
          soap_flag_type--;
          continue;
        }
      if (soap_flag_timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_LONG64(soap, "ns1:timestamp", &a->timestamp, "xsd:long")) {
          soap_flag_timestamp--;
          continue;
        }
      if (soap_flag_errorSource && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:errorSource", &a->errorSource, "xsd:string")) {
          soap_flag_errorSource--;
          continue;
        }
      if (soap_flag_errorCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:errorCode", &a->errorCode, "xsd:string")) {
          soap_flag_errorCode--;
          continue;
        }
      if (soap_flag_errorMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:errorMessage", &a->errorMessage, "xsd:string")) {
          soap_flag_errorMessage--;
          continue;
        }
      if (soap_flag_resDetails && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__resDetails(soap, "ns1:resDetails", &a->resDetails, "ns1:resDetails")) {
          soap_flag_resDetails--;
          continue;
        }
      if (soap_flag_localDetails && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__localDetails(soap, "ns1:localDetails", &a->localDetails, "ns1:localDetails")) {
          soap_flag_localDetails--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__eventContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__eventContent, 0, sizeof(struct ns1__eventContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_messageProperties > 0 || soap_flag_type > 0 || soap_flag_timestamp > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__eventContent(struct soap *soap, const struct ns1__eventContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__eventContent);
  if (soap_out_ns1__eventContent(soap, tag?tag:"ns1:eventContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__eventContent * SOAP_FMAC4 soap_get_ns1__eventContent(struct soap *soap, struct ns1__eventContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__eventContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__interDomainEventContent(struct soap *soap, struct ns1__interDomainEventContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->type);
  soap_default_string(soap, &a->errorSource);
  soap_default_string(soap, &a->errorCode);
  soap_default_string(soap, &a->errorMessage);
  a->resDetails = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__interDomainEventContent(struct soap *soap, const struct ns1__interDomainEventContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->type);
  soap_serialize_string(soap, &a->errorSource);
  soap_serialize_string(soap, &a->errorCode);
  soap_serialize_string(soap, &a->errorMessage);
  soap_serialize_PointerTons1__resDetails(soap, &a->resDetails);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__interDomainEventContent(struct soap *soap, const char *tag, int id, const struct ns1__interDomainEventContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__interDomainEventContent), type))
    return soap->error;
  if (a->messageProperties) {
    if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:messageProperties"))
    return soap->error;
  if (a->type) {
    if (soap_out_string(soap, "ns1:type", -1, &a->type, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:type"))
    return soap->error;
  if (soap_out_string(soap, "ns1:errorSource", -1, &a->errorSource, ""))
    return soap->error;
  if (soap_out_string(soap, "ns1:errorCode", -1, &a->errorCode, ""))
    return soap->error;
  if (soap_out_string(soap, "ns1:errorMessage", -1, &a->errorMessage, ""))
    return soap->error;
  if (soap_out_PointerTons1__resDetails(soap, "ns1:resDetails", -1, &a->resDetails, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__interDomainEventContent * SOAP_FMAC4 soap_in_ns1__interDomainEventContent(struct soap *soap, const char *tag, struct ns1__interDomainEventContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_type = 1;
  size_t soap_flag_errorSource = 1;
  size_t soap_flag_errorCode = 1;
  size_t soap_flag_errorMessage = 1;
  size_t soap_flag_resDetails = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__interDomainEventContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__interDomainEventContent, sizeof(struct ns1__interDomainEventContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__interDomainEventContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:type", &a->type, "xsd:string")) {
          soap_flag_type--;
          continue;
        }
      if (soap_flag_errorSource && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:errorSource", &a->errorSource, "xsd:string")) {
          soap_flag_errorSource--;
          continue;
        }
      if (soap_flag_errorCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:errorCode", &a->errorCode, "xsd:string")) {
          soap_flag_errorCode--;
          continue;
        }
      if (soap_flag_errorMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:errorMessage", &a->errorMessage, "xsd:string")) {
          soap_flag_errorMessage--;
          continue;
        }
      if (soap_flag_resDetails && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__resDetails(soap, "ns1:resDetails", &a->resDetails, "ns1:resDetails")) {
          soap_flag_resDetails--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__interDomainEventContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__interDomainEventContent, 0, sizeof(struct ns1__interDomainEventContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_messageProperties > 0 || soap_flag_type > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__interDomainEventContent(struct soap *soap, const struct ns1__interDomainEventContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__interDomainEventContent);
  if (soap_out_ns1__interDomainEventContent(soap, tag?tag:"ns1:interDomainEventContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__interDomainEventContent * SOAP_FMAC4 soap_get_ns1__interDomainEventContent(struct soap *soap, struct ns1__interDomainEventContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__interDomainEventContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mplsInfo(struct soap *soap, struct ns1__mplsInfo *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_int(soap, &a->burstLimit);
  soap_default_string(soap, &a->lspClass);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mplsInfo(struct soap *soap, const struct ns1__mplsInfo *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->burstLimit, SOAP_TYPE_int);
  soap_serialize_string(soap, &a->lspClass);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mplsInfo(struct soap *soap, const char *tag, int id, const struct ns1__mplsInfo *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mplsInfo), type))
    return soap->error;
  if (soap_out_int(soap, "ns1:burstLimit", -1, &a->burstLimit, ""))
    return soap->error;
  if (soap_out_string(soap, "ns1:lspClass", -1, &a->lspClass, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mplsInfo * SOAP_FMAC4 soap_in_ns1__mplsInfo(struct soap *soap, const char *tag, struct ns1__mplsInfo *a, const char *type) {
  size_t soap_flag_burstLimit = 1;
  size_t soap_flag_lspClass = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__mplsInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mplsInfo, sizeof(struct ns1__mplsInfo), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__mplsInfo(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_burstLimit && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_int(soap, "ns1:burstLimit", &a->burstLimit, "xsd:int")) {
          soap_flag_burstLimit--;
          continue;
        }
      if (soap_flag_lspClass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:lspClass", &a->lspClass, "xsd:string")) {
          soap_flag_lspClass--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__mplsInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mplsInfo, 0, sizeof(struct ns1__mplsInfo), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_burstLimit > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mplsInfo(struct soap *soap, const struct ns1__mplsInfo *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mplsInfo);
  if (soap_out_ns1__mplsInfo(soap, tag?tag:"ns1:mplsInfo", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mplsInfo * SOAP_FMAC4 soap_get_ns1__mplsInfo(struct soap *soap, struct ns1__mplsInfo *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__mplsInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__layer3Info(struct soap *soap, struct ns1__layer3Info *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->srcHost);
  soap_default_string(soap, &a->destHost);
  soap_default_string(soap, &a->protocol);
  a->srcIpPort = NULL;
  a->destIpPort = NULL;
  soap_default_string(soap, &a->dscp);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__layer3Info(struct soap *soap, const struct ns1__layer3Info *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->srcHost);
  soap_serialize_string(soap, &a->destHost);
  soap_serialize_string(soap, &a->protocol);
  soap_serialize_PointerToint(soap, &a->srcIpPort);
  soap_serialize_PointerToint(soap, &a->destIpPort);
  soap_serialize_string(soap, &a->dscp);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__layer3Info(struct soap *soap, const char *tag, int id, const struct ns1__layer3Info *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__layer3Info), type))
    return soap->error;
  if (a->srcHost) {
    if (soap_out_string(soap, "ns1:srcHost", -1, &a->srcHost, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:srcHost"))
    return soap->error;
  if (a->destHost) {
    if (soap_out_string(soap, "ns1:destHost", -1, &a->destHost, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:destHost"))
    return soap->error;
  if (soap_out_string(soap, "ns1:protocol", -1, &a->protocol, ""))
    return soap->error;
  if (soap_out_PointerToint(soap, "ns1:srcIpPort", -1, &a->srcIpPort, ""))
    return soap->error;
  if (soap_out_PointerToint(soap, "ns1:destIpPort", -1, &a->destIpPort, ""))
    return soap->error;
  if (soap_out_string(soap, "ns1:dscp", -1, &a->dscp, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__layer3Info * SOAP_FMAC4 soap_in_ns1__layer3Info(struct soap *soap, const char *tag, struct ns1__layer3Info *a, const char *type) {
  size_t soap_flag_srcHost = 1;
  size_t soap_flag_destHost = 1;
  size_t soap_flag_protocol = 1;
  size_t soap_flag_srcIpPort = 1;
  size_t soap_flag_destIpPort = 1;
  size_t soap_flag_dscp = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__layer3Info *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__layer3Info, sizeof(struct ns1__layer3Info), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__layer3Info(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_srcHost && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:srcHost", &a->srcHost, "xsd:string")) {
          soap_flag_srcHost--;
          continue;
        }
      if (soap_flag_destHost && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:destHost", &a->destHost, "xsd:string")) {
          soap_flag_destHost--;
          continue;
        }
      if (soap_flag_protocol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:protocol", &a->protocol, "xsd:string")) {
          soap_flag_protocol--;
          continue;
        }
      if (soap_flag_srcIpPort && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToint(soap, "ns1:srcIpPort", &a->srcIpPort, "xsd:int")) {
          soap_flag_srcIpPort--;
          continue;
        }
      if (soap_flag_destIpPort && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToint(soap, "ns1:destIpPort", &a->destIpPort, "xsd:int")) {
          soap_flag_destIpPort--;
          continue;
        }
      if (soap_flag_dscp && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:dscp", &a->dscp, "xsd:string")) {
          soap_flag_dscp--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__layer3Info *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__layer3Info, 0, sizeof(struct ns1__layer3Info), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_srcHost > 0 || soap_flag_destHost > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__layer3Info(struct soap *soap, const struct ns1__layer3Info *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__layer3Info);
  if (soap_out_ns1__layer3Info(soap, tag?tag:"ns1:layer3Info", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__layer3Info * SOAP_FMAC4 soap_get_ns1__layer3Info(struct soap *soap, struct ns1__layer3Info *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__layer3Info(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__layer2Info(struct soap *soap, struct ns1__layer2Info *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->srcVtag = NULL;
  a->destVtag = NULL;
  soap_default_string(soap, &a->srcEndpoint);
  soap_default_string(soap, &a->destEndpoint);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__layer2Info(struct soap *soap, const struct ns1__layer2Info *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__vlanTag(soap, &a->srcVtag);
  soap_serialize_PointerTons1__vlanTag(soap, &a->destVtag);
  soap_serialize_string(soap, &a->srcEndpoint);
  soap_serialize_string(soap, &a->destEndpoint);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__layer2Info(struct soap *soap, const char *tag, int id, const struct ns1__layer2Info *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__layer2Info), type))
    return soap->error;
  if (soap_out_PointerTons1__vlanTag(soap, "ns1:srcVtag", -1, &a->srcVtag, ""))
    return soap->error;
  if (soap_out_PointerTons1__vlanTag(soap, "ns1:destVtag", -1, &a->destVtag, ""))
    return soap->error;
  if (a->srcEndpoint) {
    if (soap_out_string(soap, "ns1:srcEndpoint", -1, &a->srcEndpoint, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:srcEndpoint"))
    return soap->error;
  if (a->destEndpoint) {
    if (soap_out_string(soap, "ns1:destEndpoint", -1, &a->destEndpoint, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:destEndpoint"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__layer2Info * SOAP_FMAC4 soap_in_ns1__layer2Info(struct soap *soap, const char *tag, struct ns1__layer2Info *a, const char *type) {
  size_t soap_flag_srcVtag = 1;
  size_t soap_flag_destVtag = 1;
  size_t soap_flag_srcEndpoint = 1;
  size_t soap_flag_destEndpoint = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__layer2Info *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__layer2Info, sizeof(struct ns1__layer2Info), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__layer2Info(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_srcVtag && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__vlanTag(soap, "ns1:srcVtag", &a->srcVtag, "ns1:vlanTag")) {
          soap_flag_srcVtag--;
          continue;
        }
      if (soap_flag_destVtag && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__vlanTag(soap, "ns1:destVtag", &a->destVtag, "ns1:vlanTag")) {
          soap_flag_destVtag--;
          continue;
        }
      if (soap_flag_srcEndpoint && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:srcEndpoint", &a->srcEndpoint, "xsd:string")) {
          soap_flag_srcEndpoint--;
          continue;
        }
      if (soap_flag_destEndpoint && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:destEndpoint", &a->destEndpoint, "xsd:string")) {
          soap_flag_destEndpoint--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__layer2Info *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__layer2Info, 0, sizeof(struct ns1__layer2Info), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_srcEndpoint > 0 || soap_flag_destEndpoint > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__layer2Info(struct soap *soap, const struct ns1__layer2Info *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__layer2Info);
  if (soap_out_ns1__layer2Info(soap, tag?tag:"ns1:layer2Info", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__layer2Info * SOAP_FMAC4 soap_get_ns1__layer2Info(struct soap *soap, struct ns1__layer2Info *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__layer2Info(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlanePathContent(struct soap *soap, struct ns5__CtrlPlanePathContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->lifetime = NULL;
  a->__sizehop = 0;
  a->hop = NULL;
  soap_default_string(soap, &a->id);
  soap_default_string(soap, &a->direction);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlanePathContent(struct soap *soap, const struct ns5__CtrlPlanePathContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons5__Lifetime(soap, &a->lifetime);
  if (a->hop) {
    int i;
    for (i = 0; i < a->__sizehop; i++) {
      soap_serialize_PointerTons5__CtrlPlaneHopContent(soap, a->hop + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlanePathContent(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlanePathContent *a, const char *type) {
  if (a->id)
    soap_set_attr(soap, "id", a->id, 1);
  if (a->direction)
    soap_set_attr(soap, "direction", a->direction, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CtrlPlanePathContent), type))
    return soap->error;
  if (soap_out_PointerTons5__Lifetime(soap, "ns5:lifetime", -1, &a->lifetime, ""))
    return soap->error;
  if (a->hop) {
    int i;
    for (i = 0; i < a->__sizehop; i++)
      if (soap_out_PointerTons5__CtrlPlaneHopContent(soap, "ns5:hop", -1, a->hop + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__CtrlPlanePathContent * SOAP_FMAC4 soap_in_ns5__CtrlPlanePathContent(struct soap *soap, const char *tag, struct ns5__CtrlPlanePathContent *a, const char *type) {
  size_t soap_flag_lifetime = 1;
  struct soap_blist *soap_blist_hop = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns5__CtrlPlanePathContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlanePathContent, sizeof(struct ns5__CtrlPlanePathContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns5__CtrlPlanePathContent(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "direction", 0), &a->direction, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_lifetime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__Lifetime(soap, "ns5:lifetime", &a->lifetime, "ns5:Lifetime")) {
          soap_flag_lifetime--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:hop", 1, NULL)) {
        if (a->hop == NULL) {
          if (soap_blist_hop == NULL)
            soap_blist_hop = soap_new_block(soap);
          a->hop = (struct ns5__CtrlPlaneHopContent **)soap_push_block(soap, soap_blist_hop, sizeof(struct ns5__CtrlPlaneHopContent *));
          if (a->hop == NULL)
            return NULL;
          *a->hop = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons5__CtrlPlaneHopContent(soap, "ns5:hop", a->hop, "ns5:CtrlPlaneHopContent")) {
          a->__sizehop++;
          a->hop = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->hop)
      soap_pop_block(soap, soap_blist_hop);
    if (a->__sizehop)
      a->hop = (struct ns5__CtrlPlaneHopContent **)soap_save_block(soap, soap_blist_hop, NULL, 1);
    else {
      a->hop = NULL;
      if (soap_blist_hop)
        soap_end_block(soap, soap_blist_hop);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlanePathContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CtrlPlanePathContent, 0, sizeof(struct ns5__CtrlPlanePathContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlanePathContent(struct soap *soap, const struct ns5__CtrlPlanePathContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlanePathContent);
  if (soap_out_ns5__CtrlPlanePathContent(soap, tag?tag:"ns5:CtrlPlanePathContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlanePathContent * SOAP_FMAC4 soap_get_ns5__CtrlPlanePathContent(struct soap *soap, struct ns5__CtrlPlanePathContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlanePathContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__pathInfo(struct soap *soap, struct ns1__pathInfo *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->pathSetupMode);
  soap_default_string(soap, &a->pathType);
  a->path = NULL;
  a->layer2Info = NULL;
  a->layer3Info = NULL;
  a->mplsInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__pathInfo(struct soap *soap, const struct ns1__pathInfo *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->pathSetupMode);
  soap_serialize_string(soap, &a->pathType);
  soap_serialize_PointerTons5__CtrlPlanePathContent(soap, &a->path);
  soap_serialize_PointerTons1__layer2Info(soap, &a->layer2Info);
  soap_serialize_PointerTons1__layer3Info(soap, &a->layer3Info);
  soap_serialize_PointerTons1__mplsInfo(soap, &a->mplsInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__pathInfo(struct soap *soap, const char *tag, int id, const struct ns1__pathInfo *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__pathInfo), type))
    return soap->error;
  if (a->pathSetupMode) {
    if (soap_out_string(soap, "ns1:pathSetupMode", -1, &a->pathSetupMode, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:pathSetupMode"))
    return soap->error;
  if (soap_out_string(soap, "ns1:pathType", -1, &a->pathType, ""))
    return soap->error;
  if (soap_out_PointerTons5__CtrlPlanePathContent(soap, "ns1:path", -1, &a->path, ""))
    return soap->error;
  if (soap_out_PointerTons1__layer2Info(soap, "ns1:layer2Info", -1, &a->layer2Info, ""))
    return soap->error;
  if (soap_out_PointerTons1__layer3Info(soap, "ns1:layer3Info", -1, &a->layer3Info, ""))
    return soap->error;
  if (soap_out_PointerTons1__mplsInfo(soap, "ns1:mplsInfo", -1, &a->mplsInfo, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__pathInfo * SOAP_FMAC4 soap_in_ns1__pathInfo(struct soap *soap, const char *tag, struct ns1__pathInfo *a, const char *type) {
  size_t soap_flag_pathSetupMode = 1;
  size_t soap_flag_pathType = 1;
  size_t soap_flag_path = 1;
  size_t soap_flag_layer2Info = 1;
  size_t soap_flag_layer3Info = 1;
  size_t soap_flag_mplsInfo = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__pathInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__pathInfo, sizeof(struct ns1__pathInfo), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__pathInfo(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_pathSetupMode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:pathSetupMode", &a->pathSetupMode, "xsd:string")) {
          soap_flag_pathSetupMode--;
          continue;
        }
      if (soap_flag_pathType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:pathType", &a->pathType, "xsd:string")) {
          soap_flag_pathType--;
          continue;
        }
      if (soap_flag_path && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__CtrlPlanePathContent(soap, "ns1:path", &a->path, "ns5:CtrlPlanePathContent")) {
          soap_flag_path--;
          continue;
        }
      if (soap_flag_layer2Info && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__layer2Info(soap, "ns1:layer2Info", &a->layer2Info, "ns1:layer2Info")) {
          soap_flag_layer2Info--;
          continue;
        }
      if (soap_flag_layer3Info && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__layer3Info(soap, "ns1:layer3Info", &a->layer3Info, "ns1:layer3Info")) {
          soap_flag_layer3Info--;
          continue;
        }
      if (soap_flag_mplsInfo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__mplsInfo(soap, "ns1:mplsInfo", &a->mplsInfo, "ns1:mplsInfo")) {
          soap_flag_mplsInfo--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__pathInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__pathInfo, 0, sizeof(struct ns1__pathInfo), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathSetupMode > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__pathInfo(struct soap *soap, const struct ns1__pathInfo *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__pathInfo);
  if (soap_out_ns1__pathInfo(soap, tag?tag:"ns1:pathInfo", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__pathInfo * SOAP_FMAC4 soap_get_ns1__pathInfo(struct soap *soap, struct ns1__pathInfo *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__pathInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__listReply(struct soap *soap, struct ns1__listReply *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  a->__sizeresDetails = 0;
  a->resDetails = NULL;
  a->totalResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__listReply(struct soap *soap, const struct ns1__listReply *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  if (a->resDetails) {
    int i;
    for (i = 0; i < a->__sizeresDetails; i++) {
      soap_serialize_PointerTons1__resDetails(soap, a->resDetails + i);
    }
  }
  soap_serialize_PointerToint(soap, &a->totalResults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listReply(struct soap *soap, const char *tag, int id, const struct ns1__listReply *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listReply), type))
    return soap->error;
  if (a->messageProperties)
    soap_element_result(soap, "ns1:messageProperties");
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->resDetails) {
    int i;
    for (i = 0; i < a->__sizeresDetails; i++)
      if (soap_out_PointerTons1__resDetails(soap, "ns1:resDetails", -1, a->resDetails + i, ""))
        return soap->error;
  }
  if (soap_out_PointerToint(soap, "ns1:totalResults", -1, &a->totalResults, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__listReply * SOAP_FMAC4 soap_in_ns1__listReply(struct soap *soap, const char *tag, struct ns1__listReply *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  struct soap_blist *soap_blist_resDetails = NULL;
  size_t soap_flag_totalResults = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__listReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listReply, sizeof(struct ns1__listReply), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__listReply(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:resDetails", 1, NULL)) {
        if (a->resDetails == NULL) {
          if (soap_blist_resDetails == NULL)
            soap_blist_resDetails = soap_new_block(soap);
          a->resDetails = (struct ns1__resDetails **)soap_push_block(soap, soap_blist_resDetails, sizeof(struct ns1__resDetails *));
          if (a->resDetails == NULL)
            return NULL;
          *a->resDetails = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons1__resDetails(soap, "ns1:resDetails", a->resDetails, "ns1:resDetails")) {
          a->__sizeresDetails++;
          a->resDetails = NULL;
          continue;
        }
      }
      if (soap_flag_totalResults && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToint(soap, "ns1:totalResults", &a->totalResults, "xsd:int")) {
          soap_flag_totalResults--;
          continue;
        }
      soap_check_result(soap, "ns1:messageProperties");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->resDetails)
      soap_pop_block(soap, soap_blist_resDetails);
    if (a->__sizeresDetails)
      a->resDetails = (struct ns1__resDetails **)soap_save_block(soap, soap_blist_resDetails, NULL, 1);
    else {
      a->resDetails = NULL;
      if (soap_blist_resDetails)
        soap_end_block(soap, soap_blist_resDetails);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__listReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listReply, 0, sizeof(struct ns1__listReply), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__listReply(struct soap *soap, const struct ns1__listReply *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__listReply);
  if (soap_out_ns1__listReply(soap, tag?tag:"ns1:listReply", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__listReply * SOAP_FMAC4 soap_get_ns1__listReply(struct soap *soap, struct ns1__listReply *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__listReply(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__vlanTag(struct soap *soap, struct ns1__vlanTag *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_xsd__boolean_(soap, &a->tagged);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__vlanTag(struct soap *soap, const struct ns1__vlanTag *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__vlanTag(struct soap *soap, const char *tag, int id, const struct ns1__vlanTag *a, const char *type) {
  soap_set_attr(soap, "tagged", soap_xsd__boolean_2s(soap, a->tagged), 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns1__vlanTag * SOAP_FMAC4 soap_in_ns1__vlanTag(struct soap *soap, const char *tag, struct ns1__vlanTag *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct ns1__vlanTag *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__vlanTag, sizeof(struct ns1__vlanTag), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default_ns1__vlanTag(soap, a);
  if (soap_s2xsd__boolean_(soap, soap_attr_value(soap, "tagged", 0), &a->tagged))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, "ns1:vlanTag"))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__vlanTag(struct soap *soap, const struct ns1__vlanTag *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__vlanTag);
  if (soap_out_ns1__vlanTag(soap, tag?tag:"ns1:vlanTag", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__vlanTag * SOAP_FMAC4 soap_get_ns1__vlanTag(struct soap *soap, struct ns1__vlanTag *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__vlanTag(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listRequest_sequence(struct soap *soap, struct __ns1__listRequest_sequence *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_LONG64(soap, &a->startTime);
  soap_default_LONG64(soap, &a->endTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listRequest_sequence(struct soap *soap, const struct __ns1__listRequest_sequence *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listRequest_sequence(struct soap *soap, const char *tag, int id, const struct __ns1__listRequest_sequence *a, const char *type) {
  if (soap_out_LONG64(soap, "ns1:startTime", -1, &a->startTime, ""))
    return soap->error;
  if (soap_out_LONG64(soap, "ns1:endTime", -1, &a->endTime, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listRequest_sequence * SOAP_FMAC4 soap_in___ns1__listRequest_sequence(struct soap *soap, const char *tag, struct __ns1__listRequest_sequence *a, const char *type) {
  size_t soap_flag_startTime = 1;
  size_t soap_flag_endTime = 1;
  short soap_flag;
  a = (struct __ns1__listRequest_sequence *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listRequest_sequence, sizeof(struct __ns1__listRequest_sequence), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___ns1__listRequest_sequence(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_LONG64(soap, "ns1:startTime", &a->startTime, "xsd:long")) {
        soap_flag_startTime--;
        continue;
      }
    if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_LONG64(soap, "ns1:endTime", &a->endTime, "xsd:long")) {
        soap_flag_endTime--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0 || soap_flag_endTime > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listRequest_sequence(struct soap *soap, const struct __ns1__listRequest_sequence *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___ns1__listRequest_sequence(soap, tag?tag:"-ns1:listRequest-sequence", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listRequest_sequence * SOAP_FMAC4 soap_get___ns1__listRequest_sequence(struct soap *soap, struct __ns1__listRequest_sequence *p, const char *tag, const char *type) {
  if ((p = soap_in___ns1__listRequest_sequence(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__listRequest(struct soap *soap, struct ns1__listRequest *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  a->__sizeresStatus = 0;
  a->resStatus = NULL;
  a->__size_listRequest_sequence = 0;
  a->__listRequest_sequence = NULL;
  soap_default_string(soap, &a->description);
  a->__sizelinkId = 0;
  a->linkId = NULL;
  a->__sizevlanTag = 0;
  a->vlanTag = NULL;
  a->resRequested = NULL;
  a->resOffset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__listRequest(struct soap *soap, const struct ns1__listRequest *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  if (a->resStatus) {
    int i;
    for (i = 0; i < a->__sizeresStatus; i++) {
      soap_serialize_string(soap, a->resStatus + i);
    }
  }
  if (a->__listRequest_sequence) {
    int i;
    for (i = 0; i < a->__size_listRequest_sequence; i++) {
      soap_serialize___ns1__listRequest_sequence(soap, a->__listRequest_sequence + i);
    }
  }
  soap_serialize_string(soap, &a->description);
  if (a->linkId) {
    int i;
    for (i = 0; i < a->__sizelinkId; i++) {
      soap_serialize_string(soap, a->linkId + i);
    }
  }
  if (a->vlanTag) {
    int i;
    for (i = 0; i < a->__sizevlanTag; i++) {
      soap_serialize_PointerTons1__vlanTag(soap, a->vlanTag + i);
    }
  }
  soap_serialize_PointerToint(soap, &a->resRequested);
  soap_serialize_PointerToint(soap, &a->resOffset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listRequest(struct soap *soap, const char *tag, int id, const struct ns1__listRequest *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listRequest), type))
    return soap->error;
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->resStatus) {
    int i;
    for (i = 0; i < a->__sizeresStatus; i++)
      if (soap_out_string(soap, "ns1:resStatus", -1, a->resStatus + i, ""))
        return soap->error;
  }
  if (a->__listRequest_sequence) {
    int i;
    for (i = 0; i < a->__size_listRequest_sequence; i++)
      if (soap_out___ns1__listRequest_sequence(soap, "-listRequest-sequence", -1, a->__listRequest_sequence + i, ""))
        return soap->error;
  }
  if (soap_out_string(soap, "ns1:description", -1, &a->description, ""))
    return soap->error;
  if (a->linkId) {
    int i;
    for (i = 0; i < a->__sizelinkId; i++)
      if (soap_out_string(soap, "ns1:linkId", -1, a->linkId + i, ""))
        return soap->error;
  }
  if (a->vlanTag) {
    int i;
    for (i = 0; i < a->__sizevlanTag; i++)
      if (soap_out_PointerTons1__vlanTag(soap, "ns1:vlanTag", -1, a->vlanTag + i, ""))
        return soap->error;
  }
  if (soap_out_PointerToint(soap, "ns1:resRequested", -1, &a->resRequested, ""))
    return soap->error;
  if (soap_out_PointerToint(soap, "ns1:resOffset", -1, &a->resOffset, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__listRequest * SOAP_FMAC4 soap_in_ns1__listRequest(struct soap *soap, const char *tag, struct ns1__listRequest *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  struct soap_blist *soap_blist_resStatus = NULL;
  struct soap_blist *soap_blist___listRequest_sequence = NULL;
  size_t soap_flag_description = 1;
  struct soap_blist *soap_blist_linkId = NULL;
  struct soap_blist *soap_blist_vlanTag = NULL;
  size_t soap_flag_resRequested = 1;
  size_t soap_flag_resOffset = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__listRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listRequest, sizeof(struct ns1__listRequest), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__listRequest(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:resStatus", 1, NULL)) {
        if (a->resStatus == NULL) {
          if (soap_blist_resStatus == NULL)
            soap_blist_resStatus = soap_new_block(soap);
          a->resStatus = (char **)soap_push_block(soap, soap_blist_resStatus, sizeof(char *));
          if (a->resStatus == NULL)
            return NULL;
          *a->resStatus = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns1:resStatus", a->resStatus, "xsd:string")) {
          a->__sizeresStatus++;
          a->resStatus = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__listRequest_sequence == NULL) {
          if (soap_blist___listRequest_sequence == NULL)
            soap_blist___listRequest_sequence = soap_new_block(soap);
          a->__listRequest_sequence = (struct __ns1__listRequest_sequence *)soap_push_block(soap, soap_blist___listRequest_sequence, sizeof(struct __ns1__listRequest_sequence));
          if (a->__listRequest_sequence == NULL)
            return NULL;
          soap_default___ns1__listRequest_sequence(soap, a->__listRequest_sequence);
        }
        if (soap_in___ns1__listRequest_sequence(soap, "-listRequest-sequence", a->__listRequest_sequence, "-ns1:listRequest-sequence")) {
          a->__size_listRequest_sequence++;
          a->__listRequest_sequence = NULL;
          continue;
        }
      }
      if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:description", &a->description, "xsd:string")) {
          soap_flag_description--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:linkId", 1, NULL)) {
        if (a->linkId == NULL) {
          if (soap_blist_linkId == NULL)
            soap_blist_linkId = soap_new_block(soap);
          a->linkId = (char **)soap_push_block(soap, soap_blist_linkId, sizeof(char *));
          if (a->linkId == NULL)
            return NULL;
          *a->linkId = NULL;
        }
        soap_revert(soap);
        if (soap_in_string(soap, "ns1:linkId", a->linkId, "xsd:string")) {
          a->__sizelinkId++;
          a->linkId = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:vlanTag", 1, NULL)) {
        if (a->vlanTag == NULL) {
          if (soap_blist_vlanTag == NULL)
            soap_blist_vlanTag = soap_new_block(soap);
          a->vlanTag = (struct ns1__vlanTag **)soap_push_block(soap, soap_blist_vlanTag, sizeof(struct ns1__vlanTag *));
          if (a->vlanTag == NULL)
            return NULL;
          *a->vlanTag = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons1__vlanTag(soap, "ns1:vlanTag", a->vlanTag, "ns1:vlanTag")) {
          a->__sizevlanTag++;
          a->vlanTag = NULL;
          continue;
        }
      }
      if (soap_flag_resRequested && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToint(soap, "ns1:resRequested", &a->resRequested, "xsd:int")) {
          soap_flag_resRequested--;
          continue;
        }
      if (soap_flag_resOffset && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToint(soap, "ns1:resOffset", &a->resOffset, "xsd:int")) {
          soap_flag_resOffset--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->resStatus)
      soap_pop_block(soap, soap_blist_resStatus);
    if (a->__sizeresStatus)
      a->resStatus = (char **)soap_save_block(soap, soap_blist_resStatus, NULL, 1);
    else {
      a->resStatus = NULL;
      if (soap_blist_resStatus)
        soap_end_block(soap, soap_blist_resStatus);
    }
    if (a->__listRequest_sequence)
      soap_pop_block(soap, soap_blist___listRequest_sequence);
    if (a->__size_listRequest_sequence)
      a->__listRequest_sequence = (struct __ns1__listRequest_sequence *)soap_save_block(soap, soap_blist___listRequest_sequence, NULL, 1);
    else {
      a->__listRequest_sequence = NULL;
      if (soap_blist___listRequest_sequence)
        soap_end_block(soap, soap_blist___listRequest_sequence);
    }
    if (a->linkId)
      soap_pop_block(soap, soap_blist_linkId);
    if (a->__sizelinkId)
      a->linkId = (char **)soap_save_block(soap, soap_blist_linkId, NULL, 1);
    else {
      a->linkId = NULL;
      if (soap_blist_linkId)
        soap_end_block(soap, soap_blist_linkId);
    }
    if (a->vlanTag)
      soap_pop_block(soap, soap_blist_vlanTag);
    if (a->__sizevlanTag)
      a->vlanTag = (struct ns1__vlanTag **)soap_save_block(soap, soap_blist_vlanTag, NULL, 1);
    else {
      a->vlanTag = NULL;
      if (soap_blist_vlanTag)
        soap_end_block(soap, soap_blist_vlanTag);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__listRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listRequest, 0, sizeof(struct ns1__listRequest), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeresStatus > 5)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__listRequest(struct soap *soap, const struct ns1__listRequest *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__listRequest);
  if (soap_out_ns1__listRequest(soap, tag?tag:"ns1:listRequest", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__listRequest * SOAP_FMAC4 soap_get_ns1__listRequest(struct soap *soap, struct ns1__listRequest *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__listRequest(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__teardownPathResponseContent(struct soap *soap, struct ns1__teardownPathResponseContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->globalReservationId);
  soap_default_string(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__teardownPathResponseContent(struct soap *soap, const struct ns1__teardownPathResponseContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->globalReservationId);
  soap_serialize_string(soap, &a->status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__teardownPathResponseContent(struct soap *soap, const char *tag, int id, const struct ns1__teardownPathResponseContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__teardownPathResponseContent), type))
    return soap->error;
  if (a->messageProperties)
    soap_element_result(soap, "ns1:messageProperties");
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->globalReservationId) {
    if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:globalReservationId"))
    return soap->error;
  if (a->status) {
    if (soap_out_string(soap, "ns1:status", -1, &a->status, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:status"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__teardownPathResponseContent * SOAP_FMAC4 soap_in_ns1__teardownPathResponseContent(struct soap *soap, const char *tag, struct ns1__teardownPathResponseContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_globalReservationId = 1;
  size_t soap_flag_status = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__teardownPathResponseContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__teardownPathResponseContent, sizeof(struct ns1__teardownPathResponseContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__teardownPathResponseContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:status", &a->status, "xsd:string")) {
          soap_flag_status--;
          continue;
        }
      soap_check_result(soap, "ns1:messageProperties");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__teardownPathResponseContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__teardownPathResponseContent, 0, sizeof(struct ns1__teardownPathResponseContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0 || soap_flag_status > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__teardownPathResponseContent(struct soap *soap, const struct ns1__teardownPathResponseContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__teardownPathResponseContent);
  if (soap_out_ns1__teardownPathResponseContent(soap, tag?tag:"ns1:teardownPathResponseContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__teardownPathResponseContent * SOAP_FMAC4 soap_get_ns1__teardownPathResponseContent(struct soap *soap, struct ns1__teardownPathResponseContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__teardownPathResponseContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__teardownPathContent(struct soap *soap, struct ns1__teardownPathContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->token);
  soap_default_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__teardownPathContent(struct soap *soap, const struct ns1__teardownPathContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->token);
  soap_serialize_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__teardownPathContent(struct soap *soap, const char *tag, int id, const struct ns1__teardownPathContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__teardownPathContent), type))
    return soap->error;
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (soap_out_string(soap, "ns1:token", -1, &a->token, ""))
    return soap->error;
  if (a->globalReservationId) {
    if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:globalReservationId"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__teardownPathContent * SOAP_FMAC4 soap_in_ns1__teardownPathContent(struct soap *soap, const char *tag, struct ns1__teardownPathContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_token = 1;
  size_t soap_flag_globalReservationId = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__teardownPathContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__teardownPathContent, sizeof(struct ns1__teardownPathContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__teardownPathContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:token", &a->token, "xsd:string")) {
          soap_flag_token--;
          continue;
        }
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__teardownPathContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__teardownPathContent, 0, sizeof(struct ns1__teardownPathContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__teardownPathContent(struct soap *soap, const struct ns1__teardownPathContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__teardownPathContent);
  if (soap_out_ns1__teardownPathContent(soap, tag?tag:"ns1:teardownPathContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__teardownPathContent * SOAP_FMAC4 soap_get_ns1__teardownPathContent(struct soap *soap, struct ns1__teardownPathContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__teardownPathContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__refreshPathResponseContent(struct soap *soap, struct ns1__refreshPathResponseContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->globalReservationId);
  soap_default_string(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__refreshPathResponseContent(struct soap *soap, const struct ns1__refreshPathResponseContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->globalReservationId);
  soap_serialize_string(soap, &a->status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__refreshPathResponseContent(struct soap *soap, const char *tag, int id, const struct ns1__refreshPathResponseContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__refreshPathResponseContent), type))
    return soap->error;
  if (a->messageProperties)
    soap_element_result(soap, "ns1:messageProperties");
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->globalReservationId) {
    if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:globalReservationId"))
    return soap->error;
  if (a->status) {
    if (soap_out_string(soap, "ns1:status", -1, &a->status, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:status"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__refreshPathResponseContent * SOAP_FMAC4 soap_in_ns1__refreshPathResponseContent(struct soap *soap, const char *tag, struct ns1__refreshPathResponseContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_globalReservationId = 1;
  size_t soap_flag_status = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__refreshPathResponseContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__refreshPathResponseContent, sizeof(struct ns1__refreshPathResponseContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__refreshPathResponseContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:status", &a->status, "xsd:string")) {
          soap_flag_status--;
          continue;
        }
      soap_check_result(soap, "ns1:messageProperties");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__refreshPathResponseContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__refreshPathResponseContent, 0, sizeof(struct ns1__refreshPathResponseContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0 || soap_flag_status > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__refreshPathResponseContent(struct soap *soap, const struct ns1__refreshPathResponseContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__refreshPathResponseContent);
  if (soap_out_ns1__refreshPathResponseContent(soap, tag?tag:"ns1:refreshPathResponseContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__refreshPathResponseContent * SOAP_FMAC4 soap_get_ns1__refreshPathResponseContent(struct soap *soap, struct ns1__refreshPathResponseContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__refreshPathResponseContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__refreshPathContent(struct soap *soap, struct ns1__refreshPathContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->token);
  soap_default_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__refreshPathContent(struct soap *soap, const struct ns1__refreshPathContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->token);
  soap_serialize_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__refreshPathContent(struct soap *soap, const char *tag, int id, const struct ns1__refreshPathContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__refreshPathContent), type))
    return soap->error;
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (soap_out_string(soap, "ns1:token", -1, &a->token, ""))
    return soap->error;
  if (a->globalReservationId) {
    if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:globalReservationId"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__refreshPathContent * SOAP_FMAC4 soap_in_ns1__refreshPathContent(struct soap *soap, const char *tag, struct ns1__refreshPathContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_token = 1;
  size_t soap_flag_globalReservationId = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__refreshPathContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__refreshPathContent, sizeof(struct ns1__refreshPathContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__refreshPathContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:token", &a->token, "xsd:string")) {
          soap_flag_token--;
          continue;
        }
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__refreshPathContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__refreshPathContent, 0, sizeof(struct ns1__refreshPathContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__refreshPathContent(struct soap *soap, const struct ns1__refreshPathContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__refreshPathContent);
  if (soap_out_ns1__refreshPathContent(soap, tag?tag:"ns1:refreshPathContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__refreshPathContent * SOAP_FMAC4 soap_get_ns1__refreshPathContent(struct soap *soap, struct ns1__refreshPathContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__refreshPathContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__createPathResponseContent(struct soap *soap, struct ns1__createPathResponseContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->globalReservationId);
  soap_default_string(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__createPathResponseContent(struct soap *soap, const struct ns1__createPathResponseContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->globalReservationId);
  soap_serialize_string(soap, &a->status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createPathResponseContent(struct soap *soap, const char *tag, int id, const struct ns1__createPathResponseContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createPathResponseContent), type))
    return soap->error;
  if (a->messageProperties)
    soap_element_result(soap, "ns1:messageProperties");
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->globalReservationId) {
    if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:globalReservationId"))
    return soap->error;
  if (a->status) {
    if (soap_out_string(soap, "ns1:status", -1, &a->status, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:status"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__createPathResponseContent * SOAP_FMAC4 soap_in_ns1__createPathResponseContent(struct soap *soap, const char *tag, struct ns1__createPathResponseContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_globalReservationId = 1;
  size_t soap_flag_status = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__createPathResponseContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createPathResponseContent, sizeof(struct ns1__createPathResponseContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__createPathResponseContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:status", &a->status, "xsd:string")) {
          soap_flag_status--;
          continue;
        }
      soap_check_result(soap, "ns1:messageProperties");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__createPathResponseContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createPathResponseContent, 0, sizeof(struct ns1__createPathResponseContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0 || soap_flag_status > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__createPathResponseContent(struct soap *soap, const struct ns1__createPathResponseContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__createPathResponseContent);
  if (soap_out_ns1__createPathResponseContent(soap, tag?tag:"ns1:createPathResponseContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createPathResponseContent * SOAP_FMAC4 soap_get_ns1__createPathResponseContent(struct soap *soap, struct ns1__createPathResponseContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__createPathResponseContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__createPathContent(struct soap *soap, struct ns1__createPathContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->token);
  soap_default_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__createPathContent(struct soap *soap, const struct ns1__createPathContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->token);
  soap_serialize_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createPathContent(struct soap *soap, const char *tag, int id, const struct ns1__createPathContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createPathContent), type))
    return soap->error;
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (soap_out_string(soap, "ns1:token", -1, &a->token, ""))
    return soap->error;
  if (a->globalReservationId) {
    if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:globalReservationId"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__createPathContent * SOAP_FMAC4 soap_in_ns1__createPathContent(struct soap *soap, const char *tag, struct ns1__createPathContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_token = 1;
  size_t soap_flag_globalReservationId = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__createPathContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createPathContent, sizeof(struct ns1__createPathContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__createPathContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:token", &a->token, "xsd:string")) {
          soap_flag_token--;
          continue;
        }
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__createPathContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createPathContent, 0, sizeof(struct ns1__createPathContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__createPathContent(struct soap *soap, const struct ns1__createPathContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__createPathContent);
  if (soap_out_ns1__createPathContent(soap, tag?tag:"ns1:createPathContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createPathContent * SOAP_FMAC4 soap_get_ns1__createPathContent(struct soap *soap, struct ns1__createPathContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__createPathContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__CtrlPlaneTopologyContent(struct soap *soap, struct ns5__CtrlPlaneTopologyContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->idcId);
  a->__sizepath = 0;
  a->path = NULL;
  a->__sizedomain = 0;
  a->domain = NULL;
  a->__sizedomainSignature = 0;
  a->domainSignature = NULL;
  soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__CtrlPlaneTopologyContent(struct soap *soap, const struct ns5__CtrlPlaneTopologyContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->idcId);
  if (a->path) {
    int i;
    for (i = 0; i < a->__sizepath; i++) {
      soap_serialize_PointerTons5__CtrlPlanePathContent(soap, a->path + i);
    }
  }
  if (a->domain) {
    int i;
    for (i = 0; i < a->__sizedomain; i++) {
      soap_serialize_PointerTons5__CtrlPlaneDomainContent(soap, a->domain + i);
    }
  }
  if (a->domainSignature) {
    int i;
    for (i = 0; i < a->__sizedomainSignature; i++) {
      soap_serialize_PointerTons5__CtrlPlaneDomainSignatureContent(soap, a->domainSignature + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CtrlPlaneTopologyContent(struct soap *soap, const char *tag, int id, const struct ns5__CtrlPlaneTopologyContent *a, const char *type) {
  if (a->id)
    soap_set_attr(soap, "id", a->id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CtrlPlaneTopologyContent), type))
    return soap->error;
  if (a->idcId) {
    if (soap_out_string(soap, "ns5:idcId", -1, &a->idcId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns5:idcId"))
    return soap->error;
  if (a->path) {
    int i;
    for (i = 0; i < a->__sizepath; i++)
      if (soap_out_PointerTons5__CtrlPlanePathContent(soap, "ns5:path", -1, a->path + i, ""))
        return soap->error;
  }
  if (a->domain) {
    int i;
    for (i = 0; i < a->__sizedomain; i++)
      if (soap_out_PointerTons5__CtrlPlaneDomainContent(soap, "ns5:domain", -1, a->domain + i, ""))
        return soap->error;
  }
  if (a->domainSignature) {
    int i;
    for (i = 0; i < a->__sizedomainSignature; i++)
      if (soap_out_PointerTons5__CtrlPlaneDomainSignatureContent(soap, "ns5:domainSignature", -1, a->domainSignature + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__CtrlPlaneTopologyContent * SOAP_FMAC4 soap_in_ns5__CtrlPlaneTopologyContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneTopologyContent *a, const char *type) {
  size_t soap_flag_idcId = 1;
  struct soap_blist *soap_blist_path = NULL;
  struct soap_blist *soap_blist_domain = NULL;
  struct soap_blist *soap_blist_domainSignature = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns5__CtrlPlaneTopologyContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CtrlPlaneTopologyContent, sizeof(struct ns5__CtrlPlaneTopologyContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns5__CtrlPlaneTopologyContent(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "id", 1), &a->id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_idcId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns5:idcId", &a->idcId, "xsd:string")) {
          soap_flag_idcId--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:path", 1, NULL)) {
        if (a->path == NULL) {
          if (soap_blist_path == NULL)
            soap_blist_path = soap_new_block(soap);
          a->path = (struct ns5__CtrlPlanePathContent **)soap_push_block(soap, soap_blist_path, sizeof(struct ns5__CtrlPlanePathContent *));
          if (a->path == NULL)
            return NULL;
          *a->path = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons5__CtrlPlanePathContent(soap, "ns5:path", a->path, "ns5:CtrlPlanePathContent")) {
          a->__sizepath++;
          a->path = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:domain", 1, NULL)) {
        if (a->domain == NULL) {
          if (soap_blist_domain == NULL)
            soap_blist_domain = soap_new_block(soap);
          a->domain = (struct ns5__CtrlPlaneDomainContent **)soap_push_block(soap, soap_blist_domain, sizeof(struct ns5__CtrlPlaneDomainContent *));
          if (a->domain == NULL)
            return NULL;
          *a->domain = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons5__CtrlPlaneDomainContent(soap, "ns5:domain", a->domain, "ns5:CtrlPlaneDomainContent")) {
          a->__sizedomain++;
          a->domain = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:domainSignature", 1, NULL)) {
        if (a->domainSignature == NULL) {
          if (soap_blist_domainSignature == NULL)
            soap_blist_domainSignature = soap_new_block(soap);
          a->domainSignature = (struct ns5__CtrlPlaneDomainSignatureContent **)soap_push_block(soap, soap_blist_domainSignature, sizeof(struct ns5__CtrlPlaneDomainSignatureContent *));
          if (a->domainSignature == NULL)
            return NULL;
          *a->domainSignature = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons5__CtrlPlaneDomainSignatureContent(soap, "ns5:domainSignature", a->domainSignature, "ns5:CtrlPlaneDomainSignatureContent")) {
          a->__sizedomainSignature++;
          a->domainSignature = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->path)
      soap_pop_block(soap, soap_blist_path);
    if (a->__sizepath)
      a->path = (struct ns5__CtrlPlanePathContent **)soap_save_block(soap, soap_blist_path, NULL, 1);
    else {
      a->path = NULL;
      if (soap_blist_path)
        soap_end_block(soap, soap_blist_path);
    }
    if (a->domain)
      soap_pop_block(soap, soap_blist_domain);
    if (a->__sizedomain)
      a->domain = (struct ns5__CtrlPlaneDomainContent **)soap_save_block(soap, soap_blist_domain, NULL, 1);
    else {
      a->domain = NULL;
      if (soap_blist_domain)
        soap_end_block(soap, soap_blist_domain);
    }
    if (a->domainSignature)
      soap_pop_block(soap, soap_blist_domainSignature);
    if (a->__sizedomainSignature)
      a->domainSignature = (struct ns5__CtrlPlaneDomainSignatureContent **)soap_save_block(soap, soap_blist_domainSignature, NULL, 1);
    else {
      a->domainSignature = NULL;
      if (soap_blist_domainSignature)
        soap_end_block(soap, soap_blist_domainSignature);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneTopologyContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CtrlPlaneTopologyContent, 0, sizeof(struct ns5__CtrlPlaneTopologyContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idcId > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__CtrlPlaneTopologyContent(struct soap *soap, const struct ns5__CtrlPlaneTopologyContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__CtrlPlaneTopologyContent);
  if (soap_out_ns5__CtrlPlaneTopologyContent(soap, tag?tag:"ns5:CtrlPlaneTopologyContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneTopologyContent * SOAP_FMAC4 soap_get_ns5__CtrlPlaneTopologyContent(struct soap *soap, struct ns5__CtrlPlaneTopologyContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns5__CtrlPlaneTopologyContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTopologyResponseContent(struct soap *soap, struct ns1__getTopologyResponseContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  a->ns5__topology = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTopologyResponseContent(struct soap *soap, const struct ns1__getTopologyResponseContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_PointerTons5__CtrlPlaneTopologyContent(soap, &a->ns5__topology);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTopologyResponseContent(struct soap *soap, const char *tag, int id, const struct ns1__getTopologyResponseContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTopologyResponseContent), type))
    return soap->error;
  if (a->messageProperties)
    soap_element_result(soap, "ns1:messageProperties");
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->ns5__topology) {
    if (soap_out_PointerTons5__CtrlPlaneTopologyContent(soap, "ns5:topology", -1, &a->ns5__topology, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns5:topology"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTopologyResponseContent * SOAP_FMAC4 soap_in_ns1__getTopologyResponseContent(struct soap *soap, const char *tag, struct ns1__getTopologyResponseContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_ns5__topology = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__getTopologyResponseContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTopologyResponseContent, sizeof(struct ns1__getTopologyResponseContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__getTopologyResponseContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_ns5__topology && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons5__CtrlPlaneTopologyContent(soap, "ns5:topology", &a->ns5__topology, "ns5:CtrlPlaneTopologyContent")) {
          soap_flag_ns5__topology--;
          continue;
        }
      soap_check_result(soap, "ns1:messageProperties");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__getTopologyResponseContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTopologyResponseContent, 0, sizeof(struct ns1__getTopologyResponseContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns5__topology > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTopologyResponseContent(struct soap *soap, const struct ns1__getTopologyResponseContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTopologyResponseContent);
  if (soap_out_ns1__getTopologyResponseContent(soap, tag?tag:"ns1:getTopologyResponseContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTopologyResponseContent * SOAP_FMAC4 soap_get_ns1__getTopologyResponseContent(struct soap *soap, struct ns1__getTopologyResponseContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__getTopologyResponseContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTopologyContent(struct soap *soap, struct ns1__getTopologyContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->topologyType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTopologyContent(struct soap *soap, const struct ns1__getTopologyContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->topologyType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTopologyContent(struct soap *soap, const char *tag, int id, const struct ns1__getTopologyContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTopologyContent), type))
    return soap->error;
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->topologyType) {
    if (soap_out_string(soap, "ns1:topologyType", -1, &a->topologyType, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:topologyType"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTopologyContent * SOAP_FMAC4 soap_in_ns1__getTopologyContent(struct soap *soap, const char *tag, struct ns1__getTopologyContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_topologyType = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__getTopologyContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTopologyContent, sizeof(struct ns1__getTopologyContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__getTopologyContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_topologyType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:topologyType", &a->topologyType, "xsd:string")) {
          soap_flag_topologyType--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__getTopologyContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTopologyContent, 0, sizeof(struct ns1__getTopologyContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyType > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTopologyContent(struct soap *soap, const struct ns1__getTopologyContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTopologyContent);
  if (soap_out_ns1__getTopologyContent(soap, tag?tag:"ns1:getTopologyContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTopologyContent * SOAP_FMAC4 soap_get_ns1__getTopologyContent(struct soap *soap, struct ns1__getTopologyContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__getTopologyContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__modifyResReply(struct soap *soap, struct ns1__modifyResReply *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  a->reservation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__modifyResReply(struct soap *soap, const struct ns1__modifyResReply *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_PointerTons1__resDetails(soap, &a->reservation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyResReply(struct soap *soap, const char *tag, int id, const struct ns1__modifyResReply *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifyResReply), type))
    return soap->error;
  if (a->messageProperties)
    soap_element_result(soap, "ns1:messageProperties");
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->reservation) {
    if (soap_out_PointerTons1__resDetails(soap, "ns1:reservation", -1, &a->reservation, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:reservation"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__modifyResReply * SOAP_FMAC4 soap_in_ns1__modifyResReply(struct soap *soap, const char *tag, struct ns1__modifyResReply *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_reservation = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__modifyResReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyResReply, sizeof(struct ns1__modifyResReply), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__modifyResReply(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_reservation && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__resDetails(soap, "ns1:reservation", &a->reservation, "ns1:resDetails")) {
          soap_flag_reservation--;
          continue;
        }
      soap_check_result(soap, "ns1:messageProperties");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__modifyResReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifyResReply, 0, sizeof(struct ns1__modifyResReply), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reservation > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__modifyResReply(struct soap *soap, const struct ns1__modifyResReply *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__modifyResReply);
  if (soap_out_ns1__modifyResReply(soap, tag?tag:"ns1:modifyResReply", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modifyResReply * SOAP_FMAC4 soap_get_ns1__modifyResReply(struct soap *soap, struct ns1__modifyResReply *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__modifyResReply(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__modifyResContent(struct soap *soap, struct ns1__modifyResContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->globalReservationId);
  soap_default_string(soap, &a->description);
  a->userRequestConstraint = NULL;
  a->reservedConstraint = NULL;
  a->__sizeoptionalConstraint = 0;
  a->optionalConstraint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__modifyResContent(struct soap *soap, const struct ns1__modifyResContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->globalReservationId);
  soap_serialize_string(soap, &a->description);
  soap_serialize_PointerTons1__userRequestConstraintType(soap, &a->userRequestConstraint);
  soap_serialize_PointerTons1__reservedConstraintType(soap, &a->reservedConstraint);
  if (a->optionalConstraint) {
    int i;
    for (i = 0; i < a->__sizeoptionalConstraint; i++) {
      soap_serialize_PointerTons1__optionalConstraintType(soap, a->optionalConstraint + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__modifyResContent(struct soap *soap, const char *tag, int id, const struct ns1__modifyResContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__modifyResContent), type))
    return soap->error;
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->globalReservationId) {
    if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:globalReservationId"))
    return soap->error;
  if (a->description) {
    if (soap_out_string(soap, "ns1:description", -1, &a->description, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:description"))
    return soap->error;
  if (a->userRequestConstraint) {
    if (soap_out_PointerTons1__userRequestConstraintType(soap, "ns1:userRequestConstraint", -1, &a->userRequestConstraint, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:userRequestConstraint"))
    return soap->error;
  if (soap_out_PointerTons1__reservedConstraintType(soap, "ns1:reservedConstraint", -1, &a->reservedConstraint, ""))
    return soap->error;
  if (a->optionalConstraint) {
    int i;
    for (i = 0; i < a->__sizeoptionalConstraint; i++)
      if (soap_out_PointerTons1__optionalConstraintType(soap, "ns1:optionalConstraint", -1, a->optionalConstraint + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__modifyResContent * SOAP_FMAC4 soap_in_ns1__modifyResContent(struct soap *soap, const char *tag, struct ns1__modifyResContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_globalReservationId = 1;
  size_t soap_flag_description = 1;
  size_t soap_flag_userRequestConstraint = 1;
  size_t soap_flag_reservedConstraint = 1;
  struct soap_blist *soap_blist_optionalConstraint = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__modifyResContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__modifyResContent, sizeof(struct ns1__modifyResContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__modifyResContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:description", &a->description, "xsd:string")) {
          soap_flag_description--;
          continue;
        }
      if (soap_flag_userRequestConstraint && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__userRequestConstraintType(soap, "ns1:userRequestConstraint", &a->userRequestConstraint, "ns1:userRequestConstraintType")) {
          soap_flag_userRequestConstraint--;
          continue;
        }
      if (soap_flag_reservedConstraint && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__reservedConstraintType(soap, "ns1:reservedConstraint", &a->reservedConstraint, "ns1:reservedConstraintType")) {
          soap_flag_reservedConstraint--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:optionalConstraint", 1, NULL)) {
        if (a->optionalConstraint == NULL) {
          if (soap_blist_optionalConstraint == NULL)
            soap_blist_optionalConstraint = soap_new_block(soap);
          a->optionalConstraint = (struct ns1__optionalConstraintType **)soap_push_block(soap, soap_blist_optionalConstraint, sizeof(struct ns1__optionalConstraintType *));
          if (a->optionalConstraint == NULL)
            return NULL;
          *a->optionalConstraint = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons1__optionalConstraintType(soap, "ns1:optionalConstraint", a->optionalConstraint, "ns1:optionalConstraintType")) {
          a->__sizeoptionalConstraint++;
          a->optionalConstraint = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->optionalConstraint)
      soap_pop_block(soap, soap_blist_optionalConstraint);
    if (a->__sizeoptionalConstraint)
      a->optionalConstraint = (struct ns1__optionalConstraintType **)soap_save_block(soap, soap_blist_optionalConstraint, NULL, 1);
    else {
      a->optionalConstraint = NULL;
      if (soap_blist_optionalConstraint)
        soap_end_block(soap, soap_blist_optionalConstraint);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__modifyResContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__modifyResContent, 0, sizeof(struct ns1__modifyResContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0 || soap_flag_description > 0 || soap_flag_userRequestConstraint > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__modifyResContent(struct soap *soap, const struct ns1__modifyResContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__modifyResContent);
  if (soap_out_ns1__modifyResContent(soap, tag?tag:"ns1:modifyResContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modifyResContent * SOAP_FMAC4 soap_get_ns1__modifyResContent(struct soap *soap, struct ns1__modifyResContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__modifyResContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__resDetails(struct soap *soap, struct ns1__resDetails *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->globalReservationId);
  soap_default_string(soap, &a->login);
  soap_default_string(soap, &a->description);
  soap_default_LONG64(soap, &a->createTime);
  soap_default_string(soap, &a->status);
  a->userRequestConstraint = NULL;
  a->reservedConstraint = NULL;
  a->__sizeoptionalConstraint = 0;
  a->optionalConstraint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__resDetails(struct soap *soap, const struct ns1__resDetails *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->globalReservationId);
  soap_serialize_string(soap, &a->login);
  soap_serialize_string(soap, &a->description);
  soap_serialize_string(soap, &a->status);
  soap_serialize_PointerTons1__userRequestConstraintType(soap, &a->userRequestConstraint);
  soap_serialize_PointerTons1__reservedConstraintType(soap, &a->reservedConstraint);
  if (a->optionalConstraint) {
    int i;
    for (i = 0; i < a->__sizeoptionalConstraint; i++) {
      soap_serialize_PointerTons1__optionalConstraintType(soap, a->optionalConstraint + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__resDetails(struct soap *soap, const char *tag, int id, const struct ns1__resDetails *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__resDetails), type))
    return soap->error;
  if (a->globalReservationId) {
    if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:globalReservationId"))
    return soap->error;
  if (a->login) {
    if (soap_out_string(soap, "ns1:login", -1, &a->login, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:login"))
    return soap->error;
  if (a->description) {
    if (soap_out_string(soap, "ns1:description", -1, &a->description, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:description"))
    return soap->error;
  if (soap_out_LONG64(soap, "ns1:createTime", -1, &a->createTime, ""))
    return soap->error;
  if (a->status) {
    if (soap_out_string(soap, "ns1:status", -1, &a->status, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:status"))
    return soap->error;
  if (a->userRequestConstraint) {
    if (soap_out_PointerTons1__userRequestConstraintType(soap, "ns1:userRequestConstraint", -1, &a->userRequestConstraint, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:userRequestConstraint"))
    return soap->error;
  if (soap_out_PointerTons1__reservedConstraintType(soap, "ns1:reservedConstraint", -1, &a->reservedConstraint, ""))
    return soap->error;
  if (a->optionalConstraint) {
    int i;
    for (i = 0; i < a->__sizeoptionalConstraint; i++)
      if (soap_out_PointerTons1__optionalConstraintType(soap, "ns1:optionalConstraint", -1, a->optionalConstraint + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__resDetails * SOAP_FMAC4 soap_in_ns1__resDetails(struct soap *soap, const char *tag, struct ns1__resDetails *a, const char *type) {
  size_t soap_flag_globalReservationId = 1;
  size_t soap_flag_login = 1;
  size_t soap_flag_description = 1;
  size_t soap_flag_createTime = 1;
  size_t soap_flag_status = 1;
  size_t soap_flag_userRequestConstraint = 1;
  size_t soap_flag_reservedConstraint = 1;
  struct soap_blist *soap_blist_optionalConstraint = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__resDetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__resDetails, sizeof(struct ns1__resDetails), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__resDetails(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:login", &a->login, "xsd:string")) {
          soap_flag_login--;
          continue;
        }
      if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:description", &a->description, "xsd:string")) {
          soap_flag_description--;
          continue;
        }
      if (soap_flag_createTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_LONG64(soap, "ns1:createTime", &a->createTime, "xsd:long")) {
          soap_flag_createTime--;
          continue;
        }
      if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:status", &a->status, "xsd:string")) {
          soap_flag_status--;
          continue;
        }
      if (soap_flag_userRequestConstraint && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__userRequestConstraintType(soap, "ns1:userRequestConstraint", &a->userRequestConstraint, "ns1:userRequestConstraintType")) {
          soap_flag_userRequestConstraint--;
          continue;
        }
      if (soap_flag_reservedConstraint && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__reservedConstraintType(soap, "ns1:reservedConstraint", &a->reservedConstraint, "ns1:reservedConstraintType")) {
          soap_flag_reservedConstraint--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:optionalConstraint", 1, NULL)) {
        if (a->optionalConstraint == NULL) {
          if (soap_blist_optionalConstraint == NULL)
            soap_blist_optionalConstraint = soap_new_block(soap);
          a->optionalConstraint = (struct ns1__optionalConstraintType **)soap_push_block(soap, soap_blist_optionalConstraint, sizeof(struct ns1__optionalConstraintType *));
          if (a->optionalConstraint == NULL)
            return NULL;
          *a->optionalConstraint = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons1__optionalConstraintType(soap, "ns1:optionalConstraint", a->optionalConstraint, "ns1:optionalConstraintType")) {
          a->__sizeoptionalConstraint++;
          a->optionalConstraint = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->optionalConstraint)
      soap_pop_block(soap, soap_blist_optionalConstraint);
    if (a->__sizeoptionalConstraint)
      a->optionalConstraint = (struct ns1__optionalConstraintType **)soap_save_block(soap, soap_blist_optionalConstraint, NULL, 1);
    else {
      a->optionalConstraint = NULL;
      if (soap_blist_optionalConstraint)
        soap_end_block(soap, soap_blist_optionalConstraint);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__resDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__resDetails, 0, sizeof(struct ns1__resDetails), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0 || soap_flag_login > 0 || soap_flag_description > 0 || soap_flag_createTime > 0 || soap_flag_status > 0 || soap_flag_userRequestConstraint > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__resDetails(struct soap *soap, const struct ns1__resDetails *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__resDetails);
  if (soap_out_ns1__resDetails(soap, tag?tag:"ns1:resDetails", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__resDetails * SOAP_FMAC4 soap_get_ns1__resDetails(struct soap *soap, struct ns1__resDetails *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__resDetails(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__queryResReply(struct soap *soap, struct ns1__queryResReply *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  a->reservationDetails = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__queryResReply(struct soap *soap, const struct ns1__queryResReply *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_PointerTons1__resDetails(soap, &a->reservationDetails);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__queryResReply(struct soap *soap, const char *tag, int id, const struct ns1__queryResReply *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__queryResReply), type))
    return soap->error;
  if (a->messageProperties)
    soap_element_result(soap, "ns1:messageProperties");
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->reservationDetails) {
    if (soap_out_PointerTons1__resDetails(soap, "ns1:reservationDetails", -1, &a->reservationDetails, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:reservationDetails"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__queryResReply * SOAP_FMAC4 soap_in_ns1__queryResReply(struct soap *soap, const char *tag, struct ns1__queryResReply *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_reservationDetails = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__queryResReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__queryResReply, sizeof(struct ns1__queryResReply), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__queryResReply(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_reservationDetails && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__resDetails(soap, "ns1:reservationDetails", &a->reservationDetails, "ns1:resDetails")) {
          soap_flag_reservationDetails--;
          continue;
        }
      soap_check_result(soap, "ns1:messageProperties");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__queryResReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__queryResReply, 0, sizeof(struct ns1__queryResReply), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reservationDetails > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__queryResReply(struct soap *soap, const struct ns1__queryResReply *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__queryResReply);
  if (soap_out_ns1__queryResReply(soap, tag?tag:"ns1:queryResReply", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__queryResReply * SOAP_FMAC4 soap_get_ns1__queryResReply(struct soap *soap, struct ns1__queryResReply *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__queryResReply(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__queryResContent(struct soap *soap, struct ns1__queryResContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__queryResContent(struct soap *soap, const struct ns1__queryResContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__queryResContent(struct soap *soap, const char *tag, int id, const struct ns1__queryResContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__queryResContent), type))
    return soap->error;
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->globalReservationId) {
    if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:globalReservationId"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__queryResContent * SOAP_FMAC4 soap_in_ns1__queryResContent(struct soap *soap, const char *tag, struct ns1__queryResContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_globalReservationId = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__queryResContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__queryResContent, sizeof(struct ns1__queryResContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__queryResContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__queryResContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__queryResContent, 0, sizeof(struct ns1__queryResContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__queryResContent(struct soap *soap, const struct ns1__queryResContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__queryResContent);
  if (soap_out_ns1__queryResContent(soap, tag?tag:"ns1:queryResContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__queryResContent * SOAP_FMAC4 soap_get_ns1__queryResContent(struct soap *soap, struct ns1__queryResContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__queryResContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelResReply(struct soap *soap, struct ns1__cancelResReply *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelResReply(struct soap *soap, const struct ns1__cancelResReply *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelResReply(struct soap *soap, const char *tag, int id, const struct ns1__cancelResReply *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelResReply), type))
    return soap->error;
  if (a->messageProperties)
    soap_element_result(soap, "ns1:messageProperties");
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->status) {
    if (soap_out_string(soap, "ns1:status", -1, &a->status, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:status"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelResReply * SOAP_FMAC4 soap_in_ns1__cancelResReply(struct soap *soap, const char *tag, struct ns1__cancelResReply *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_status = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__cancelResReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelResReply, sizeof(struct ns1__cancelResReply), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__cancelResReply(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:status", &a->status, "xsd:string")) {
          soap_flag_status--;
          continue;
        }
      soap_check_result(soap, "ns1:messageProperties");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__cancelResReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelResReply, 0, sizeof(struct ns1__cancelResReply), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelResReply(struct soap *soap, const struct ns1__cancelResReply *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelResReply);
  if (soap_out_ns1__cancelResReply(soap, tag?tag:"ns1:cancelResReply", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelResReply * SOAP_FMAC4 soap_get_ns1__cancelResReply(struct soap *soap, struct ns1__cancelResReply *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__cancelResReply(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelResContent(struct soap *soap, struct ns1__cancelResContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelResContent(struct soap *soap, const struct ns1__cancelResContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->globalReservationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelResContent(struct soap *soap, const char *tag, int id, const struct ns1__cancelResContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelResContent), type))
    return soap->error;
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->globalReservationId) {
    if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:globalReservationId"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelResContent * SOAP_FMAC4 soap_in_ns1__cancelResContent(struct soap *soap, const char *tag, struct ns1__cancelResContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_globalReservationId = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__cancelResContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelResContent, sizeof(struct ns1__cancelResContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__cancelResContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__cancelResContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelResContent, 0, sizeof(struct ns1__cancelResContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelResContent(struct soap *soap, const struct ns1__cancelResContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelResContent);
  if (soap_out_ns1__cancelResContent(soap, tag?tag:"ns1:cancelResContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelResContent * SOAP_FMAC4 soap_get_ns1__cancelResContent(struct soap *soap, struct ns1__cancelResContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__cancelResContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__createReply(struct soap *soap, struct ns1__createReply *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->globalReservationId);
  soap_default_string(soap, &a->token);
  soap_default_string(soap, &a->status);
  a->userRequestConstraint = NULL;
  a->reservedConstraint = NULL;
  a->__sizeoptionalConstraint = 0;
  a->optionalConstraint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__createReply(struct soap *soap, const struct ns1__createReply *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->globalReservationId);
  soap_serialize_string(soap, &a->token);
  soap_serialize_string(soap, &a->status);
  soap_serialize_PointerTons1__userRequestConstraintType(soap, &a->userRequestConstraint);
  soap_serialize_PointerTons1__reservedConstraintType(soap, &a->reservedConstraint);
  if (a->optionalConstraint) {
    int i;
    for (i = 0; i < a->__sizeoptionalConstraint; i++) {
      soap_serialize_PointerTons1__optionalConstraintType(soap, a->optionalConstraint + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createReply(struct soap *soap, const char *tag, int id, const struct ns1__createReply *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createReply), type))
    return soap->error;
  if (a->messageProperties)
    soap_element_result(soap, "ns1:messageProperties");
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (a->globalReservationId) {
    if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:globalReservationId"))
    return soap->error;
  if (soap_out_string(soap, "ns1:token", -1, &a->token, ""))
    return soap->error;
  if (a->status) {
    if (soap_out_string(soap, "ns1:status", -1, &a->status, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:status"))
    return soap->error;
  if (a->userRequestConstraint) {
    if (soap_out_PointerTons1__userRequestConstraintType(soap, "ns1:userRequestConstraint", -1, &a->userRequestConstraint, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:userRequestConstraint"))
    return soap->error;
  if (soap_out_PointerTons1__reservedConstraintType(soap, "ns1:reservedConstraint", -1, &a->reservedConstraint, ""))
    return soap->error;
  if (a->optionalConstraint) {
    int i;
    for (i = 0; i < a->__sizeoptionalConstraint; i++)
      if (soap_out_PointerTons1__optionalConstraintType(soap, "ns1:optionalConstraint", -1, a->optionalConstraint + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__createReply * SOAP_FMAC4 soap_in_ns1__createReply(struct soap *soap, const char *tag, struct ns1__createReply *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_globalReservationId = 1;
  size_t soap_flag_token = 1;
  size_t soap_flag_status = 1;
  size_t soap_flag_userRequestConstraint = 1;
  size_t soap_flag_reservedConstraint = 1;
  struct soap_blist *soap_blist_optionalConstraint = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__createReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createReply, sizeof(struct ns1__createReply), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__createReply(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:token", &a->token, "xsd:string")) {
          soap_flag_token--;
          continue;
        }
      if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:status", &a->status, "xsd:string")) {
          soap_flag_status--;
          continue;
        }
      if (soap_flag_userRequestConstraint && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__userRequestConstraintType(soap, "ns1:userRequestConstraint", &a->userRequestConstraint, "ns1:userRequestConstraintType")) {
          soap_flag_userRequestConstraint--;
          continue;
        }
      if (soap_flag_reservedConstraint && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__reservedConstraintType(soap, "ns1:reservedConstraint", &a->reservedConstraint, "ns1:reservedConstraintType")) {
          soap_flag_reservedConstraint--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:optionalConstraint", 1, NULL)) {
        if (a->optionalConstraint == NULL) {
          if (soap_blist_optionalConstraint == NULL)
            soap_blist_optionalConstraint = soap_new_block(soap);
          a->optionalConstraint = (struct ns1__optionalConstraintType **)soap_push_block(soap, soap_blist_optionalConstraint, sizeof(struct ns1__optionalConstraintType *));
          if (a->optionalConstraint == NULL)
            return NULL;
          *a->optionalConstraint = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons1__optionalConstraintType(soap, "ns1:optionalConstraint", a->optionalConstraint, "ns1:optionalConstraintType")) {
          a->__sizeoptionalConstraint++;
          a->optionalConstraint = NULL;
          continue;
        }
      }
      soap_check_result(soap, "ns1:messageProperties");
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->optionalConstraint)
      soap_pop_block(soap, soap_blist_optionalConstraint);
    if (a->__sizeoptionalConstraint)
      a->optionalConstraint = (struct ns1__optionalConstraintType **)soap_save_block(soap, soap_blist_optionalConstraint, NULL, 1);
    else {
      a->optionalConstraint = NULL;
      if (soap_blist_optionalConstraint)
        soap_end_block(soap, soap_blist_optionalConstraint);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__createReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createReply, 0, sizeof(struct ns1__createReply), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalReservationId > 0 || soap_flag_status > 0 || soap_flag_userRequestConstraint > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__createReply(struct soap *soap, const struct ns1__createReply *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__createReply);
  if (soap_out_ns1__createReply(soap, tag?tag:"ns1:createReply", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createReply * SOAP_FMAC4 soap_get_ns1__createReply(struct soap *soap, struct ns1__createReply *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__createReply(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__optionalConstraintType(struct soap *soap, struct ns1__optionalConstraintType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->value = NULL;
  soap_default_string(soap, &a->category);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__optionalConstraintType(struct soap *soap, const struct ns1__optionalConstraintType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons1__optionalConstraintValue(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__optionalConstraintType(struct soap *soap, const char *tag, int id, const struct ns1__optionalConstraintType *a, const char *type) {
  if (a->category)
    soap_set_attr(soap, "category", a->category, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__optionalConstraintType), type))
    return soap->error;
  if (a->value) {
    if (soap_out_PointerTons1__optionalConstraintValue(soap, "ns1:value", -1, &a->value, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:value"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__optionalConstraintType * SOAP_FMAC4 soap_in_ns1__optionalConstraintType(struct soap *soap, const char *tag, struct ns1__optionalConstraintType *a, const char *type) {
  size_t soap_flag_value = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__optionalConstraintType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__optionalConstraintType, sizeof(struct ns1__optionalConstraintType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__optionalConstraintType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "category", 1), &a->category, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__optionalConstraintValue(soap, "ns1:value", &a->value, "ns1:optionalConstraintValue")) {
          soap_flag_value--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__optionalConstraintType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__optionalConstraintType, 0, sizeof(struct ns1__optionalConstraintType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__optionalConstraintType(struct soap *soap, const struct ns1__optionalConstraintType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__optionalConstraintType);
  if (soap_out_ns1__optionalConstraintType(soap, tag?tag:"ns1:optionalConstraintType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__optionalConstraintType * SOAP_FMAC4 soap_get_ns1__optionalConstraintType(struct soap *soap, struct ns1__optionalConstraintType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__optionalConstraintType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__reservedConstraintType(struct soap *soap, struct ns1__reservedConstraintType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_LONG64(soap, &a->startTime);
  soap_default_LONG64(soap, &a->endTime);
  soap_default_int(soap, &a->bandwidth);
  a->pathInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__reservedConstraintType(struct soap *soap, const struct ns1__reservedConstraintType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->bandwidth, SOAP_TYPE_int);
  soap_serialize_PointerTons1__pathInfo(soap, &a->pathInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__reservedConstraintType(struct soap *soap, const char *tag, int id, const struct ns1__reservedConstraintType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__reservedConstraintType), type))
    return soap->error;
  if (soap_out_LONG64(soap, "ns1:startTime", -1, &a->startTime, ""))
    return soap->error;
  if (soap_out_LONG64(soap, "ns1:endTime", -1, &a->endTime, ""))
    return soap->error;
  if (soap_out_int(soap, "ns1:bandwidth", -1, &a->bandwidth, ""))
    return soap->error;
  if (a->pathInfo) {
    if (soap_out_PointerTons1__pathInfo(soap, "ns1:pathInfo", -1, &a->pathInfo, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:pathInfo"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__reservedConstraintType * SOAP_FMAC4 soap_in_ns1__reservedConstraintType(struct soap *soap, const char *tag, struct ns1__reservedConstraintType *a, const char *type) {
  size_t soap_flag_startTime = 1;
  size_t soap_flag_endTime = 1;
  size_t soap_flag_bandwidth = 1;
  size_t soap_flag_pathInfo = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__reservedConstraintType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__reservedConstraintType, sizeof(struct ns1__reservedConstraintType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__reservedConstraintType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_LONG64(soap, "ns1:startTime", &a->startTime, "xsd:long")) {
          soap_flag_startTime--;
          continue;
        }
      if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_LONG64(soap, "ns1:endTime", &a->endTime, "xsd:long")) {
          soap_flag_endTime--;
          continue;
        }
      if (soap_flag_bandwidth && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_int(soap, "ns1:bandwidth", &a->bandwidth, "xsd:int")) {
          soap_flag_bandwidth--;
          continue;
        }
      if (soap_flag_pathInfo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__pathInfo(soap, "ns1:pathInfo", &a->pathInfo, "ns1:pathInfo")) {
          soap_flag_pathInfo--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__reservedConstraintType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__reservedConstraintType, 0, sizeof(struct ns1__reservedConstraintType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0 || soap_flag_endTime > 0 || soap_flag_bandwidth > 0 || soap_flag_pathInfo > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__reservedConstraintType(struct soap *soap, const struct ns1__reservedConstraintType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__reservedConstraintType);
  if (soap_out_ns1__reservedConstraintType(soap, tag?tag:"ns1:reservedConstraintType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__reservedConstraintType * SOAP_FMAC4 soap_get_ns1__reservedConstraintType(struct soap *soap, struct ns1__reservedConstraintType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__reservedConstraintType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__userRequestConstraintType(struct soap *soap, struct ns1__userRequestConstraintType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_LONG64(soap, &a->startTime);
  soap_default_LONG64(soap, &a->endTime);
  soap_default_int(soap, &a->bandwidth);
  a->pathInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__userRequestConstraintType(struct soap *soap, const struct ns1__userRequestConstraintType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_embedded(soap, &a->bandwidth, SOAP_TYPE_int);
  soap_serialize_PointerTons1__pathInfo(soap, &a->pathInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__userRequestConstraintType(struct soap *soap, const char *tag, int id, const struct ns1__userRequestConstraintType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__userRequestConstraintType), type))
    return soap->error;
  if (soap_out_LONG64(soap, "ns1:startTime", -1, &a->startTime, ""))
    return soap->error;
  if (soap_out_LONG64(soap, "ns1:endTime", -1, &a->endTime, ""))
    return soap->error;
  if (soap_out_int(soap, "ns1:bandwidth", -1, &a->bandwidth, ""))
    return soap->error;
  if (a->pathInfo) {
    if (soap_out_PointerTons1__pathInfo(soap, "ns1:pathInfo", -1, &a->pathInfo, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:pathInfo"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__userRequestConstraintType * SOAP_FMAC4 soap_in_ns1__userRequestConstraintType(struct soap *soap, const char *tag, struct ns1__userRequestConstraintType *a, const char *type) {
  size_t soap_flag_startTime = 1;
  size_t soap_flag_endTime = 1;
  size_t soap_flag_bandwidth = 1;
  size_t soap_flag_pathInfo = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__userRequestConstraintType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__userRequestConstraintType, sizeof(struct ns1__userRequestConstraintType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__userRequestConstraintType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_LONG64(soap, "ns1:startTime", &a->startTime, "xsd:long")) {
          soap_flag_startTime--;
          continue;
        }
      if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_LONG64(soap, "ns1:endTime", &a->endTime, "xsd:long")) {
          soap_flag_endTime--;
          continue;
        }
      if (soap_flag_bandwidth && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_int(soap, "ns1:bandwidth", &a->bandwidth, "xsd:int")) {
          soap_flag_bandwidth--;
          continue;
        }
      if (soap_flag_pathInfo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__pathInfo(soap, "ns1:pathInfo", &a->pathInfo, "ns1:pathInfo")) {
          soap_flag_pathInfo--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__userRequestConstraintType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__userRequestConstraintType, 0, sizeof(struct ns1__userRequestConstraintType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0 || soap_flag_endTime > 0 || soap_flag_bandwidth > 0 || soap_flag_pathInfo > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__userRequestConstraintType(struct soap *soap, const struct ns1__userRequestConstraintType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__userRequestConstraintType);
  if (soap_out_ns1__userRequestConstraintType(soap, tag?tag:"ns1:userRequestConstraintType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__userRequestConstraintType * SOAP_FMAC4 soap_get_ns1__userRequestConstraintType(struct soap *soap, struct ns1__userRequestConstraintType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__userRequestConstraintType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__messagePropertiesType(struct soap *soap, struct ns6__messagePropertiesType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->globalTransactionId);
  a->originator = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__messagePropertiesType(struct soap *soap, const struct ns6__messagePropertiesType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->globalTransactionId);
  soap_serialize_PointerTons6__subjectAttributes(soap, &a->originator);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__messagePropertiesType(struct soap *soap, const char *tag, int id, const struct ns6__messagePropertiesType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__messagePropertiesType), type))
    return soap->error;
  if (a->globalTransactionId) {
    if (soap_out_string(soap, "ns6:globalTransactionId", -1, &a->globalTransactionId, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns6:globalTransactionId"))
    return soap->error;
  if (a->originator) {
    if (soap_out_PointerTons6__subjectAttributes(soap, "ns6:originator", -1, &a->originator, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns6:originator"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__messagePropertiesType * SOAP_FMAC4 soap_in_ns6__messagePropertiesType(struct soap *soap, const char *tag, struct ns6__messagePropertiesType *a, const char *type) {
  size_t soap_flag_globalTransactionId = 1;
  size_t soap_flag_originator = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns6__messagePropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__messagePropertiesType, sizeof(struct ns6__messagePropertiesType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns6__messagePropertiesType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_globalTransactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns6:globalTransactionId", &a->globalTransactionId, "xsd:string")) {
          soap_flag_globalTransactionId--;
          continue;
        }
      if (soap_flag_originator && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__subjectAttributes(soap, "ns6:originator", &a->originator, "ns6:subjectAttributes")) {
          soap_flag_originator--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns6__messagePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__messagePropertiesType, 0, sizeof(struct ns6__messagePropertiesType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_globalTransactionId > 0 || soap_flag_originator > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__messagePropertiesType(struct soap *soap, const struct ns6__messagePropertiesType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__messagePropertiesType);
  if (soap_out_ns6__messagePropertiesType(soap, tag?tag:"ns6:messagePropertiesType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__messagePropertiesType * SOAP_FMAC4 soap_get_ns6__messagePropertiesType(struct soap *soap, struct ns6__messagePropertiesType *p, const char *tag, const char *type) {
  if ((p = soap_in_ns6__messagePropertiesType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__resCreateContent(struct soap *soap, struct ns1__resCreateContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->messageProperties = NULL;
  soap_default_string(soap, &a->globalReservationId);
  soap_default_string(soap, &a->description);
  a->userRequestConstraint = NULL;
  a->reservedConstraint = NULL;
  a->__sizeoptionalConstraint = 0;
  a->optionalConstraint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__resCreateContent(struct soap *soap, const struct ns1__resCreateContent *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTons6__messagePropertiesType(soap, &a->messageProperties);
  soap_serialize_string(soap, &a->globalReservationId);
  soap_serialize_string(soap, &a->description);
  soap_serialize_PointerTons1__userRequestConstraintType(soap, &a->userRequestConstraint);
  soap_serialize_PointerTons1__reservedConstraintType(soap, &a->reservedConstraint);
  if (a->optionalConstraint) {
    int i;
    for (i = 0; i < a->__sizeoptionalConstraint; i++) {
      soap_serialize_PointerTons1__optionalConstraintType(soap, a->optionalConstraint + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__resCreateContent(struct soap *soap, const char *tag, int id, const struct ns1__resCreateContent *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__resCreateContent), type))
    return soap->error;
  if (soap_out_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", -1, &a->messageProperties, ""))
    return soap->error;
  if (soap_out_string(soap, "ns1:globalReservationId", -1, &a->globalReservationId, ""))
    return soap->error;
  if (a->description) {
    if (soap_out_string(soap, "ns1:description", -1, &a->description, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:description"))
    return soap->error;
  if (a->userRequestConstraint) {
    if (soap_out_PointerTons1__userRequestConstraintType(soap, "ns1:userRequestConstraint", -1, &a->userRequestConstraint, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ns1:userRequestConstraint"))
    return soap->error;
  if (soap_out_PointerTons1__reservedConstraintType(soap, "ns1:reservedConstraint", -1, &a->reservedConstraint, ""))
    return soap->error;
  if (a->optionalConstraint) {
    int i;
    for (i = 0; i < a->__sizeoptionalConstraint; i++)
      if (soap_out_PointerTons1__optionalConstraintType(soap, "ns1:optionalConstraint", -1, a->optionalConstraint + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__resCreateContent * SOAP_FMAC4 soap_in_ns1__resCreateContent(struct soap *soap, const char *tag, struct ns1__resCreateContent *a, const char *type) {
  size_t soap_flag_messageProperties = 1;
  size_t soap_flag_globalReservationId = 1;
  size_t soap_flag_description = 1;
  size_t soap_flag_userRequestConstraint = 1;
  size_t soap_flag_reservedConstraint = 1;
  struct soap_blist *soap_blist_optionalConstraint = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ns1__resCreateContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__resCreateContent, sizeof(struct ns1__resCreateContent), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ns1__resCreateContent(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_messageProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons6__messagePropertiesType(soap, "ns1:messageProperties", &a->messageProperties, "ns6:messagePropertiesType")) {
          soap_flag_messageProperties--;
          continue;
        }
      if (soap_flag_globalReservationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:globalReservationId", &a->globalReservationId, "xsd:string")) {
          soap_flag_globalReservationId--;
          continue;
        }
      if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ns1:description", &a->description, "xsd:string")) {
          soap_flag_description--;
          continue;
        }
      if (soap_flag_userRequestConstraint && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__userRequestConstraintType(soap, "ns1:userRequestConstraint", &a->userRequestConstraint, "ns1:userRequestConstraintType")) {
          soap_flag_userRequestConstraint--;
          continue;
        }
      if (soap_flag_reservedConstraint && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTons1__reservedConstraintType(soap, "ns1:reservedConstraint", &a->reservedConstraint, "ns1:reservedConstraintType")) {
          soap_flag_reservedConstraint--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:optionalConstraint", 1, NULL)) {
        if (a->optionalConstraint == NULL) {
          if (soap_blist_optionalConstraint == NULL)
            soap_blist_optionalConstraint = soap_new_block(soap);
          a->optionalConstraint = (struct ns1__optionalConstraintType **)soap_push_block(soap, soap_blist_optionalConstraint, sizeof(struct ns1__optionalConstraintType *));
          if (a->optionalConstraint == NULL)
            return NULL;
          *a->optionalConstraint = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTons1__optionalConstraintType(soap, "ns1:optionalConstraint", a->optionalConstraint, "ns1:optionalConstraintType")) {
          a->__sizeoptionalConstraint++;
          a->optionalConstraint = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->optionalConstraint)
      soap_pop_block(soap, soap_blist_optionalConstraint);
    if (a->__sizeoptionalConstraint)
      a->optionalConstraint = (struct ns1__optionalConstraintType **)soap_save_block(soap, soap_blist_optionalConstraint, NULL, 1);
    else {
      a->optionalConstraint = NULL;
      if (soap_blist_optionalConstraint)
        soap_end_block(soap, soap_blist_optionalConstraint);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ns1__resCreateContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__resCreateContent, 0, sizeof(struct ns1__resCreateContent), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_description > 0 || soap_flag_userRequestConstraint > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__resCreateContent(struct soap *soap, const struct ns1__resCreateContent *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__resCreateContent);
  if (soap_out_ns1__resCreateContent(soap, tag?tag:"ns1:resCreateContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__resCreateContent * SOAP_FMAC4 soap_get_ns1__resCreateContent(struct soap *soap, struct ns1__resCreateContent *p, const char *tag, const char *type) {
  if ((p = soap_in_ns1__resCreateContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->wsu__Timestamp = NULL;
  a->UsernameToken = NULL;
  a->BinarySecurityToken = NULL;
  a->xenc__EncryptedKey = NULL;
  a->xenc__ReferenceList = NULL;
  a->ds__Signature = NULL;
  soap_default_string(soap, &a->SOAP_ENV__actor);
  soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
  soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
  soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
  soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
  soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->xenc__ReferenceList);
  soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type) {
  if (a->SOAP_ENV__actor)
    soap_set_attr(soap, "SOAP-ENV:actor", a->SOAP_ENV__actor, 1);
  if (a->SOAP_ENV__role)
    soap_set_attr(soap, "SOAP-ENV:role", a->SOAP_ENV__role, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
    return soap->error;
  if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
    return soap->error;
  if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
    return soap->error;
  if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
    return soap->error;
  if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
    return soap->error;
  if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->xenc__ReferenceList, ""))
    return soap->error;
  if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type) {
  size_t soap_flag_wsu__Timestamp = 1;
  size_t soap_flag_UsernameToken = 1;
  size_t soap_flag_BinarySecurityToken = 1;
  size_t soap_flag_xenc__EncryptedKey = 1;
  size_t soap_flag_xenc__ReferenceList = 1;
  size_t soap_flag_ds__Signature = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__wsse__Security(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, "")) {
          soap_flag_wsu__Timestamp--;
          continue;
        }
      if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, "")) {
          soap_flag_UsernameToken--;
          continue;
        }
      if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, "")) {
          soap_flag_BinarySecurityToken--;
          continue;
        }
      if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType")) {
          soap_flag_xenc__EncryptedKey--;
          continue;
        }
      if (soap_flag_xenc__ReferenceList && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->xenc__ReferenceList, "")) {
          soap_flag_xenc__ReferenceList--;
          continue;
        }
      if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType")) {
          soap_flag_ds__Signature--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, 0, sizeof(struct _wsse__Security), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Security);
  if (soap_out__wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type) {
  if ((p = soap_in__wsse__Security(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_string(soap, &a->wsu__Id);
  soap_default_string(soap, &a->ValueType);
  soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type) {
  if (a->wsu__Id)
    soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
  if (a->ValueType)
    soap_set_attr(soap, "ValueType", a->ValueType, 1);
  if (a->EncodingType)
    soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default__wsse__KeyIdentifier(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, -1, -1))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, ""))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__KeyIdentifier);
  if (soap_out__wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type) {
  if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->wsu__Id);
  soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type) {
  if (a->wsu__Id)
    soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
  if (a->ValueType)
    soap_set_attr(soap, "ValueType", a->ValueType, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__wsse__Embedded(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, 0, sizeof(struct _wsse__Embedded), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Embedded);
  if (soap_out__wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type) {
  if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->URI);
  soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type) {
  if (a->URI)
    soap_set_attr(soap, "URI", a->URI, 1);
  if (a->ValueType)
    soap_set_attr(soap, "ValueType", a->ValueType, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__wsse__Reference(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, 0, sizeof(struct _wsse__Reference), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Reference);
  if (soap_out__wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type) {
  if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_string(soap, &a->wsu__Id);
  soap_default_string(soap, &a->ValueType);
  soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type) {
  if (a->wsu__Id)
    soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
  if (a->ValueType)
    soap_set_attr(soap, "ValueType", a->ValueType, 1);
  if (a->EncodingType)
    soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default__wsse__BinarySecurityToken(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, -1, -1))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, ""))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__BinarySecurityToken);
  if (soap_out__wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type) {
  if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type) {
  if (a->Type)
    soap_set_attr(soap, "Type", a->Type, 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default__wsse__Password(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, ""))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Password);
  if (soap_out__wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type) {
  if ((p = soap_in__wsse__Password(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->Username);
  a->Password = NULL;
  soap_default_string(soap, &a->Nonce);
  soap_default_string(soap, &a->wsu__Created);
  soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->Username);
  soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
  soap_serialize_string(soap, &a->Nonce);
  soap_serialize_string(soap, &a->wsu__Created);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type) {
  if (a->wsu__Id)
    soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
    return soap->error;
  if (soap_out_string(soap, "wsse:Username", -1, &a->Username, ""))
    return soap->error;
  if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
    return soap->error;
  if (soap_out_string(soap, "wsse:Nonce", -1, &a->Nonce, ""))
    return soap->error;
  if (soap_out_string(soap, "wsu:Created", -1, &a->wsu__Created, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type) {
  size_t soap_flag_Username = 1;
  size_t soap_flag_Password = 1;
  size_t soap_flag_Nonce = 1;
  size_t soap_flag_wsu__Created = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__wsse__UsernameToken(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "wsse:Username", &a->Username, "xsd:string")) {
          soap_flag_Username--;
          continue;
        }
      if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, "")) {
          soap_flag_Password--;
          continue;
        }
      if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "wsse:Nonce", &a->Nonce, "xsd:string")) {
          soap_flag_Nonce--;
          continue;
        }
      if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "wsu:Created", &a->wsu__Created, "xsd:string")) {
          soap_flag_wsu__Created--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, 0, sizeof(struct _wsse__UsernameToken), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__UsernameToken);
  if (soap_out__wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type) {
  if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->wsu__Id);
  soap_default_string(soap, &a->Created);
  soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->Created);
  soap_serialize_string(soap, &a->Expires);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type) {
  if (a->wsu__Id)
    soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
    return soap->error;
  if (soap_out_string(soap, "wsu:Created", -1, &a->Created, ""))
    return soap->error;
  if (soap_out_string(soap, "wsu:Expires", -1, &a->Expires, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type) {
  size_t soap_flag_Created = 1;
  size_t soap_flag_Expires = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__wsu__Timestamp(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "wsu:Created", &a->Created, "xsd:string")) {
          soap_flag_Created--;
          continue;
        }
      if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "wsu:Expires", &a->Expires, "xsd:string")) {
          soap_flag_Expires--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, 0, sizeof(struct _wsu__Timestamp), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsu__Timestamp);
  if (soap_out__wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type) {
  if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
  a->wsa5__RelatesTo = NULL;
  a->wsa5__From = NULL;
  a->wsa5__ReplyTo = NULL;
  a->wsa5__FaultTo = NULL;
  soap_default__wsa5__To(soap, &a->wsa5__To);
  soap_default__wsa5__Action(soap, &a->wsa5__Action);
  a->wsse__Security = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__wsa5__MessageID(soap, &a->wsa5__MessageID);
  soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
  soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
  soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
  soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
  soap_serialize__wsa5__To(soap, &a->wsa5__To);
  soap_serialize__wsa5__Action(soap, &a->wsa5__Action);
  soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
    return soap->error;
  if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, &a->wsa5__MessageID, ""))
    return soap->error;
  if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
    return soap->error;
  if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
    return soap->error;
  soap->mustUnderstand = 1;
  if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
    return soap->error;
  soap->mustUnderstand = 1;
  if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
    return soap->error;
  soap->mustUnderstand = 1;
  if (soap_out__wsa5__To(soap, "wsa5:To", -1, &a->wsa5__To, ""))
    return soap->error;
  soap->mustUnderstand = 1;
  if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, &a->wsa5__Action, ""))
    return soap->error;
  soap->mustUnderstand = 1;
  if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type) {
  size_t soap_flag_wsa5__MessageID = 1;
  size_t soap_flag_wsa5__RelatesTo = 1;
  size_t soap_flag_wsa5__From = 1;
  size_t soap_flag_wsa5__ReplyTo = 1;
  size_t soap_flag_wsa5__FaultTo = 1;
  size_t soap_flag_wsa5__To = 1;
  size_t soap_flag_wsa5__Action = 1;
  size_t soap_flag_wsse__Security = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_SOAP_ENV__Header(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", &a->wsa5__MessageID, "")) {
          soap_flag_wsa5__MessageID--;
          continue;
        }
      if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, "")) {
          soap_flag_wsa5__RelatesTo--;
          continue;
        }
      if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, "")) {
          soap_flag_wsa5__From--;
          continue;
        }
      if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, "")) {
          soap_flag_wsa5__ReplyTo--;
          continue;
        }
      if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, "")) {
          soap_flag_wsa5__FaultTo--;
          continue;
        }
      if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in__wsa5__To(soap, "wsa5:To", &a->wsa5__To, "")) {
          soap_flag_wsa5__To--;
          continue;
        }
      if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in__wsa5__Action(soap, "wsa5:Action", &a->wsa5__Action, "")) {
          soap_flag_wsa5__Action--;
          continue;
        }
      if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, "")) {
          soap_flag_wsse__Security--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
  if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type) {
  if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->Action);
  soap_default_string(soap, &a->SoapAction);
  a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->Action);
  soap_serialize_string(soap, &a->SoapAction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type) {
  if (a->__anyAttribute)
    soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
    return soap->error;
  if (soap_out_string(soap, "wsa5:Action", -1, &a->Action, ""))
    return soap->error;
  if (soap_out_string(soap, "wsa5:SoapAction", -1, &a->SoapAction, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type) {
  size_t soap_flag_Action = 1;
  size_t soap_flag_SoapAction = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct wsa5__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_wsa5__ProblemActionType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "wsa5:Action", &a->Action, "xsd:string")) {
          soap_flag_Action--;
          continue;
        }
      if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "wsa5:SoapAction", &a->SoapAction, "xsd:string")) {
          soap_flag_SoapAction--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, 0, sizeof(struct wsa5__ProblemActionType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ProblemActionType);
  if (soap_out_wsa5__ProblemActionType(soap, tag?tag:"wsa5:ProblemActionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type) {
  if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->__item);
  soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
  a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type) {
  if (a->RelationshipType)
    soap_set_attr(soap, "RelationshipType", a->RelationshipType, 1);
  if (a->__anyAttribute)
    soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
  return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type) {
  (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), 0, NULL, NULL, NULL)))
    return NULL;
  soap_revert(soap);
  *soap->id = '\0';
  soap_default_wsa5__RelatesToType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
    return NULL;
  if (!soap_in_string(soap, tag, &a->__item, "wsa5:RelatesToType"))
    return NULL;
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelatesToType);
  if (soap_out_wsa5__RelatesToType(soap, tag?tag:"wsa5:RelatesToType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type) {
  if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size = 0;
  a->__any = NULL;
  a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type) {
  if (a->__anyAttribute)
    soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type) {
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct wsa5__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_wsa5__MetadataType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, 0, sizeof(struct wsa5__MetadataType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__MetadataType);
  if (soap_out_wsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type) {
  if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size = 0;
  a->__any = NULL;
  a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type) {
  if (a->__anyAttribute)
    soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type) {
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct wsa5__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_wsa5__ReferenceParametersType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, 0, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ReferenceParametersType);
  if (soap_out_wsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type) {
  if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->Address);
  a->ReferenceParameters = NULL;
  a->Metadata = NULL;
  a->__size = 0;
  a->__any = NULL;
  a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->Address);
  soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
  soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type) {
  if (a->__anyAttribute)
    soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
    return soap->error;
  if (a->Address) {
    if (soap_out_string(soap, "wsa5:Address", -1, &a->Address, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "wsa5:Address"))
    return soap->error;
  if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
    return soap->error;
  if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
    return soap->error;
  if (a->__any) {
    int i;
    for (i = 0; i < a->__size; i++)
      soap_outliteral(soap, "-any", a->__any + i, NULL);
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type) {
  size_t soap_flag_Address = 1;
  size_t soap_flag_ReferenceParameters = 1;
  size_t soap_flag_Metadata = 1;
  struct soap_blist *soap_blist___any = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct wsa5__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_wsa5__EndpointReferenceType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "wsa5:Address", &a->Address, "xsd:string")) {
          soap_flag_Address--;
          continue;
        }
      if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType")) {
          soap_flag_ReferenceParameters--;
          continue;
        }
      if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType")) {
          soap_flag_Metadata--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__any == NULL) {
          if (soap_blist___any == NULL)
            soap_blist___any = soap_new_block(soap);
          a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
          if (a->__any == NULL)
            return NULL;
          *a->__any = NULL;
        }
        if (soap_inliteral(soap, "-any", a->__any)) {
          a->__size++;
          a->__any = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__any)
      soap_pop_block(soap, soap_blist___any);
    if (a->__size)
      a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
    else {
      a->__any = NULL;
      if (soap_blist___any)
        soap_end_block(soap, soap_blist___any);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, 0, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__EndpointReferenceType);
  if (soap_out_wsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type) {
  if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->DataReference = NULL;
  a->KeyReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToxenc__ReferenceType(soap, &a->DataReference);
  soap_serialize_PointerToxenc__ReferenceType(soap, &a->KeyReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, const struct __xenc__union_ReferenceList *a, const char *type) {
  if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:DataReference", -1, &a->DataReference, ""))
    return soap->error;
  if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", -1, &a->KeyReference, ""))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_in___xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList *a, const char *type) {
  size_t soap_flag_DataReference = 1;
  size_t soap_flag_KeyReference = 1;
  short soap_flag;
  a = (struct __xenc__union_ReferenceList *)soap_id_enter(soap, "", a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default___xenc__union_ReferenceList(soap, a);
  for (soap_flag = 0;; soap_flag = 1) {
    soap->error = SOAP_TAG_MISMATCH;
    if (soap_flag_DataReference && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:DataReference", &a->DataReference, "xenc:ReferenceType")) {
        soap_flag_DataReference--;
        continue;
      }
    if (soap_flag_KeyReference && soap->error == SOAP_TAG_MISMATCH)
      if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", &a->KeyReference, "xenc:ReferenceType")) {
        soap_flag_KeyReference--;
        continue;
      }
    if (soap->error == SOAP_TAG_MISMATCH)
      if (soap_flag) {
        soap->error = SOAP_OK;
        break;
      }
    if (soap_flag && soap->error == SOAP_NO_TAG)
      break;
    if (soap->error)
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a, const char *tag, const char *type) {
  register int id = 0;
  if (soap_out___xenc__union_ReferenceList(soap, tag?tag:"-xenc:union-ReferenceList", id, a, type))
    return soap->error;
  return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_get___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *p, const char *tag, const char *type) {
  if ((p = soap_in___xenc__union_ReferenceList(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__size_ReferenceList = 0;
  a->__union_ReferenceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->__union_ReferenceList) {
    int i;
    for (i = 0; i < a->__size_ReferenceList; i++) {
      soap_serialize___xenc__union_ReferenceList(soap, a->__union_ReferenceList + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xenc__ReferenceList(struct soap *soap, const char *tag, int id, const struct _xenc__ReferenceList *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xenc__ReferenceList), type))
    return soap->error;
  if (a->__union_ReferenceList) {
    int i;
    for (i = 0; i < a->__size_ReferenceList; i++)
      if (soap_out___xenc__union_ReferenceList(soap, "-union-ReferenceList", -1, a->__union_ReferenceList + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_in__xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList *a, const char *type) {
  struct soap_blist *soap_blist___union_ReferenceList = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _xenc__ReferenceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__xenc__ReferenceList(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap)) {
        if (a->__union_ReferenceList == NULL) {
          if (soap_blist___union_ReferenceList == NULL)
            soap_blist___union_ReferenceList = soap_new_block(soap);
          a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_push_block(soap, soap_blist___union_ReferenceList, sizeof(struct __xenc__union_ReferenceList));
          if (a->__union_ReferenceList == NULL)
            return NULL;
          soap_default___xenc__union_ReferenceList(soap, a->__union_ReferenceList);
        }
        if (soap_in___xenc__union_ReferenceList(soap, "-union-ReferenceList", a->__union_ReferenceList, "-xenc:union-ReferenceList")) {
          a->__size_ReferenceList++;
          a->__union_ReferenceList = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->__union_ReferenceList)
      soap_pop_block(soap, soap_blist___union_ReferenceList);
    if (a->__size_ReferenceList)
      a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_save_block(soap, soap_blist___union_ReferenceList, NULL, 1);
    else {
      a->__union_ReferenceList = NULL;
      if (soap_blist___union_ReferenceList)
        soap_end_block(soap, soap_blist___union_ReferenceList);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _xenc__ReferenceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xenc__ReferenceList, 0, sizeof(struct _xenc__ReferenceList), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (a->__size_ReferenceList < 1)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__xenc__ReferenceList);
  if (soap_out__xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_get__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *p, const char *tag, const char *type) {
  if ((p = soap_in__xenc__ReferenceList(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->Target);
  soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertyType *a, const char *type) {
  if (a->Target)
    soap_set_attr(soap, "Target", a->Target, 1);
  if (a->Id)
    soap_set_attr(soap, "Id", a->Id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertyType), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct xenc__EncryptionPropertyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_xenc__EncryptionPropertyType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Target", 0), &a->Target, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct xenc__EncryptionPropertyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertyType, 0, sizeof(struct xenc__EncryptionPropertyType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionPropertyType);
  if (soap_out_xenc__EncryptionPropertyType(soap, tag?tag:"xenc:EncryptionPropertyType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *p, const char *tag, const char *type) {
  if ((p = soap_in_xenc__EncryptionPropertyType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__sizeEncryptionProperty = 0;
  a->EncryptionProperty = NULL;
  soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->EncryptionProperty) {
    int i;
    for (i = 0; i < a->__sizeEncryptionProperty; i++) {
      soap_embedded(soap, a->EncryptionProperty + i, SOAP_TYPE_xenc__EncryptionPropertyType);
      soap_serialize_xenc__EncryptionPropertyType(soap, a->EncryptionProperty + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertiesType *a, const char *type) {
  if (a->Id)
    soap_set_attr(soap, "Id", a->Id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertiesType), type))
    return soap->error;
  if (a->EncryptionProperty) {
    int i;
    for (i = 0; i < a->__sizeEncryptionProperty; i++)
      if (soap_out_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", -1, a->EncryptionProperty + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType *a, const char *type) {
  struct soap_blist *soap_blist_EncryptionProperty = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct xenc__EncryptionPropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_xenc__EncryptionPropertiesType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptionProperty", 1, NULL)) {
        if (a->EncryptionProperty == NULL) {
          if (soap_blist_EncryptionProperty == NULL)
            soap_blist_EncryptionProperty = soap_new_block(soap);
          a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_push_block(soap, soap_blist_EncryptionProperty, sizeof(struct xenc__EncryptionPropertyType));
          if (a->EncryptionProperty == NULL)
            return NULL;
          soap_default_xenc__EncryptionPropertyType(soap, a->EncryptionProperty);
        }
        soap_revert(soap);
        if (soap_in_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", a->EncryptionProperty, "xenc:EncryptionPropertyType")) {
          a->__sizeEncryptionProperty++;
          a->EncryptionProperty = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->EncryptionProperty)
      soap_pop_block(soap, soap_blist_EncryptionProperty);
    if (a->__sizeEncryptionProperty)
      a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_save_block(soap, soap_blist_EncryptionProperty, NULL, 1);
    else {
      a->EncryptionProperty = NULL;
      if (soap_blist_EncryptionProperty)
        soap_end_block(soap, soap_blist_EncryptionProperty);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct xenc__EncryptionPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertiesType, 0, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEncryptionProperty < 1)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionPropertiesType);
  if (soap_out_xenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *p, const char *tag, const char *type) {
  if ((p = soap_in_xenc__EncryptionPropertiesType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__ReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__ReferenceType *a, const char *type) {
  if (a->URI)
    soap_set_attr(soap, "URI", a->URI, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__ReferenceType), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_in_xenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct xenc__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_xenc__ReferenceType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct xenc__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__ReferenceType, 0, sizeof(struct xenc__ReferenceType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__ReferenceType);
  if (soap_out_xenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_get_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *p, const char *tag, const char *type) {
  if ((p = soap_in_xenc__ReferenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->KA_Nonce);
  a->OriginatorKeyInfo = NULL;
  a->RecipientKeyInfo = NULL;
  soap_default_string(soap, &a->Algorithm);
  a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->KA_Nonce);
  soap_serialize_PointerTods__KeyInfoType(soap, &a->OriginatorKeyInfo);
  soap_serialize_PointerTods__KeyInfoType(soap, &a->RecipientKeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__AgreementMethodType(struct soap *soap, const char *tag, int id, const struct xenc__AgreementMethodType *a, const char *type) {
  if (a->Algorithm)
    soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__AgreementMethodType), type))
    return soap->error;
  if (soap_out_string(soap, "xenc:KA-Nonce", -1, &a->KA_Nonce, ""))
    return soap->error;
  if (soap_out_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", -1, &a->OriginatorKeyInfo, ""))
    return soap->error;
  if (soap_out_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", -1, &a->RecipientKeyInfo, ""))
    return soap->error;
  soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_in_xenc__AgreementMethodType(struct soap *soap, const char *tag, struct xenc__AgreementMethodType *a, const char *type) {
  size_t soap_flag_KA_Nonce = 1;
  size_t soap_flag_OriginatorKeyInfo = 1;
  size_t soap_flag_RecipientKeyInfo = 1;
  size_t soap_flag___mixed = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct xenc__AgreementMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_xenc__AgreementMethodType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_KA_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "xenc:KA-Nonce", &a->KA_Nonce, "xsd:string")) {
          soap_flag_KA_Nonce--;
          continue;
        }
      if (soap_flag_OriginatorKeyInfo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", &a->OriginatorKeyInfo, "ds:KeyInfoType")) {
          soap_flag_OriginatorKeyInfo--;
          continue;
        }
      if (soap_flag_RecipientKeyInfo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", &a->RecipientKeyInfo, "ds:KeyInfoType")) {
          soap_flag_RecipientKeyInfo--;
          continue;
        }
      if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-mixed", &a->__mixed)) {
          soap_flag___mixed--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct xenc__AgreementMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__AgreementMethodType, 0, sizeof(struct xenc__AgreementMethodType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__AgreementMethodType);
  if (soap_out_xenc__AgreementMethodType(soap, tag?tag:"xenc:AgreementMethodType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_get_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *p, const char *tag, const char *type) {
  if ((p = soap_in_xenc__AgreementMethodType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->EncryptionMethod = NULL;
  a->ds__KeyInfo = NULL;
  a->CipherData = NULL;
  a->EncryptionProperties = NULL;
  soap_default_string(soap, &a->Id);
  soap_default_string(soap, &a->Type);
  soap_default_string(soap, &a->MimeType);
  soap_default_string(soap, &a->Encoding);
  a->ReferenceList = NULL;
  soap_default_string(soap, &a->CarriedKeyName);
  soap_default_string(soap, &a->Recipient);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
  soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
  soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
  soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
  soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->ReferenceList);
  soap_serialize_string(soap, &a->CarriedKeyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedKeyType *a, const char *type) {
  if (a->Id)
    soap_set_attr(soap, "Id", a->Id, 1);
  if (a->Type)
    soap_set_attr(soap, "Type", a->Type, 1);
  if (a->MimeType)
    soap_set_attr(soap, "MimeType", a->MimeType, 1);
  if (a->Encoding)
    soap_set_attr(soap, "Encoding", a->Encoding, 1);
  if (a->Recipient)
    soap_set_attr(soap, "Recipient", a->Recipient, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedKeyType), type))
    return soap->error;
  if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
    return soap->error;
  if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
    return soap->error;
  if (a->CipherData) {
    if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "xenc:CipherData"))
    return soap->error;
  if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
    return soap->error;
  if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->ReferenceList, ""))
    return soap->error;
  if (soap_out_string(soap, "xenc:CarriedKeyName", -1, &a->CarriedKeyName, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_in_xenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType *a, const char *type) {
  size_t soap_flag_EncryptionMethod = 1;
  size_t soap_flag_ds__KeyInfo = 1;
  size_t soap_flag_CipherData = 1;
  size_t soap_flag_EncryptionProperties = 1;
  size_t soap_flag_ReferenceList = 1;
  size_t soap_flag_CarriedKeyName = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct xenc__EncryptedKeyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_xenc__EncryptedKeyType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 0), &a->Recipient, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType")) {
          soap_flag_EncryptionMethod--;
          continue;
        }
      if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, "")) {
          soap_flag_ds__KeyInfo--;
          continue;
        }
      if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType")) {
          soap_flag_CipherData--;
          continue;
        }
      if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType")) {
          soap_flag_EncryptionProperties--;
          continue;
        }
      if (soap_flag_ReferenceList && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->ReferenceList, "")) {
          soap_flag_ReferenceList--;
          continue;
        }
      if (soap_flag_CarriedKeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "xenc:CarriedKeyName", &a->CarriedKeyName, "xsd:string")) {
          soap_flag_CarriedKeyName--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct xenc__EncryptedKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedKeyType, 0, sizeof(struct xenc__EncryptedKeyType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedKeyType);
  if (soap_out_xenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_get_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *p, const char *tag, const char *type) {
  if ((p = soap_in_xenc__EncryptedKeyType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->EncryptionMethod = NULL;
  a->ds__KeyInfo = NULL;
  a->CipherData = NULL;
  a->EncryptionProperties = NULL;
  soap_default_string(soap, &a->Id);
  soap_default_string(soap, &a->Type);
  soap_default_string(soap, &a->MimeType);
  soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
  soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
  soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
  soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedDataType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedDataType *a, const char *type) {
  if (a->Id)
    soap_set_attr(soap, "Id", a->Id, 1);
  if (a->Type)
    soap_set_attr(soap, "Type", a->Type, 1);
  if (a->MimeType)
    soap_set_attr(soap, "MimeType", a->MimeType, 1);
  if (a->Encoding)
    soap_set_attr(soap, "Encoding", a->Encoding, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedDataType), type))
    return soap->error;
  if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
    return soap->error;
  if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
    return soap->error;
  if (a->CipherData) {
    if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "xenc:CipherData"))
    return soap->error;
  if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_in_xenc__EncryptedDataType(struct soap *soap, const char *tag, struct xenc__EncryptedDataType *a, const char *type) {
  size_t soap_flag_EncryptionMethod = 1;
  size_t soap_flag_ds__KeyInfo = 1;
  size_t soap_flag_CipherData = 1;
  size_t soap_flag_EncryptionProperties = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct xenc__EncryptedDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_xenc__EncryptedDataType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType")) {
          soap_flag_EncryptionMethod--;
          continue;
        }
      if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, "")) {
          soap_flag_ds__KeyInfo--;
          continue;
        }
      if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType")) {
          soap_flag_CipherData--;
          continue;
        }
      if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType")) {
          soap_flag_EncryptionProperties--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct xenc__EncryptedDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedDataType, 0, sizeof(struct xenc__EncryptedDataType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedDataType);
  if (soap_out_xenc__EncryptedDataType(soap, tag?tag:"xenc:EncryptedDataType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_get_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *p, const char *tag, const char *type) {
  if ((p = soap_in_xenc__EncryptedDataType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__TransformsType(struct soap *soap, const char *tag, int id, const struct xenc__TransformsType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__TransformsType), type))
    return soap->error;
  if (soap_out__ds__Transform(soap, "ds:Transform", -1, &a->ds__Transform, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_in_xenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType *a, const char *type) {
  size_t soap_flag_ds__Transform = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct xenc__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_xenc__TransformsType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ds__Transform && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in__ds__Transform(soap, "ds:Transform", &a->ds__Transform, "")) {
          soap_flag_ds__Transform--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct xenc__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__TransformsType, 0, sizeof(struct xenc__TransformsType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__Transform > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__TransformsType);
  if (soap_out_xenc__TransformsType(soap, tag?tag:"xenc:TransformsType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_get_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *p, const char *tag, const char *type) {
  if ((p = soap_in_xenc__TransformsType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->Transforms = NULL;
  soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToxenc__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__CipherReferenceType *a, const char *type) {
  if (a->URI)
    soap_set_attr(soap, "URI", a->URI, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherReferenceType), type))
    return soap->error;
  if (soap_out_PointerToxenc__TransformsType(soap, "xenc:Transforms", -1, &a->Transforms, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_in_xenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType *a, const char *type) {
  size_t soap_flag_Transforms = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct xenc__CipherReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_xenc__CipherReferenceType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxenc__TransformsType(soap, "xenc:Transforms", &a->Transforms, "xenc:TransformsType")) {
          soap_flag_Transforms--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct xenc__CipherReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherReferenceType, 0, sizeof(struct xenc__CipherReferenceType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__CipherReferenceType);
  if (soap_out_xenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_get_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *p, const char *tag, const char *type) {
  if ((p = soap_in_xenc__CipherReferenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->CipherValue);
  a->CipherReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->CipherValue);
  soap_serialize_PointerToxenc__CipherReferenceType(soap, &a->CipherReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherDataType(struct soap *soap, const char *tag, int id, const struct xenc__CipherDataType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherDataType), type))
    return soap->error;
  if (soap_out_string(soap, "xenc:CipherValue", -1, &a->CipherValue, ""))
    return soap->error;
  if (soap_out_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", -1, &a->CipherReference, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_in_xenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType *a, const char *type) {
  size_t soap_flag_CipherValue = 1;
  size_t soap_flag_CipherReference = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct xenc__CipherDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_xenc__CipherDataType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_CipherValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "xenc:CipherValue", &a->CipherValue, "xsd:string")) {
          soap_flag_CipherValue--;
          continue;
        }
      if (soap_flag_CipherReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", &a->CipherReference, "xenc:CipherReferenceType")) {
          soap_flag_CipherReference--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct xenc__CipherDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherDataType, 0, sizeof(struct xenc__CipherDataType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__CipherDataType);
  if (soap_out_xenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_get_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *p, const char *tag, const char *type) {
  if ((p = soap_in_xenc__CipherDataType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->KeySize = NULL;
  soap_default_string(soap, &a->OAEPparams);
  soap_default_string(soap, &a->Algorithm);
  a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToint(soap, &a->KeySize);
  soap_serialize_string(soap, &a->OAEPparams);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionMethodType *a, const char *type) {
  if (a->Algorithm)
    soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionMethodType), type))
    return soap->error;
  if (soap_out_PointerToint(soap, "xenc:KeySize", -1, &a->KeySize, ""))
    return soap->error;
  if (soap_out_string(soap, "xenc:OAEPparams", -1, &a->OAEPparams, ""))
    return soap->error;
  soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_in_xenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType *a, const char *type) {
  size_t soap_flag_KeySize = 1;
  size_t soap_flag_OAEPparams = 1;
  size_t soap_flag___mixed = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct xenc__EncryptionMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_xenc__EncryptionMethodType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToint(soap, "xenc:KeySize", &a->KeySize, "xsd:int")) {
          soap_flag_KeySize--;
          continue;
        }
      if (soap_flag_OAEPparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "xenc:OAEPparams", &a->OAEPparams, "xsd:string")) {
          soap_flag_OAEPparams--;
          continue;
        }
      if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-mixed", &a->__mixed)) {
          soap_flag___mixed--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct xenc__EncryptionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionMethodType, 0, sizeof(struct xenc__EncryptionMethodType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionMethodType);
  if (soap_out_xenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_get_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *p, const char *tag, const char *type) {
  if ((p = soap_in_xenc__EncryptionMethodType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->EncryptionMethod = NULL;
  a->ds__KeyInfo = NULL;
  a->CipherData = NULL;
  a->EncryptionProperties = NULL;
  soap_default_string(soap, &a->Id);
  soap_default_string(soap, &a->Type);
  soap_default_string(soap, &a->MimeType);
  soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
  soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
  soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
  soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedType *a, const char *type) {
  if (a->Id)
    soap_set_attr(soap, "Id", a->Id, 1);
  if (a->Type)
    soap_set_attr(soap, "Type", a->Type, 1);
  if (a->MimeType)
    soap_set_attr(soap, "MimeType", a->MimeType, 1);
  if (a->Encoding)
    soap_set_attr(soap, "Encoding", a->Encoding, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedType), type))
    return soap->error;
  if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
    return soap->error;
  if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
    return soap->error;
  if (a->CipherData) {
    if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "xenc:CipherData"))
    return soap->error;
  if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_in_xenc__EncryptedType(struct soap *soap, const char *tag, struct xenc__EncryptedType *a, const char *type) {
  size_t soap_flag_EncryptionMethod = 1;
  size_t soap_flag_ds__KeyInfo = 1;
  size_t soap_flag_CipherData = 1;
  size_t soap_flag_EncryptionProperties = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct xenc__EncryptedType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_xenc__EncryptedType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType")) {
          soap_flag_EncryptionMethod--;
          continue;
        }
      if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, "")) {
          soap_flag_ds__KeyInfo--;
          continue;
        }
      if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType")) {
          soap_flag_CipherData--;
          continue;
        }
      if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType")) {
          soap_flag_EncryptionProperties--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct xenc__EncryptedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedType, 0, sizeof(struct xenc__EncryptedType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedType);
  if (soap_out_xenc__EncryptedType(soap, tag?tag:"xenc:EncryptedType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_get_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *p, const char *tag, const char *type) {
  if ((p = soap_in_xenc__EncryptedType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->Modulus);
  soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->Modulus);
  soap_serialize_string(soap, &a->Exponent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
    return soap->error;
  if (a->Modulus) {
    if (soap_out_string(soap, "ds:Modulus", -1, &a->Modulus, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:Modulus"))
    return soap->error;
  if (a->Exponent) {
    if (soap_out_string(soap, "ds:Exponent", -1, &a->Exponent, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:Exponent"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type) {
  size_t soap_flag_Modulus = 1;
  size_t soap_flag_Exponent = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__RSAKeyValueType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:Modulus", &a->Modulus, "xsd:string")) {
          soap_flag_Modulus--;
          continue;
        }
      if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:Exponent", &a->Exponent, "xsd:string")) {
          soap_flag_Exponent--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, 0, sizeof(struct ds__RSAKeyValueType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RSAKeyValueType);
  if (soap_out_ds__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->G);
  soap_default_string(soap, &a->Y);
  soap_default_string(soap, &a->J);
  soap_default_string(soap, &a->P);
  soap_default_string(soap, &a->Q);
  soap_default_string(soap, &a->Seed);
  soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->G);
  soap_serialize_string(soap, &a->Y);
  soap_serialize_string(soap, &a->J);
  soap_serialize_string(soap, &a->P);
  soap_serialize_string(soap, &a->Q);
  soap_serialize_string(soap, &a->Seed);
  soap_serialize_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
    return soap->error;
  if (soap_out_string(soap, "ds:G", -1, &a->G, ""))
    return soap->error;
  if (a->Y) {
    if (soap_out_string(soap, "ds:Y", -1, &a->Y, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:Y"))
    return soap->error;
  if (soap_out_string(soap, "ds:J", -1, &a->J, ""))
    return soap->error;
  if (a->P) {
    if (soap_out_string(soap, "ds:P", -1, &a->P, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:P"))
    return soap->error;
  if (a->Q) {
    if (soap_out_string(soap, "ds:Q", -1, &a->Q, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:Q"))
    return soap->error;
  if (a->Seed) {
    if (soap_out_string(soap, "ds:Seed", -1, &a->Seed, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:Seed"))
    return soap->error;
  if (a->PgenCounter) {
    if (soap_out_string(soap, "ds:PgenCounter", -1, &a->PgenCounter, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:PgenCounter"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type) {
  size_t soap_flag_G = 1;
  size_t soap_flag_Y = 1;
  size_t soap_flag_J = 1;
  size_t soap_flag_P = 1;
  size_t soap_flag_Q = 1;
  size_t soap_flag_Seed = 1;
  size_t soap_flag_PgenCounter = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__DSAKeyValueType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:G", &a->G, "xsd:string")) {
          soap_flag_G--;
          continue;
        }
      if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:Y", &a->Y, "xsd:string")) {
          soap_flag_Y--;
          continue;
        }
      if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:J", &a->J, "xsd:string")) {
          soap_flag_J--;
          continue;
        }
      if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:P", &a->P, "xsd:string")) {
          soap_flag_P--;
          continue;
        }
      if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:Q", &a->Q, "xsd:string")) {
          soap_flag_Q--;
          continue;
        }
      if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:Seed", &a->Seed, "xsd:string")) {
          soap_flag_Seed--;
          continue;
        }
      if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:PgenCounter", &a->PgenCounter, "xsd:string")) {
          soap_flag_PgenCounter--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, 0, sizeof(struct ds__DSAKeyValueType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DSAKeyValueType);
  if (soap_out_ds__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->X509IssuerName);
  soap_default_int(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->X509IssuerName);
  soap_embedded(soap, &a->X509SerialNumber, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
    return soap->error;
  if (a->X509IssuerName) {
    if (soap_out_string(soap, "ds:X509IssuerName", -1, &a->X509IssuerName, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:X509IssuerName"))
    return soap->error;
  if (soap_out_int(soap, "ds:X509SerialNumber", -1, &a->X509SerialNumber, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type) {
  size_t soap_flag_X509IssuerName = 1;
  size_t soap_flag_X509SerialNumber = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__X509IssuerSerialType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:X509IssuerName", &a->X509IssuerName, "xsd:string")) {
          soap_flag_X509IssuerName--;
          continue;
        }
      if (soap_flag_X509SerialNumber && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_int(soap, "ds:X509SerialNumber", &a->X509SerialNumber, "xsd:int")) {
          soap_flag_X509SerialNumber--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, 0, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509IssuerSerialType);
  if (soap_out_ds__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->Reference = NULL;
  a->KeyIdentifier = NULL;
  a->Embedded = NULL;
  soap_default_string(soap, &a->wsu__Id);
  soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
  soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
  soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type) {
  if (a->wsu__Id)
    soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
  if (a->Usage)
    soap_set_attr(soap, "Usage", a->Usage, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
    return soap->error;
  if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
    return soap->error;
  if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
    return soap->error;
  if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type) {
  size_t soap_flag_Reference = 1;
  size_t soap_flag_KeyIdentifier = 1;
  size_t soap_flag_Embedded = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__wsse__SecurityTokenReference(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, "")) {
          soap_flag_Reference--;
          continue;
        }
      if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, "")) {
          soap_flag_KeyIdentifier--;
          continue;
        }
      if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, "")) {
          soap_flag_Embedded--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, 0, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__SecurityTokenReference);
  if (soap_out__wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type) {
  if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->X509IssuerSerial = NULL;
  soap_default_string(soap, &a->X509SKI);
  soap_default_string(soap, &a->X509SubjectName);
  soap_default_string(soap, &a->X509Certificate);
  soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
  soap_serialize_string(soap, &a->X509SKI);
  soap_serialize_string(soap, &a->X509SubjectName);
  soap_serialize_string(soap, &a->X509Certificate);
  soap_serialize_string(soap, &a->X509CRL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
    return soap->error;
  if (a->X509IssuerSerial) {
    if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:X509IssuerSerial"))
    return soap->error;
  if (a->X509SKI) {
    if (soap_out_string(soap, "ds:X509SKI", -1, &a->X509SKI, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:X509SKI"))
    return soap->error;
  if (a->X509SubjectName) {
    if (soap_out_string(soap, "ds:X509SubjectName", -1, &a->X509SubjectName, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:X509SubjectName"))
    return soap->error;
  if (a->X509Certificate) {
    if (soap_out_string(soap, "ds:X509Certificate", -1, &a->X509Certificate, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:X509Certificate"))
    return soap->error;
  if (a->X509CRL) {
    if (soap_out_string(soap, "ds:X509CRL", -1, &a->X509CRL, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:X509CRL"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type) {
  size_t soap_flag_X509IssuerSerial = 1;
  size_t soap_flag_X509SKI = 1;
  size_t soap_flag_X509SubjectName = 1;
  size_t soap_flag_X509Certificate = 1;
  size_t soap_flag_X509CRL = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__X509DataType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType")) {
          soap_flag_X509IssuerSerial--;
          continue;
        }
      if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:X509SKI", &a->X509SKI, "xsd:string")) {
          soap_flag_X509SKI--;
          continue;
        }
      if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:X509SubjectName", &a->X509SubjectName, "xsd:string")) {
          soap_flag_X509SubjectName--;
          continue;
        }
      if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:X509Certificate", &a->X509Certificate, "xsd:string")) {
          soap_flag_X509Certificate--;
          continue;
        }
      if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:X509CRL", &a->X509CRL, "xsd:string")) {
          soap_flag_X509CRL--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, 0, sizeof(struct ds__X509DataType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerSerial > 0 || soap_flag_X509SKI > 0 || soap_flag_X509SubjectName > 0 || soap_flag_X509Certificate > 0 || soap_flag_X509CRL > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509DataType);
  if (soap_out_ds__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->Transforms = NULL;
  soap_default_string(soap, &a->URI);
  soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type) {
  if (a->URI)
    soap_set_attr(soap, "URI", a->URI, 1);
  if (a->Type)
    soap_set_attr(soap, "Type", a->Type, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
    return soap->error;
  if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type) {
  size_t soap_flag_Transforms = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__RetrievalMethodType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType")) {
          soap_flag_Transforms--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, 0, sizeof(struct ds__RetrievalMethodType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RetrievalMethodType);
  if (soap_out_ds__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->DSAKeyValue = NULL;
  a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
  soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
    return soap->error;
  if (a->DSAKeyValue) {
    if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:DSAKeyValue"))
    return soap->error;
  if (a->RSAKeyValue) {
    if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:RSAKeyValue"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type) {
  size_t soap_flag_DSAKeyValue = 1;
  size_t soap_flag_RSAKeyValue = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__KeyValueType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType")) {
          soap_flag_DSAKeyValue--;
          continue;
        }
      if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType")) {
          soap_flag_RSAKeyValue--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, 0, sizeof(struct ds__KeyValueType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DSAKeyValue > 0 || soap_flag_RSAKeyValue > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyValueType);
  if (soap_out_ds__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type) {
  if (a->Algorithm)
    soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__DigestMethodType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, 0, sizeof(struct ds__DigestMethodType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DigestMethodType);
  if (soap_out_ds__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->c14n__InclusiveNamespaces = NULL;
  a->__any = NULL;
  soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type) {
  if (a->Algorithm)
    soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
    return soap->error;
  if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
    return soap->error;
  soap_outliteral(soap, "-any", &a->__any, NULL);
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type) {
  size_t soap_flag_c14n__InclusiveNamespaces = 1;
  size_t soap_flag___any = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__TransformType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, "")) {
          soap_flag_c14n__InclusiveNamespaces--;
          continue;
        }
      if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_inliteral(soap, "-any", &a->__any)) {
          soap_flag___any--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, 0, sizeof(struct ds__TransformType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformType);
  if (soap_out_ds__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type) {
  if (a->PrefixList)
    soap_set_attr(soap, "PrefixList", a->PrefixList, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type) {
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default__c14n__InclusiveNamespaces(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, 0, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__c14n__InclusiveNamespaces);
  if (soap_out__c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type) {
  if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->__sizeTransform = 0;
  a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  if (a->Transform) {
    int i;
    for (i = 0; i < a->__sizeTransform; i++) {
      soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
      soap_serialize_ds__TransformType(soap, a->Transform + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type) {
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
    return soap->error;
  if (a->Transform) {
    int i;
    for (i = 0; i < a->__sizeTransform; i++)
      if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type) {
  struct soap_blist *soap_blist_Transform = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__TransformsType(soap, a);
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL)) {
        if (a->Transform == NULL) {
          if (soap_blist_Transform == NULL)
            soap_blist_Transform = soap_new_block(soap);
          a->Transform = (struct ds__TransformType *)soap_push_block(soap, soap_blist_Transform, sizeof(struct ds__TransformType));
          if (a->Transform == NULL)
            return NULL;
          soap_default_ds__TransformType(soap, a->Transform);
        }
        soap_revert(soap);
        if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType")) {
          a->__sizeTransform++;
          a->Transform = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->Transform)
      soap_pop_block(soap, soap_blist_Transform);
    if (a->__sizeTransform)
      a->Transform = (struct ds__TransformType *)soap_save_block(soap, soap_blist_Transform, NULL, 1);
    else {
      a->Transform = NULL;
      if (soap_blist_Transform)
        soap_end_block(soap, soap_blist_Transform);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, 0, sizeof(struct ds__TransformsType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformsType);
  if (soap_out_ds__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->Transforms = NULL;
  a->DigestMethod = NULL;
  soap_default_string(soap, &a->DigestValue);
  soap_default_string(soap, &a->Id);
  soap_default_string(soap, &a->URI);
  soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
  soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
  soap_serialize_string(soap, &a->DigestValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type) {
  if (a->Id)
    soap_set_attr(soap, "Id", a->Id, 1);
  if (a->URI)
    soap_set_attr(soap, "URI", a->URI, 1);
  if (a->Type)
    soap_set_attr(soap, "Type", a->Type, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
    return soap->error;
  if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
    return soap->error;
  if (a->DigestMethod) {
    if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:DigestMethod"))
    return soap->error;
  if (a->DigestValue) {
    if (soap_out_string(soap, "ds:DigestValue", -1, &a->DigestValue, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:DigestValue"))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type) {
  size_t soap_flag_Transforms = 1;
  size_t soap_flag_DigestMethod = 1;
  size_t soap_flag_DigestValue = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__ReferenceType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
    return NULL;
  if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType")) {
          soap_flag_Transforms--;
          continue;
        }
      if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType")) {
          soap_flag_DigestMethod--;
          continue;
        }
      if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:DigestValue", &a->DigestValue, "xsd:string")) {
          soap_flag_DigestValue--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, 0, sizeof(struct ds__ReferenceType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__ReferenceType);
  if (soap_out_ds__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->HMACOutputLength = NULL;
  soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToint(soap, &a->HMACOutputLength);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type) {
  if (a->Algorithm)
    soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
    return soap->error;
  if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type) {
  size_t soap_flag_HMACOutputLength = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__SignatureMethodType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int")) {
          soap_flag_HMACOutputLength--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, 0, sizeof(struct ds__SignatureMethodType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureMethodType);
  if (soap_out_ds__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->Algorithm);
  a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type) {
  if (a->Algorithm)
    soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
    return soap->error;
  if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type) {
  size_t soap_flag_c14n__InclusiveNamespaces = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__CanonicalizationMethodType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, "")) {
          soap_flag_c14n__InclusiveNamespaces--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, 0, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__CanonicalizationMethodType);
  if (soap_out_ds__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->KeyName);
  a->KeyValue = NULL;
  a->RetrievalMethod = NULL;
  a->X509Data = NULL;
  a->wsse__SecurityTokenReference = NULL;
  soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->KeyName);
  soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
  soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
  soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
  soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type) {
  if (a->Id)
    soap_set_attr(soap, "Id", a->Id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
    return soap->error;
  if (soap_out_string(soap, "ds:KeyName", -1, &a->KeyName, ""))
    return soap->error;
  if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
    return soap->error;
  if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
    return soap->error;
  if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
    return soap->error;
  if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type) {
  size_t soap_flag_KeyName = 1;
  size_t soap_flag_KeyValue = 1;
  size_t soap_flag_RetrievalMethod = 1;
  size_t soap_flag_X509Data = 1;
  size_t soap_flag_wsse__SecurityTokenReference = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__KeyInfoType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:KeyName", &a->KeyName, "xsd:string")) {
          soap_flag_KeyName--;
          continue;
        }
      if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType")) {
          soap_flag_KeyValue--;
          continue;
        }
      if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType")) {
          soap_flag_RetrievalMethod--;
          continue;
        }
      if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType")) {
          soap_flag_X509Data--;
          continue;
        }
      if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, "")) {
          soap_flag_wsse__SecurityTokenReference--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, 0, sizeof(struct ds__KeyInfoType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyInfoType);
  if (soap_out_ds__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->CanonicalizationMethod = NULL;
  a->SignatureMethod = NULL;
  a->__sizeReference = 0;
  a->Reference = NULL;
  soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
  soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
  if (a->Reference) {
    int i;
    for (i = 0; i < a->__sizeReference; i++) {
      soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
    }
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type) {
  if (a->Id)
    soap_set_attr(soap, "Id", a->Id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
    return soap->error;
  if (a->CanonicalizationMethod) {
    if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:CanonicalizationMethod"))
    return soap->error;
  if (a->SignatureMethod) {
    if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
      return soap->error;
  }
  else if (soap_element_nil(soap, "ds:SignatureMethod"))
    return soap->error;
  if (a->Reference) {
    int i;
    for (i = 0; i < a->__sizeReference; i++)
      if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
        return soap->error;
  }
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type) {
  size_t soap_flag_CanonicalizationMethod = 1;
  size_t soap_flag_SignatureMethod = 1;
  struct soap_blist *soap_blist_Reference = NULL;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__SignedInfoType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType")) {
          soap_flag_CanonicalizationMethod--;
          continue;
        }
      if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType")) {
          soap_flag_SignatureMethod--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL)) {
        if (a->Reference == NULL) {
          if (soap_blist_Reference == NULL)
            soap_blist_Reference = soap_new_block(soap);
          a->Reference = (struct ds__ReferenceType **)soap_push_block(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
          if (a->Reference == NULL)
            return NULL;
          *a->Reference = NULL;
        }
        soap_revert(soap);
        if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType")) {
          a->__sizeReference++;
          a->Reference = NULL;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (a->Reference)
      soap_pop_block(soap, soap_blist_Reference);
    if (a->__sizeReference)
      a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
    else {
      a->Reference = NULL;
      if (soap_blist_Reference)
        soap_end_block(soap, soap_blist_Reference);
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, 0, sizeof(struct ds__SignedInfoType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0)) {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignedInfoType);
  if (soap_out_ds__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  a->SignedInfo = NULL;
  soap_default_string(soap, &a->SignatureValue);
  a->KeyInfo = NULL;
  soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
  soap_serialize_string(soap, &a->SignatureValue);
  soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type) {
  if (a->Id)
    soap_set_attr(soap, "Id", a->Id, 1);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
    return soap->error;
  if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
    return soap->error;
  if (soap_out_string(soap, "ds:SignatureValue", -1, &a->SignatureValue, ""))
    return soap->error;
  if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type) {
  size_t soap_flag_SignedInfo = 1;
  size_t soap_flag_SignatureValue = 1;
  size_t soap_flag_KeyInfo = 1;
  if (soap_element_begin_in(soap, tag, 0, type))
    return NULL;
  a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL, NULL);
  if (!a)
    return NULL;
  soap_default_ds__SignatureType(soap, a);
  if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
    return NULL;
  if (soap->body && !*soap->href) {
    for (;;) {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType")) {
          soap_flag_SignedInfo--;
          continue;
        }
      if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
        if (soap_in_string(soap, "ds:SignatureValue", &a->SignatureValue, "xsd:string")) {
          soap_flag_SignatureValue--;
          continue;
        }
      if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
        if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType")) {
          soap_flag_KeyInfo--;
          continue;
        }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
  }
  else {
    a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, 0, sizeof(struct ds__SignatureType), 0, NULL);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureType);
  if (soap_out_ds__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type) {
  if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__union_AttributeStatementType(struct soap *soap, int choice, const union _ns8__union_AttributeStatementType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  switch (choice) {
  case SOAP_UNION__ns8__union_AttributeStatementType_Attribute:
    soap_serialize_PointerTons8__AttributeType(soap, &a->Attribute);
    break;
  case SOAP_UNION__ns8__union_AttributeStatementType_EncryptedAttribute:
    soap_serialize_PointerTons8__EncryptedElementType(soap, &a->EncryptedAttribute);
    break;
  default:
    break;
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__union_AttributeStatementType(struct soap *soap, int choice, const union _ns8__union_AttributeStatementType *a) {
  switch (choice) {
  case SOAP_UNION__ns8__union_AttributeStatementType_Attribute:
    return soap_out_PointerTons8__AttributeType(soap, "Attribute", -1, &a->Attribute, "");
  case SOAP_UNION__ns8__union_AttributeStatementType_EncryptedAttribute:
    return soap_out_PointerTons8__EncryptedElementType(soap, "EncryptedAttribute", -1, &a->EncryptedAttribute, "");
  default:
    break;
  }
  return SOAP_OK;
}

SOAP_FMAC3 union _ns8__union_AttributeStatementType * SOAP_FMAC4 soap_in__ns8__union_AttributeStatementType(struct soap *soap, int *choice, union _ns8__union_AttributeStatementType *a) {
  soap->error = SOAP_TAG_MISMATCH;
  a->Attribute = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__AttributeType(soap, "Attribute", &a->Attribute, "ns8:AttributeType")) {
    *choice = SOAP_UNION__ns8__union_AttributeStatementType_Attribute;
    return a;
  }
  a->EncryptedAttribute = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__EncryptedElementType(soap, "EncryptedAttribute", &a->EncryptedAttribute, "ns8:EncryptedElementType")) {
    *choice = SOAP_UNION__ns8__union_AttributeStatementType_EncryptedAttribute;
    return a;
  }
  *choice = 0;
  if (!soap->error)
    soap->error = SOAP_TAG_MISMATCH;
  return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__union_EvidenceType(struct soap *soap, int choice, const union _ns8__union_EvidenceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  switch (choice) {
  case SOAP_UNION__ns8__union_EvidenceType_AssertionIDRef:
    soap_serialize_string(soap, &a->AssertionIDRef);
    break;
  case SOAP_UNION__ns8__union_EvidenceType_AssertionURIRef:
    soap_serialize_string(soap, &a->AssertionURIRef);
    break;
  case SOAP_UNION__ns8__union_EvidenceType_Assertion:
    soap_serialize_PointerTons8__AssertionType(soap, &a->Assertion);
    break;
  case SOAP_UNION__ns8__union_EvidenceType_EncryptedAssertion:
    soap_serialize_PointerTons8__EncryptedElementType(soap, &a->EncryptedAssertion);
    break;
  default:
    break;
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__union_EvidenceType(struct soap *soap, int choice, const union _ns8__union_EvidenceType *a) {
  switch (choice) {
  case SOAP_UNION__ns8__union_EvidenceType_AssertionIDRef:
    return soap_out_string(soap, "AssertionIDRef", -1, &a->AssertionIDRef, "");
  case SOAP_UNION__ns8__union_EvidenceType_AssertionURIRef:
    return soap_out_string(soap, "AssertionURIRef", -1, &a->AssertionURIRef, "");
  case SOAP_UNION__ns8__union_EvidenceType_Assertion:
    return soap_out_PointerTons8__AssertionType(soap, "Assertion", -1, &a->Assertion, "");
  case SOAP_UNION__ns8__union_EvidenceType_EncryptedAssertion:
    return soap_out_PointerTons8__EncryptedElementType(soap, "EncryptedAssertion", -1, &a->EncryptedAssertion, "");
  default:
    break;
  }
  return SOAP_OK;
}

SOAP_FMAC3 union _ns8__union_EvidenceType * SOAP_FMAC4 soap_in__ns8__union_EvidenceType(struct soap *soap, int *choice, union _ns8__union_EvidenceType *a) {
  soap->error = SOAP_TAG_MISMATCH;
  a->AssertionIDRef = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "AssertionIDRef", &a->AssertionIDRef, "xsd:string")) {
    *choice = SOAP_UNION__ns8__union_EvidenceType_AssertionIDRef;
    return a;
  }
  a->AssertionURIRef = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "AssertionURIRef", &a->AssertionURIRef, "xsd:string")) {
    *choice = SOAP_UNION__ns8__union_EvidenceType_AssertionURIRef;
    return a;
  }
  a->Assertion = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__AssertionType(soap, "Assertion", &a->Assertion, "ns8:AssertionType")) {
    *choice = SOAP_UNION__ns8__union_EvidenceType_Assertion;
    return a;
  }
  a->EncryptedAssertion = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__EncryptedElementType(soap, "EncryptedAssertion", &a->EncryptedAssertion, "ns8:EncryptedElementType")) {
    *choice = SOAP_UNION__ns8__union_EvidenceType_EncryptedAssertion;
    return a;
  }
  *choice = 0;
  if (!soap->error)
    soap->error = SOAP_TAG_MISMATCH;
  return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__union_AuthnContextType__(struct soap *soap, int choice, const union _ns8__union_AuthnContextType__ *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  switch (choice) {
  case SOAP_UNION__ns8__union_AuthnContextType___AuthnContextDeclRef:
    soap_serialize_string(soap, &a->AuthnContextDeclRef);
    break;
  default:
    break;
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__union_AuthnContextType__(struct soap *soap, int choice, const union _ns8__union_AuthnContextType__ *a) {
  switch (choice) {
  case SOAP_UNION__ns8__union_AuthnContextType___AuthnContextDecl:
    return soap_outliteral(soap, "AuthnContextDecl", &a->AuthnContextDecl, NULL);
  case SOAP_UNION__ns8__union_AuthnContextType___AuthnContextDeclRef:
    return soap_out_string(soap, "AuthnContextDeclRef", -1, &a->AuthnContextDeclRef, "");
  default:
    break;
  }
  return SOAP_OK;
}

SOAP_FMAC3 union _ns8__union_AuthnContextType__ * SOAP_FMAC4 soap_in__ns8__union_AuthnContextType__(struct soap *soap, int *choice, union _ns8__union_AuthnContextType__ *a) {
  soap->error = SOAP_TAG_MISMATCH;
  if (soap->error == SOAP_TAG_MISMATCH && soap_inliteral(soap, "AuthnContextDecl", &a->AuthnContextDecl)) {
    *choice = SOAP_UNION__ns8__union_AuthnContextType___AuthnContextDecl;
    return a;
  }
  a->AuthnContextDeclRef = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "AuthnContextDeclRef", &a->AuthnContextDeclRef, "xsd:string")) {
    *choice = SOAP_UNION__ns8__union_AuthnContextType___AuthnContextDeclRef;
    return a;
  }
  *choice = 0;
  if (!soap->error)
    soap->error = SOAP_TAG_MISMATCH;
  return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__union_AuthnContextType_(struct soap *soap, int choice, const union _ns8__union_AuthnContextType_ *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  switch (choice) {
  case SOAP_UNION__ns8__union_AuthnContextType__AuthnContextDeclRef:
    soap_serialize_string(soap, &a->AuthnContextDeclRef);
    break;
  default:
    break;
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__union_AuthnContextType_(struct soap *soap, int choice, const union _ns8__union_AuthnContextType_ *a) {
  switch (choice) {
  case SOAP_UNION__ns8__union_AuthnContextType__AuthnContextDecl:
    return soap_outliteral(soap, "AuthnContextDecl", &a->AuthnContextDecl, NULL);
  case SOAP_UNION__ns8__union_AuthnContextType__AuthnContextDeclRef:
    return soap_out_string(soap, "AuthnContextDeclRef", -1, &a->AuthnContextDeclRef, "");
  default:
    break;
  }
  return SOAP_OK;
}

SOAP_FMAC3 union _ns8__union_AuthnContextType_ * SOAP_FMAC4 soap_in__ns8__union_AuthnContextType_(struct soap *soap, int *choice, union _ns8__union_AuthnContextType_ *a) {
  soap->error = SOAP_TAG_MISMATCH;
  if (soap->error == SOAP_TAG_MISMATCH && soap_inliteral(soap, "AuthnContextDecl", &a->AuthnContextDecl)) {
    *choice = SOAP_UNION__ns8__union_AuthnContextType__AuthnContextDecl;
    return a;
  }
  a->AuthnContextDeclRef = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "AuthnContextDeclRef", &a->AuthnContextDeclRef, "xsd:string")) {
    *choice = SOAP_UNION__ns8__union_AuthnContextType__AuthnContextDeclRef;
    return a;
  }
  *choice = 0;
  if (!soap->error)
    soap->error = SOAP_TAG_MISMATCH;
  return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__union_AdviceType(struct soap *soap, int choice, const union _ns8__union_AdviceType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  switch (choice) {
  case SOAP_UNION__ns8__union_AdviceType_AssertionIDRef:
    soap_serialize_string(soap, &a->AssertionIDRef);
    break;
  case SOAP_UNION__ns8__union_AdviceType_AssertionURIRef:
    soap_serialize_string(soap, &a->AssertionURIRef);
    break;
  case SOAP_UNION__ns8__union_AdviceType_Assertion:
    soap_serialize_PointerTons8__AssertionType(soap, &a->Assertion);
    break;
  case SOAP_UNION__ns8__union_AdviceType_EncryptedAssertion:
    soap_serialize_PointerTons8__EncryptedElementType(soap, &a->EncryptedAssertion);
    break;
  default:
    break;
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__union_AdviceType(struct soap *soap, int choice, const union _ns8__union_AdviceType *a) {
  switch (choice) {
  case SOAP_UNION__ns8__union_AdviceType_AssertionIDRef:
    return soap_out_string(soap, "AssertionIDRef", -1, &a->AssertionIDRef, "");
  case SOAP_UNION__ns8__union_AdviceType_AssertionURIRef:
    return soap_out_string(soap, "AssertionURIRef", -1, &a->AssertionURIRef, "");
  case SOAP_UNION__ns8__union_AdviceType_Assertion:
    return soap_out_PointerTons8__AssertionType(soap, "Assertion", -1, &a->Assertion, "");
  case SOAP_UNION__ns8__union_AdviceType_EncryptedAssertion:
    return soap_out_PointerTons8__EncryptedElementType(soap, "EncryptedAssertion", -1, &a->EncryptedAssertion, "");
  case SOAP_UNION__ns8__union_AdviceType___any:
    return soap_outliteral(soap, "-any", &a->__any, NULL);
  default:
    break;
  }
  return SOAP_OK;
}

SOAP_FMAC3 union _ns8__union_AdviceType * SOAP_FMAC4 soap_in__ns8__union_AdviceType(struct soap *soap, int *choice, union _ns8__union_AdviceType *a) {
  soap->error = SOAP_TAG_MISMATCH;
  a->AssertionIDRef = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "AssertionIDRef", &a->AssertionIDRef, "xsd:string")) {
    *choice = SOAP_UNION__ns8__union_AdviceType_AssertionIDRef;
    return a;
  }
  a->AssertionURIRef = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "AssertionURIRef", &a->AssertionURIRef, "xsd:string")) {
    *choice = SOAP_UNION__ns8__union_AdviceType_AssertionURIRef;
    return a;
  }
  a->Assertion = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__AssertionType(soap, "Assertion", &a->Assertion, "ns8:AssertionType")) {
    *choice = SOAP_UNION__ns8__union_AdviceType_Assertion;
    return a;
  }
  a->EncryptedAssertion = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__EncryptedElementType(soap, "EncryptedAssertion", &a->EncryptedAssertion, "ns8:EncryptedElementType")) {
    *choice = SOAP_UNION__ns8__union_AdviceType_EncryptedAssertion;
    return a;
  }
  if (soap->error == SOAP_TAG_MISMATCH && soap_inliteral(soap, "-any", &a->__any)) {
    *choice = SOAP_UNION__ns8__union_AdviceType___any;
    return a;
  }
  *choice = 0;
  if (!soap->error)
    soap->error = SOAP_TAG_MISMATCH;
  return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__union_ConditionsType(struct soap *soap, int choice, const union _ns8__union_ConditionsType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  switch (choice) {
  case SOAP_UNION__ns8__union_ConditionsType_Condition:
    soap_serialize_PointerTons8__ConditionAbstractType(soap, &a->Condition);
    break;
  case SOAP_UNION__ns8__union_ConditionsType_AudienceRestriction:
    soap_serialize_PointerTons8__AudienceRestrictionType(soap, &a->AudienceRestriction);
    break;
  case SOAP_UNION__ns8__union_ConditionsType_OneTimeUse:
    soap_serialize_PointerTons8__OneTimeUseType(soap, &a->OneTimeUse);
    break;
  case SOAP_UNION__ns8__union_ConditionsType_ProxyRestriction:
    soap_serialize_PointerTons8__ProxyRestrictionType(soap, &a->ProxyRestriction);
    break;
  default:
    break;
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__union_ConditionsType(struct soap *soap, int choice, const union _ns8__union_ConditionsType *a) {
  switch (choice) {
  case SOAP_UNION__ns8__union_ConditionsType_Condition:
    return soap_out_PointerTons8__ConditionAbstractType(soap, "Condition", -1, &a->Condition, "");
  case SOAP_UNION__ns8__union_ConditionsType_AudienceRestriction:
    return soap_out_PointerTons8__AudienceRestrictionType(soap, "AudienceRestriction", -1, &a->AudienceRestriction, "");
  case SOAP_UNION__ns8__union_ConditionsType_OneTimeUse:
    return soap_out_PointerTons8__OneTimeUseType(soap, "OneTimeUse", -1, &a->OneTimeUse, "");
  case SOAP_UNION__ns8__union_ConditionsType_ProxyRestriction:
    return soap_out_PointerTons8__ProxyRestrictionType(soap, "ProxyRestriction", -1, &a->ProxyRestriction, "");
  default:
    break;
  }
  return SOAP_OK;
}

SOAP_FMAC3 union _ns8__union_ConditionsType * SOAP_FMAC4 soap_in__ns8__union_ConditionsType(struct soap *soap, int *choice, union _ns8__union_ConditionsType *a) {
  soap->error = SOAP_TAG_MISMATCH;
  a->Condition = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__ConditionAbstractType(soap, "Condition", &a->Condition, "ns8:ConditionAbstractType")) {
    *choice = SOAP_UNION__ns8__union_ConditionsType_Condition;
    return a;
  }
  a->AudienceRestriction = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__AudienceRestrictionType(soap, "AudienceRestriction", &a->AudienceRestriction, "ns8:AudienceRestrictionType")) {
    *choice = SOAP_UNION__ns8__union_ConditionsType_AudienceRestriction;
    return a;
  }
  a->OneTimeUse = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__OneTimeUseType(soap, "OneTimeUse", &a->OneTimeUse, "ns8:OneTimeUseType")) {
    *choice = SOAP_UNION__ns8__union_ConditionsType_OneTimeUse;
    return a;
  }
  a->ProxyRestriction = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__ProxyRestrictionType(soap, "ProxyRestriction", &a->ProxyRestriction, "ns8:ProxyRestrictionType")) {
    *choice = SOAP_UNION__ns8__union_ConditionsType_ProxyRestriction;
    return a;
  }
  *choice = 0;
  if (!soap->error)
    soap->error = SOAP_TAG_MISMATCH;
  return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__union_SubjectConfirmationType(struct soap *soap, int choice, const union _ns8__union_SubjectConfirmationType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  switch (choice) {
  case SOAP_UNION__ns8__union_SubjectConfirmationType_BaseID:
    soap_serialize_PointerTons8__BaseIDAbstractType(soap, &a->BaseID);
    break;
  case SOAP_UNION__ns8__union_SubjectConfirmationType_NameID:
    soap_serialize_PointerTons8__NameIDType(soap, &a->NameID);
    break;
  case SOAP_UNION__ns8__union_SubjectConfirmationType_EncryptedID:
    soap_serialize_PointerTons8__EncryptedElementType(soap, &a->EncryptedID);
    break;
  default:
    break;
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__union_SubjectConfirmationType(struct soap *soap, int choice, const union _ns8__union_SubjectConfirmationType *a) {
  switch (choice) {
  case SOAP_UNION__ns8__union_SubjectConfirmationType_BaseID:
    return soap_out_PointerTons8__BaseIDAbstractType(soap, "BaseID", -1, &a->BaseID, "");
  case SOAP_UNION__ns8__union_SubjectConfirmationType_NameID:
    return soap_out_PointerTons8__NameIDType(soap, "NameID", -1, &a->NameID, "");
  case SOAP_UNION__ns8__union_SubjectConfirmationType_EncryptedID:
    return soap_out_PointerTons8__EncryptedElementType(soap, "EncryptedID", -1, &a->EncryptedID, "");
  default:
    break;
  }
  return SOAP_OK;
}

SOAP_FMAC3 union _ns8__union_SubjectConfirmationType * SOAP_FMAC4 soap_in__ns8__union_SubjectConfirmationType(struct soap *soap, int *choice, union _ns8__union_SubjectConfirmationType *a) {
  soap->error = SOAP_TAG_MISMATCH;
  a->BaseID = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__BaseIDAbstractType(soap, "BaseID", &a->BaseID, "ns8:BaseIDAbstractType")) {
    *choice = SOAP_UNION__ns8__union_SubjectConfirmationType_BaseID;
    return a;
  }
  a->NameID = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__NameIDType(soap, "NameID", &a->NameID, "ns8:NameIDType")) {
    *choice = SOAP_UNION__ns8__union_SubjectConfirmationType_NameID;
    return a;
  }
  a->EncryptedID = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__EncryptedElementType(soap, "EncryptedID", &a->EncryptedID, "ns8:EncryptedElementType")) {
    *choice = SOAP_UNION__ns8__union_SubjectConfirmationType_EncryptedID;
    return a;
  }
  *choice = 0;
  if (!soap->error)
    soap->error = SOAP_TAG_MISMATCH;
  return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__union_SubjectType_(struct soap *soap, int choice, const union _ns8__union_SubjectType_ *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  switch (choice) {
  case SOAP_UNION__ns8__union_SubjectType__BaseID:
    soap_serialize_PointerTons8__BaseIDAbstractType(soap, &a->BaseID);
    break;
  case SOAP_UNION__ns8__union_SubjectType__NameID:
    soap_serialize_PointerTons8__NameIDType(soap, &a->NameID);
    break;
  case SOAP_UNION__ns8__union_SubjectType__EncryptedID:
    soap_serialize_PointerTons8__EncryptedElementType(soap, &a->EncryptedID);
    break;
  default:
    break;
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__union_SubjectType_(struct soap *soap, int choice, const union _ns8__union_SubjectType_ *a) {
  switch (choice) {
  case SOAP_UNION__ns8__union_SubjectType__BaseID:
    return soap_out_PointerTons8__BaseIDAbstractType(soap, "BaseID", -1, &a->BaseID, "");
  case SOAP_UNION__ns8__union_SubjectType__NameID:
    return soap_out_PointerTons8__NameIDType(soap, "NameID", -1, &a->NameID, "");
  case SOAP_UNION__ns8__union_SubjectType__EncryptedID:
    return soap_out_PointerTons8__EncryptedElementType(soap, "EncryptedID", -1, &a->EncryptedID, "");
  default:
    break;
  }
  return SOAP_OK;
}

SOAP_FMAC3 union _ns8__union_SubjectType_ * SOAP_FMAC4 soap_in__ns8__union_SubjectType_(struct soap *soap, int *choice, union _ns8__union_SubjectType_ *a) {
  soap->error = SOAP_TAG_MISMATCH;
  a->BaseID = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__BaseIDAbstractType(soap, "BaseID", &a->BaseID, "ns8:BaseIDAbstractType")) {
    *choice = SOAP_UNION__ns8__union_SubjectType__BaseID;
    return a;
  }
  a->NameID = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__NameIDType(soap, "NameID", &a->NameID, "ns8:NameIDType")) {
    *choice = SOAP_UNION__ns8__union_SubjectType__NameID;
    return a;
  }
  a->EncryptedID = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__EncryptedElementType(soap, "EncryptedID", &a->EncryptedID, "ns8:EncryptedElementType")) {
    *choice = SOAP_UNION__ns8__union_SubjectType__EncryptedID;
    return a;
  }
  *choice = 0;
  if (!soap->error)
    soap->error = SOAP_TAG_MISMATCH;
  return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__union_AssertionType(struct soap *soap, int choice, const union _ns8__union_AssertionType *a) {
  (void)soap;
  (void)a; /* appease -Wall -Werror */
  switch (choice) {
  case SOAP_UNION__ns8__union_AssertionType_Statement:
    soap_serialize_PointerTons8__StatementAbstractType(soap, &a->Statement);
    break;
  case SOAP_UNION__ns8__union_AssertionType_AuthnStatement:
    soap_serialize_PointerTons8__AuthnStatementType(soap, &a->AuthnStatement);
    break;
  case SOAP_UNION__ns8__union_AssertionType_AuthzDecisionStatement:
    soap_serialize_PointerTons8__AuthzDecisionStatementType(soap, &a->AuthzDecisionStatement);
    break;
  case SOAP_UNION__ns8__union_AssertionType_AttributeStatement:
    soap_serialize_PointerTons8__AttributeStatementType(soap, &a->AttributeStatement);
    break;
  default:
    break;
  }
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__union_AssertionType(struct soap *soap, int choice, const union _ns8__union_AssertionType *a) {
  switch (choice) {
  case SOAP_UNION__ns8__union_AssertionType_Statement:
    return soap_out_PointerTons8__StatementAbstractType(soap, "Statement", -1, &a->Statement, "");
  case SOAP_UNION__ns8__union_AssertionType_AuthnStatement:
    return soap_out_PointerTons8__AuthnStatementType(soap, "AuthnStatement", -1, &a->AuthnStatement, "");
  case SOAP_UNION__ns8__union_AssertionType_AuthzDecisionStatement:
    return soap_out_PointerTons8__AuthzDecisionStatementType(soap, "AuthzDecisionStatement", -1, &a->AuthzDecisionStatement, "");
  case SOAP_UNION__ns8__union_AssertionType_AttributeStatement:
    return soap_out_PointerTons8__AttributeStatementType(soap, "AttributeStatement", -1, &a->AttributeStatement, "");
  default:
    break;
  }
  return SOAP_OK;
}

SOAP_FMAC3 union _ns8__union_AssertionType * SOAP_FMAC4 soap_in__ns8__union_AssertionType(struct soap *soap, int *choice, union _ns8__union_AssertionType *a) {
  soap->error = SOAP_TAG_MISMATCH;
  a->Statement = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__StatementAbstractType(soap, "Statement", &a->Statement, "ns8:StatementAbstractType")) {
    *choice = SOAP_UNION__ns8__union_AssertionType_Statement;
    return a;
  }
  a->AuthnStatement = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__AuthnStatementType(soap, "AuthnStatement", &a->AuthnStatement, "ns8:AuthnStatementType")) {
    *choice = SOAP_UNION__ns8__union_AssertionType_AuthnStatement;
    return a;
  }
  a->AuthzDecisionStatement = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__AuthzDecisionStatementType(soap, "AuthzDecisionStatement", &a->AuthzDecisionStatement, "ns8:AuthzDecisionStatementType")) {
    *choice = SOAP_UNION__ns8__union_AssertionType_AuthzDecisionStatement;
    return a;
  }
  a->AttributeStatement = NULL;
  if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons8__AttributeStatementType(soap, "AttributeStatement", &a->AttributeStatement, "ns8:AttributeStatementType")) {
    *choice = SOAP_UNION__ns8__union_AssertionType_AttributeStatement;
    return a;
  }
  *choice = 0;
  if (!soap->error)
    soap->error = SOAP_TAG_MISMATCH;
  return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
    soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
  if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
    soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
  if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
    soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
  if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__interDomainEventContent(struct soap *soap, struct ns1__interDomainEventContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__interDomainEventContent))
    soap_serialize_ns1__interDomainEventContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__interDomainEventContent(struct soap *soap, const char *tag, int id, struct ns1__interDomainEventContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__interDomainEventContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__interDomainEventContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__interDomainEventContent ** SOAP_FMAC4 soap_in_PointerTons1__interDomainEventContent(struct soap *soap, const char *tag, struct ns1__interDomainEventContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__interDomainEventContent **)soap_malloc(soap, sizeof(struct ns1__interDomainEventContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__interDomainEventContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__interDomainEventContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__interDomainEventContent, sizeof(struct ns1__interDomainEventContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__interDomainEventContent(struct soap *soap, struct ns1__interDomainEventContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__interDomainEventContent);
  if (soap_out_PointerTons1__interDomainEventContent(soap, tag?tag:"ns1:interDomainEventContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__interDomainEventContent ** SOAP_FMAC4 soap_get_PointerTons1__interDomainEventContent(struct soap *soap, struct ns1__interDomainEventContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__interDomainEventContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__teardownPathResponseContent(struct soap *soap, struct ns1__teardownPathResponseContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__teardownPathResponseContent))
    soap_serialize_ns1__teardownPathResponseContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__teardownPathResponseContent(struct soap *soap, const char *tag, int id, struct ns1__teardownPathResponseContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__teardownPathResponseContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__teardownPathResponseContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__teardownPathResponseContent ** SOAP_FMAC4 soap_in_PointerTons1__teardownPathResponseContent(struct soap *soap, const char *tag, struct ns1__teardownPathResponseContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__teardownPathResponseContent **)soap_malloc(soap, sizeof(struct ns1__teardownPathResponseContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__teardownPathResponseContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__teardownPathResponseContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__teardownPathResponseContent, sizeof(struct ns1__teardownPathResponseContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__teardownPathResponseContent(struct soap *soap, struct ns1__teardownPathResponseContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__teardownPathResponseContent);
  if (soap_out_PointerTons1__teardownPathResponseContent(soap, tag?tag:"ns1:teardownPathResponseContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__teardownPathResponseContent ** SOAP_FMAC4 soap_get_PointerTons1__teardownPathResponseContent(struct soap *soap, struct ns1__teardownPathResponseContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__teardownPathResponseContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__teardownPathContent(struct soap *soap, struct ns1__teardownPathContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__teardownPathContent))
    soap_serialize_ns1__teardownPathContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__teardownPathContent(struct soap *soap, const char *tag, int id, struct ns1__teardownPathContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__teardownPathContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__teardownPathContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__teardownPathContent ** SOAP_FMAC4 soap_in_PointerTons1__teardownPathContent(struct soap *soap, const char *tag, struct ns1__teardownPathContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__teardownPathContent **)soap_malloc(soap, sizeof(struct ns1__teardownPathContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__teardownPathContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__teardownPathContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__teardownPathContent, sizeof(struct ns1__teardownPathContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__teardownPathContent(struct soap *soap, struct ns1__teardownPathContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__teardownPathContent);
  if (soap_out_PointerTons1__teardownPathContent(soap, tag?tag:"ns1:teardownPathContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__teardownPathContent ** SOAP_FMAC4 soap_get_PointerTons1__teardownPathContent(struct soap *soap, struct ns1__teardownPathContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__teardownPathContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__refreshPathResponseContent(struct soap *soap, struct ns1__refreshPathResponseContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__refreshPathResponseContent))
    soap_serialize_ns1__refreshPathResponseContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__refreshPathResponseContent(struct soap *soap, const char *tag, int id, struct ns1__refreshPathResponseContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__refreshPathResponseContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__refreshPathResponseContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__refreshPathResponseContent ** SOAP_FMAC4 soap_in_PointerTons1__refreshPathResponseContent(struct soap *soap, const char *tag, struct ns1__refreshPathResponseContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__refreshPathResponseContent **)soap_malloc(soap, sizeof(struct ns1__refreshPathResponseContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__refreshPathResponseContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__refreshPathResponseContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__refreshPathResponseContent, sizeof(struct ns1__refreshPathResponseContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__refreshPathResponseContent(struct soap *soap, struct ns1__refreshPathResponseContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__refreshPathResponseContent);
  if (soap_out_PointerTons1__refreshPathResponseContent(soap, tag?tag:"ns1:refreshPathResponseContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__refreshPathResponseContent ** SOAP_FMAC4 soap_get_PointerTons1__refreshPathResponseContent(struct soap *soap, struct ns1__refreshPathResponseContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__refreshPathResponseContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__refreshPathContent(struct soap *soap, struct ns1__refreshPathContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__refreshPathContent))
    soap_serialize_ns1__refreshPathContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__refreshPathContent(struct soap *soap, const char *tag, int id, struct ns1__refreshPathContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__refreshPathContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__refreshPathContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__refreshPathContent ** SOAP_FMAC4 soap_in_PointerTons1__refreshPathContent(struct soap *soap, const char *tag, struct ns1__refreshPathContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__refreshPathContent **)soap_malloc(soap, sizeof(struct ns1__refreshPathContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__refreshPathContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__refreshPathContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__refreshPathContent, sizeof(struct ns1__refreshPathContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__refreshPathContent(struct soap *soap, struct ns1__refreshPathContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__refreshPathContent);
  if (soap_out_PointerTons1__refreshPathContent(soap, tag?tag:"ns1:refreshPathContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__refreshPathContent ** SOAP_FMAC4 soap_get_PointerTons1__refreshPathContent(struct soap *soap, struct ns1__refreshPathContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__refreshPathContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createPathResponseContent(struct soap *soap, struct ns1__createPathResponseContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createPathResponseContent))
    soap_serialize_ns1__createPathResponseContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createPathResponseContent(struct soap *soap, const char *tag, int id, struct ns1__createPathResponseContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createPathResponseContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__createPathResponseContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__createPathResponseContent ** SOAP_FMAC4 soap_in_PointerTons1__createPathResponseContent(struct soap *soap, const char *tag, struct ns1__createPathResponseContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__createPathResponseContent **)soap_malloc(soap, sizeof(struct ns1__createPathResponseContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__createPathResponseContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__createPathResponseContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createPathResponseContent, sizeof(struct ns1__createPathResponseContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createPathResponseContent(struct soap *soap, struct ns1__createPathResponseContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createPathResponseContent);
  if (soap_out_PointerTons1__createPathResponseContent(soap, tag?tag:"ns1:createPathResponseContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createPathResponseContent ** SOAP_FMAC4 soap_get_PointerTons1__createPathResponseContent(struct soap *soap, struct ns1__createPathResponseContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__createPathResponseContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createPathContent(struct soap *soap, struct ns1__createPathContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createPathContent))
    soap_serialize_ns1__createPathContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createPathContent(struct soap *soap, const char *tag, int id, struct ns1__createPathContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createPathContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__createPathContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__createPathContent ** SOAP_FMAC4 soap_in_PointerTons1__createPathContent(struct soap *soap, const char *tag, struct ns1__createPathContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__createPathContent **)soap_malloc(soap, sizeof(struct ns1__createPathContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__createPathContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__createPathContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createPathContent, sizeof(struct ns1__createPathContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createPathContent(struct soap *soap, struct ns1__createPathContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createPathContent);
  if (soap_out_PointerTons1__createPathContent(soap, tag?tag:"ns1:createPathContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createPathContent ** SOAP_FMAC4 soap_get_PointerTons1__createPathContent(struct soap *soap, struct ns1__createPathContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__createPathContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTopologyResponseContent(struct soap *soap, struct ns1__getTopologyResponseContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTopologyResponseContent))
    soap_serialize_ns1__getTopologyResponseContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTopologyResponseContent(struct soap *soap, const char *tag, int id, struct ns1__getTopologyResponseContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTopologyResponseContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__getTopologyResponseContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__getTopologyResponseContent ** SOAP_FMAC4 soap_in_PointerTons1__getTopologyResponseContent(struct soap *soap, const char *tag, struct ns1__getTopologyResponseContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__getTopologyResponseContent **)soap_malloc(soap, sizeof(struct ns1__getTopologyResponseContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__getTopologyResponseContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__getTopologyResponseContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTopologyResponseContent, sizeof(struct ns1__getTopologyResponseContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTopologyResponseContent(struct soap *soap, struct ns1__getTopologyResponseContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTopologyResponseContent);
  if (soap_out_PointerTons1__getTopologyResponseContent(soap, tag?tag:"ns1:getTopologyResponseContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTopologyResponseContent ** SOAP_FMAC4 soap_get_PointerTons1__getTopologyResponseContent(struct soap *soap, struct ns1__getTopologyResponseContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__getTopologyResponseContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTopologyContent(struct soap *soap, struct ns1__getTopologyContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTopologyContent))
    soap_serialize_ns1__getTopologyContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTopologyContent(struct soap *soap, const char *tag, int id, struct ns1__getTopologyContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTopologyContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__getTopologyContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__getTopologyContent ** SOAP_FMAC4 soap_in_PointerTons1__getTopologyContent(struct soap *soap, const char *tag, struct ns1__getTopologyContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__getTopologyContent **)soap_malloc(soap, sizeof(struct ns1__getTopologyContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__getTopologyContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__getTopologyContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTopologyContent, sizeof(struct ns1__getTopologyContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTopologyContent(struct soap *soap, struct ns1__getTopologyContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTopologyContent);
  if (soap_out_PointerTons1__getTopologyContent(soap, tag?tag:"ns1:getTopologyContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTopologyContent ** SOAP_FMAC4 soap_get_PointerTons1__getTopologyContent(struct soap *soap, struct ns1__getTopologyContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__getTopologyContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyResReply(struct soap *soap, struct ns1__modifyResReply *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyResReply))
    soap_serialize_ns1__modifyResReply(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyResReply(struct soap *soap, const char *tag, int id, struct ns1__modifyResReply *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyResReply);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__modifyResReply(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__modifyResReply ** SOAP_FMAC4 soap_in_PointerTons1__modifyResReply(struct soap *soap, const char *tag, struct ns1__modifyResReply **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__modifyResReply **)soap_malloc(soap, sizeof(struct ns1__modifyResReply *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__modifyResReply(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__modifyResReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyResReply, sizeof(struct ns1__modifyResReply), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyResReply(struct soap *soap, struct ns1__modifyResReply *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyResReply);
  if (soap_out_PointerTons1__modifyResReply(soap, tag?tag:"ns1:modifyResReply", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modifyResReply ** SOAP_FMAC4 soap_get_PointerTons1__modifyResReply(struct soap *soap, struct ns1__modifyResReply **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__modifyResReply(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__modifyResContent(struct soap *soap, struct ns1__modifyResContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__modifyResContent))
    soap_serialize_ns1__modifyResContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__modifyResContent(struct soap *soap, const char *tag, int id, struct ns1__modifyResContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__modifyResContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__modifyResContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__modifyResContent ** SOAP_FMAC4 soap_in_PointerTons1__modifyResContent(struct soap *soap, const char *tag, struct ns1__modifyResContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__modifyResContent **)soap_malloc(soap, sizeof(struct ns1__modifyResContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__modifyResContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__modifyResContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__modifyResContent, sizeof(struct ns1__modifyResContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__modifyResContent(struct soap *soap, struct ns1__modifyResContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__modifyResContent);
  if (soap_out_PointerTons1__modifyResContent(soap, tag?tag:"ns1:modifyResContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__modifyResContent ** SOAP_FMAC4 soap_get_PointerTons1__modifyResContent(struct soap *soap, struct ns1__modifyResContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__modifyResContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cancelResReply(struct soap *soap, struct ns1__cancelResReply *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cancelResReply))
    soap_serialize_ns1__cancelResReply(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cancelResReply(struct soap *soap, const char *tag, int id, struct ns1__cancelResReply *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cancelResReply);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__cancelResReply(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__cancelResReply ** SOAP_FMAC4 soap_in_PointerTons1__cancelResReply(struct soap *soap, const char *tag, struct ns1__cancelResReply **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__cancelResReply **)soap_malloc(soap, sizeof(struct ns1__cancelResReply *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__cancelResReply(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__cancelResReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cancelResReply, sizeof(struct ns1__cancelResReply), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cancelResReply(struct soap *soap, struct ns1__cancelResReply *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__cancelResReply);
  if (soap_out_PointerTons1__cancelResReply(soap, tag?tag:"ns1:cancelResReply", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelResReply ** SOAP_FMAC4 soap_get_PointerTons1__cancelResReply(struct soap *soap, struct ns1__cancelResReply **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__cancelResReply(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cancelResContent(struct soap *soap, struct ns1__cancelResContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cancelResContent))
    soap_serialize_ns1__cancelResContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cancelResContent(struct soap *soap, const char *tag, int id, struct ns1__cancelResContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cancelResContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__cancelResContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__cancelResContent ** SOAP_FMAC4 soap_in_PointerTons1__cancelResContent(struct soap *soap, const char *tag, struct ns1__cancelResContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__cancelResContent **)soap_malloc(soap, sizeof(struct ns1__cancelResContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__cancelResContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__cancelResContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cancelResContent, sizeof(struct ns1__cancelResContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cancelResContent(struct soap *soap, struct ns1__cancelResContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__cancelResContent);
  if (soap_out_PointerTons1__cancelResContent(soap, tag?tag:"ns1:cancelResContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelResContent ** SOAP_FMAC4 soap_get_PointerTons1__cancelResContent(struct soap *soap, struct ns1__cancelResContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__cancelResContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listReply(struct soap *soap, struct ns1__listReply *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listReply))
    soap_serialize_ns1__listReply(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listReply(struct soap *soap, const char *tag, int id, struct ns1__listReply *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listReply);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__listReply(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__listReply ** SOAP_FMAC4 soap_in_PointerTons1__listReply(struct soap *soap, const char *tag, struct ns1__listReply **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__listReply **)soap_malloc(soap, sizeof(struct ns1__listReply *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__listReply(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__listReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listReply, sizeof(struct ns1__listReply), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listReply(struct soap *soap, struct ns1__listReply *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listReply);
  if (soap_out_PointerTons1__listReply(soap, tag?tag:"ns1:listReply", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__listReply ** SOAP_FMAC4 soap_get_PointerTons1__listReply(struct soap *soap, struct ns1__listReply **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__listReply(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listRequest(struct soap *soap, struct ns1__listRequest *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listRequest))
    soap_serialize_ns1__listRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listRequest(struct soap *soap, const char *tag, int id, struct ns1__listRequest *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listRequest);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__listRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__listRequest ** SOAP_FMAC4 soap_in_PointerTons1__listRequest(struct soap *soap, const char *tag, struct ns1__listRequest **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__listRequest **)soap_malloc(soap, sizeof(struct ns1__listRequest *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__listRequest(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__listRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listRequest, sizeof(struct ns1__listRequest), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listRequest(struct soap *soap, struct ns1__listRequest *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listRequest);
  if (soap_out_PointerTons1__listRequest(soap, tag?tag:"ns1:listRequest", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__listRequest ** SOAP_FMAC4 soap_get_PointerTons1__listRequest(struct soap *soap, struct ns1__listRequest **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__listRequest(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__queryResReply(struct soap *soap, struct ns1__queryResReply *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__queryResReply))
    soap_serialize_ns1__queryResReply(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__queryResReply(struct soap *soap, const char *tag, int id, struct ns1__queryResReply *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__queryResReply);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__queryResReply(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__queryResReply ** SOAP_FMAC4 soap_in_PointerTons1__queryResReply(struct soap *soap, const char *tag, struct ns1__queryResReply **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__queryResReply **)soap_malloc(soap, sizeof(struct ns1__queryResReply *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__queryResReply(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__queryResReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__queryResReply, sizeof(struct ns1__queryResReply), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__queryResReply(struct soap *soap, struct ns1__queryResReply *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__queryResReply);
  if (soap_out_PointerTons1__queryResReply(soap, tag?tag:"ns1:queryResReply", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__queryResReply ** SOAP_FMAC4 soap_get_PointerTons1__queryResReply(struct soap *soap, struct ns1__queryResReply **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__queryResReply(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__queryResContent(struct soap *soap, struct ns1__queryResContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__queryResContent))
    soap_serialize_ns1__queryResContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__queryResContent(struct soap *soap, const char *tag, int id, struct ns1__queryResContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__queryResContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__queryResContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__queryResContent ** SOAP_FMAC4 soap_in_PointerTons1__queryResContent(struct soap *soap, const char *tag, struct ns1__queryResContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__queryResContent **)soap_malloc(soap, sizeof(struct ns1__queryResContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__queryResContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__queryResContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__queryResContent, sizeof(struct ns1__queryResContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__queryResContent(struct soap *soap, struct ns1__queryResContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__queryResContent);
  if (soap_out_PointerTons1__queryResContent(soap, tag?tag:"ns1:queryResContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__queryResContent ** SOAP_FMAC4 soap_get_PointerTons1__queryResContent(struct soap *soap, struct ns1__queryResContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__queryResContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createReply(struct soap *soap, struct ns1__createReply *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createReply))
    soap_serialize_ns1__createReply(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createReply(struct soap *soap, const char *tag, int id, struct ns1__createReply *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createReply);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__createReply(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__createReply ** SOAP_FMAC4 soap_in_PointerTons1__createReply(struct soap *soap, const char *tag, struct ns1__createReply **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__createReply **)soap_malloc(soap, sizeof(struct ns1__createReply *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__createReply(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__createReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createReply, sizeof(struct ns1__createReply), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createReply(struct soap *soap, struct ns1__createReply *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createReply);
  if (soap_out_PointerTons1__createReply(soap, tag?tag:"ns1:createReply", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createReply ** SOAP_FMAC4 soap_get_PointerTons1__createReply(struct soap *soap, struct ns1__createReply **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__createReply(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__resCreateContent(struct soap *soap, struct ns1__resCreateContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__resCreateContent))
    soap_serialize_ns1__resCreateContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__resCreateContent(struct soap *soap, const char *tag, int id, struct ns1__resCreateContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__resCreateContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__resCreateContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__resCreateContent ** SOAP_FMAC4 soap_in_PointerTons1__resCreateContent(struct soap *soap, const char *tag, struct ns1__resCreateContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__resCreateContent **)soap_malloc(soap, sizeof(struct ns1__resCreateContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__resCreateContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__resCreateContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__resCreateContent, sizeof(struct ns1__resCreateContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__resCreateContent(struct soap *soap, struct ns1__resCreateContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__resCreateContent);
  if (soap_out_PointerTons1__resCreateContent(soap, tag?tag:"ns1:resCreateContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__resCreateContent ** SOAP_FMAC4 soap_get_PointerTons1__resCreateContent(struct soap *soap, struct ns1__resCreateContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__resCreateContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__OSCARSFault(struct soap *soap, struct _ns2__OSCARSFault *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__ns2__OSCARSFault))
    soap_serialize__ns2__OSCARSFault(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__OSCARSFault(struct soap *soap, const char *tag, int id, struct _ns2__OSCARSFault *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__OSCARSFault);
  if (id < 0)
    return soap->error;
  return soap_out__ns2__OSCARSFault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__OSCARSFault ** SOAP_FMAC4 soap_in_PointerTo_ns2__OSCARSFault(struct soap *soap, const char *tag, struct _ns2__OSCARSFault **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _ns2__OSCARSFault **)soap_malloc(soap, sizeof(struct _ns2__OSCARSFault *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__ns2__OSCARSFault(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _ns2__OSCARSFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__OSCARSFault, sizeof(struct _ns2__OSCARSFault), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__OSCARSFault(struct soap *soap, struct _ns2__OSCARSFault *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__OSCARSFault);
  if (soap_out_PointerTo_ns2__OSCARSFault(soap, tag?tag:"ns2:OSCARSFault", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__OSCARSFault ** SOAP_FMAC4 soap_get_PointerTo_ns2__OSCARSFault(struct soap *soap, struct _ns2__OSCARSFault **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_ns2__OSCARSFault(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns8__union_AttributeStatementType(struct soap *soap, struct __ns8__union_AttributeStatementType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE___ns8__union_AttributeStatementType))
    soap_serialize___ns8__union_AttributeStatementType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns8__union_AttributeStatementType(struct soap *soap, const char *tag, int id, struct __ns8__union_AttributeStatementType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns8__union_AttributeStatementType);
  if (id < 0)
    return soap->error;
  return soap_out___ns8__union_AttributeStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns8__union_AttributeStatementType ** SOAP_FMAC4 soap_in_PointerTo__ns8__union_AttributeStatementType(struct soap *soap, const char *tag, struct __ns8__union_AttributeStatementType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct __ns8__union_AttributeStatementType **)soap_malloc(soap, sizeof(struct __ns8__union_AttributeStatementType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in___ns8__union_AttributeStatementType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct __ns8__union_AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns8__union_AttributeStatementType, sizeof(struct __ns8__union_AttributeStatementType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns8__union_AttributeStatementType(struct soap *soap, struct __ns8__union_AttributeStatementType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns8__union_AttributeStatementType);
  if (soap_out_PointerTo__ns8__union_AttributeStatementType(soap, tag?tag:"-ns8:union-AttributeStatementType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns8__union_AttributeStatementType ** SOAP_FMAC4 soap_get_PointerTo__ns8__union_AttributeStatementType(struct soap *soap, struct __ns8__union_AttributeStatementType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo__ns8__union_AttributeStatementType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__EvidenceType(struct soap *soap, struct ns8__EvidenceType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__EvidenceType))
    soap_serialize_ns8__EvidenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__EvidenceType(struct soap *soap, const char *tag, int id, struct ns8__EvidenceType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__EvidenceType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__EvidenceType ** SOAP_FMAC4 soap_in_PointerTons8__EvidenceType(struct soap *soap, const char *tag, struct ns8__EvidenceType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__EvidenceType **)soap_malloc(soap, sizeof(struct ns8__EvidenceType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__EvidenceType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__EvidenceType, sizeof(struct ns8__EvidenceType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__EvidenceType(struct soap *soap, struct ns8__EvidenceType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__EvidenceType);
  if (soap_out_PointerTons8__EvidenceType(soap, tag?tag:"ns8:EvidenceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__EvidenceType ** SOAP_FMAC4 soap_get_PointerTons8__EvidenceType(struct soap *soap, struct ns8__EvidenceType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__EvidenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons8__ActionType(struct soap *soap, struct ns8__ActionType **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons8__ActionType))
    soap_serialize_PointerTons8__ActionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons8__ActionType(struct soap *soap, const char *tag, int id, struct ns8__ActionType **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons8__ActionType);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons8__ActionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__ActionType *** SOAP_FMAC4 soap_in_PointerToPointerTons8__ActionType(struct soap *soap, const char *tag, struct ns8__ActionType ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__ActionType ***)soap_malloc(soap, sizeof(struct ns8__ActionType **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons8__ActionType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__ActionType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons8__ActionType, sizeof(struct ns8__ActionType *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons8__ActionType(struct soap *soap, struct ns8__ActionType **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons8__ActionType);
  if (soap_out_PointerToPointerTons8__ActionType(soap, tag?tag:"ns8:ActionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ActionType *** SOAP_FMAC4 soap_get_PointerToPointerTons8__ActionType(struct soap *soap, struct ns8__ActionType ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons8__ActionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__ActionType(struct soap *soap, struct ns8__ActionType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__ActionType))
    soap_serialize_ns8__ActionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__ActionType(struct soap *soap, const char *tag, int id, struct ns8__ActionType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__ActionType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__ActionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__ActionType ** SOAP_FMAC4 soap_in_PointerTons8__ActionType(struct soap *soap, const char *tag, struct ns8__ActionType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__ActionType **)soap_malloc(soap, sizeof(struct ns8__ActionType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__ActionType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__ActionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__ActionType, sizeof(struct ns8__ActionType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__ActionType(struct soap *soap, struct ns8__ActionType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__ActionType);
  if (soap_out_PointerTons8__ActionType(soap, tag?tag:"ns8:ActionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ActionType ** SOAP_FMAC4 soap_get_PointerTons8__ActionType(struct soap *soap, struct ns8__ActionType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__ActionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__AuthnContextType(struct soap *soap, struct ns8__AuthnContextType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__AuthnContextType))
    soap_serialize_ns8__AuthnContextType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__AuthnContextType(struct soap *soap, const char *tag, int id, struct ns8__AuthnContextType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__AuthnContextType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__AuthnContextType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__AuthnContextType ** SOAP_FMAC4 soap_in_PointerTons8__AuthnContextType(struct soap *soap, const char *tag, struct ns8__AuthnContextType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__AuthnContextType **)soap_malloc(soap, sizeof(struct ns8__AuthnContextType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__AuthnContextType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__AuthnContextType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__AuthnContextType, sizeof(struct ns8__AuthnContextType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__AuthnContextType(struct soap *soap, struct ns8__AuthnContextType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__AuthnContextType);
  if (soap_out_PointerTons8__AuthnContextType(soap, tag?tag:"ns8:AuthnContextType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AuthnContextType ** SOAP_FMAC4 soap_get_PointerTons8__AuthnContextType(struct soap *soap, struct ns8__AuthnContextType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__AuthnContextType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__SubjectLocalityType(struct soap *soap, struct ns8__SubjectLocalityType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__SubjectLocalityType))
    soap_serialize_ns8__SubjectLocalityType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__SubjectLocalityType(struct soap *soap, const char *tag, int id, struct ns8__SubjectLocalityType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__SubjectLocalityType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__SubjectLocalityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__SubjectLocalityType ** SOAP_FMAC4 soap_in_PointerTons8__SubjectLocalityType(struct soap *soap, const char *tag, struct ns8__SubjectLocalityType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__SubjectLocalityType **)soap_malloc(soap, sizeof(struct ns8__SubjectLocalityType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__SubjectLocalityType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__SubjectLocalityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__SubjectLocalityType, sizeof(struct ns8__SubjectLocalityType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__SubjectLocalityType(struct soap *soap, struct ns8__SubjectLocalityType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__SubjectLocalityType);
  if (soap_out_PointerTons8__SubjectLocalityType(soap, tag?tag:"ns8:SubjectLocalityType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__SubjectLocalityType ** SOAP_FMAC4 soap_get_PointerTons8__SubjectLocalityType(struct soap *soap, struct ns8__SubjectLocalityType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__SubjectLocalityType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_QName(struct soap *soap, char **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__QName))
    soap_serialize__QName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_QName(struct soap *soap, const char *tag, int id, char **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__QName);
  if (id < 0)
    return soap->error;
  return soap_out__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTo_QName(struct soap *soap, const char *tag, char ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__QName(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__QName, sizeof(char *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_QName(struct soap *soap, char **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_QName);
  if (soap_out_PointerTo_QName(soap, tag?tag:"byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTo_QName(struct soap *soap, char ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_QName(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns1__reservationResourceType_sequence(struct soap *soap, struct __ns1__reservationResourceType_sequence *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE___ns1__reservationResourceType_sequence))
    soap_serialize___ns1__reservationResourceType_sequence(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns1__reservationResourceType_sequence(struct soap *soap, const char *tag, int id, struct __ns1__reservationResourceType_sequence *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns1__reservationResourceType_sequence);
  if (id < 0)
    return soap->error;
  return soap_out___ns1__reservationResourceType_sequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns1__reservationResourceType_sequence ** SOAP_FMAC4 soap_in_PointerTo__ns1__reservationResourceType_sequence(struct soap *soap, const char *tag, struct __ns1__reservationResourceType_sequence **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct __ns1__reservationResourceType_sequence **)soap_malloc(soap, sizeof(struct __ns1__reservationResourceType_sequence *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in___ns1__reservationResourceType_sequence(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct __ns1__reservationResourceType_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns1__reservationResourceType_sequence, sizeof(struct __ns1__reservationResourceType_sequence), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns1__reservationResourceType_sequence(struct soap *soap, struct __ns1__reservationResourceType_sequence *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns1__reservationResourceType_sequence);
  if (soap_out_PointerTo__ns1__reservationResourceType_sequence(soap, tag?tag:"-ns1:reservationResourceType-sequence", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns1__reservationResourceType_sequence ** SOAP_FMAC4 soap_get_PointerTo__ns1__reservationResourceType_sequence(struct soap *soap, struct __ns1__reservationResourceType_sequence **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo__ns1__reservationResourceType_sequence(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns8__union_EvidenceType(struct soap *soap, struct __ns8__union_EvidenceType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE___ns8__union_EvidenceType))
    soap_serialize___ns8__union_EvidenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns8__union_EvidenceType(struct soap *soap, const char *tag, int id, struct __ns8__union_EvidenceType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns8__union_EvidenceType);
  if (id < 0)
    return soap->error;
  return soap_out___ns8__union_EvidenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns8__union_EvidenceType ** SOAP_FMAC4 soap_in_PointerTo__ns8__union_EvidenceType(struct soap *soap, const char *tag, struct __ns8__union_EvidenceType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct __ns8__union_EvidenceType **)soap_malloc(soap, sizeof(struct __ns8__union_EvidenceType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in___ns8__union_EvidenceType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct __ns8__union_EvidenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns8__union_EvidenceType, sizeof(struct __ns8__union_EvidenceType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns8__union_EvidenceType(struct soap *soap, struct __ns8__union_EvidenceType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns8__union_EvidenceType);
  if (soap_out_PointerTo__ns8__union_EvidenceType(soap, tag?tag:"-ns8:union-EvidenceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns8__union_EvidenceType ** SOAP_FMAC4 soap_get_PointerTo__ns8__union_EvidenceType(struct soap *soap, struct __ns8__union_EvidenceType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo__ns8__union_EvidenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns8__union_AdviceType(struct soap *soap, struct __ns8__union_AdviceType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE___ns8__union_AdviceType))
    soap_serialize___ns8__union_AdviceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns8__union_AdviceType(struct soap *soap, const char *tag, int id, struct __ns8__union_AdviceType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns8__union_AdviceType);
  if (id < 0)
    return soap->error;
  return soap_out___ns8__union_AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns8__union_AdviceType ** SOAP_FMAC4 soap_in_PointerTo__ns8__union_AdviceType(struct soap *soap, const char *tag, struct __ns8__union_AdviceType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct __ns8__union_AdviceType **)soap_malloc(soap, sizeof(struct __ns8__union_AdviceType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in___ns8__union_AdviceType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct __ns8__union_AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns8__union_AdviceType, sizeof(struct __ns8__union_AdviceType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns8__union_AdviceType(struct soap *soap, struct __ns8__union_AdviceType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns8__union_AdviceType);
  if (soap_out_PointerTo__ns8__union_AdviceType(soap, tag?tag:"-ns8:union-AdviceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns8__union_AdviceType ** SOAP_FMAC4 soap_get_PointerTo__ns8__union_AdviceType(struct soap *soap, struct __ns8__union_AdviceType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo__ns8__union_AdviceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__AssertionType(struct soap *soap, struct ns8__AssertionType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__AssertionType))
    soap_serialize_ns8__AssertionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__AssertionType(struct soap *soap, const char *tag, int id, struct ns8__AssertionType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__AssertionType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__AssertionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__AssertionType ** SOAP_FMAC4 soap_in_PointerTons8__AssertionType(struct soap *soap, const char *tag, struct ns8__AssertionType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__AssertionType **)soap_malloc(soap, sizeof(struct ns8__AssertionType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__AssertionType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__AssertionType, sizeof(struct ns8__AssertionType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__AssertionType(struct soap *soap, struct ns8__AssertionType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__AssertionType);
  if (soap_out_PointerTons8__AssertionType(soap, tag?tag:"ns8:AssertionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AssertionType ** SOAP_FMAC4 soap_get_PointerTons8__AssertionType(struct soap *soap, struct ns8__AssertionType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__AssertionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns8__union_ConditionsType(struct soap *soap, struct __ns8__union_ConditionsType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE___ns8__union_ConditionsType))
    soap_serialize___ns8__union_ConditionsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns8__union_ConditionsType(struct soap *soap, const char *tag, int id, struct __ns8__union_ConditionsType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns8__union_ConditionsType);
  if (id < 0)
    return soap->error;
  return soap_out___ns8__union_ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns8__union_ConditionsType ** SOAP_FMAC4 soap_in_PointerTo__ns8__union_ConditionsType(struct soap *soap, const char *tag, struct __ns8__union_ConditionsType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct __ns8__union_ConditionsType **)soap_malloc(soap, sizeof(struct __ns8__union_ConditionsType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in___ns8__union_ConditionsType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct __ns8__union_ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns8__union_ConditionsType, sizeof(struct __ns8__union_ConditionsType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns8__union_ConditionsType(struct soap *soap, struct __ns8__union_ConditionsType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns8__union_ConditionsType);
  if (soap_out_PointerTo__ns8__union_ConditionsType(soap, tag?tag:"-ns8:union-ConditionsType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns8__union_ConditionsType ** SOAP_FMAC4 soap_get_PointerTo__ns8__union_ConditionsType(struct soap *soap, struct __ns8__union_ConditionsType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo__ns8__union_ConditionsType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__ProxyRestrictionType(struct soap *soap, struct ns8__ProxyRestrictionType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__ProxyRestrictionType))
    soap_serialize_ns8__ProxyRestrictionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__ProxyRestrictionType(struct soap *soap, const char *tag, int id, struct ns8__ProxyRestrictionType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__ProxyRestrictionType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__ProxyRestrictionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__ProxyRestrictionType ** SOAP_FMAC4 soap_in_PointerTons8__ProxyRestrictionType(struct soap *soap, const char *tag, struct ns8__ProxyRestrictionType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__ProxyRestrictionType **)soap_malloc(soap, sizeof(struct ns8__ProxyRestrictionType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__ProxyRestrictionType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__ProxyRestrictionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__ProxyRestrictionType, sizeof(struct ns8__ProxyRestrictionType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__ProxyRestrictionType(struct soap *soap, struct ns8__ProxyRestrictionType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__ProxyRestrictionType);
  if (soap_out_PointerTons8__ProxyRestrictionType(soap, tag?tag:"ns8:ProxyRestrictionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ProxyRestrictionType ** SOAP_FMAC4 soap_get_PointerTons8__ProxyRestrictionType(struct soap *soap, struct ns8__ProxyRestrictionType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__ProxyRestrictionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__OneTimeUseType(struct soap *soap, struct ns8__OneTimeUseType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__OneTimeUseType))
    soap_serialize_ns8__OneTimeUseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__OneTimeUseType(struct soap *soap, const char *tag, int id, struct ns8__OneTimeUseType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__OneTimeUseType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__OneTimeUseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__OneTimeUseType ** SOAP_FMAC4 soap_in_PointerTons8__OneTimeUseType(struct soap *soap, const char *tag, struct ns8__OneTimeUseType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__OneTimeUseType **)soap_malloc(soap, sizeof(struct ns8__OneTimeUseType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__OneTimeUseType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__OneTimeUseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__OneTimeUseType, sizeof(struct ns8__OneTimeUseType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__OneTimeUseType(struct soap *soap, struct ns8__OneTimeUseType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__OneTimeUseType);
  if (soap_out_PointerTons8__OneTimeUseType(soap, tag?tag:"ns8:OneTimeUseType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__OneTimeUseType ** SOAP_FMAC4 soap_get_PointerTons8__OneTimeUseType(struct soap *soap, struct ns8__OneTimeUseType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__OneTimeUseType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__AudienceRestrictionType(struct soap *soap, struct ns8__AudienceRestrictionType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__AudienceRestrictionType))
    soap_serialize_ns8__AudienceRestrictionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__AudienceRestrictionType(struct soap *soap, const char *tag, int id, struct ns8__AudienceRestrictionType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__AudienceRestrictionType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__AudienceRestrictionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__AudienceRestrictionType ** SOAP_FMAC4 soap_in_PointerTons8__AudienceRestrictionType(struct soap *soap, const char *tag, struct ns8__AudienceRestrictionType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__AudienceRestrictionType **)soap_malloc(soap, sizeof(struct ns8__AudienceRestrictionType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__AudienceRestrictionType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__AudienceRestrictionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__AudienceRestrictionType, sizeof(struct ns8__AudienceRestrictionType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__AudienceRestrictionType(struct soap *soap, struct ns8__AudienceRestrictionType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__AudienceRestrictionType);
  if (soap_out_PointerTons8__AudienceRestrictionType(soap, tag?tag:"ns8:AudienceRestrictionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AudienceRestrictionType ** SOAP_FMAC4 soap_get_PointerTons8__AudienceRestrictionType(struct soap *soap, struct ns8__AudienceRestrictionType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__AudienceRestrictionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__ConditionAbstractType(struct soap *soap, struct ns8__ConditionAbstractType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__ConditionAbstractType))
    soap_serialize_ns8__ConditionAbstractType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__ConditionAbstractType(struct soap *soap, const char *tag, int id, struct ns8__ConditionAbstractType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__ConditionAbstractType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__ConditionAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__ConditionAbstractType ** SOAP_FMAC4 soap_in_PointerTons8__ConditionAbstractType(struct soap *soap, const char *tag, struct ns8__ConditionAbstractType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__ConditionAbstractType **)soap_malloc(soap, sizeof(struct ns8__ConditionAbstractType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__ConditionAbstractType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__ConditionAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__ConditionAbstractType, sizeof(struct ns8__ConditionAbstractType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__ConditionAbstractType(struct soap *soap, struct ns8__ConditionAbstractType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__ConditionAbstractType);
  if (soap_out_PointerTons8__ConditionAbstractType(soap, tag?tag:"ns8:ConditionAbstractType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ConditionAbstractType ** SOAP_FMAC4 soap_get_PointerTons8__ConditionAbstractType(struct soap *soap, struct ns8__ConditionAbstractType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__ConditionAbstractType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__SubjectConfirmationDataType(struct soap *soap, struct ns8__SubjectConfirmationDataType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__SubjectConfirmationDataType))
    soap_serialize_ns8__SubjectConfirmationDataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__SubjectConfirmationDataType(struct soap *soap, const char *tag, int id, struct ns8__SubjectConfirmationDataType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__SubjectConfirmationDataType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__SubjectConfirmationDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__SubjectConfirmationDataType ** SOAP_FMAC4 soap_in_PointerTons8__SubjectConfirmationDataType(struct soap *soap, const char *tag, struct ns8__SubjectConfirmationDataType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__SubjectConfirmationDataType **)soap_malloc(soap, sizeof(struct ns8__SubjectConfirmationDataType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__SubjectConfirmationDataType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__SubjectConfirmationDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__SubjectConfirmationDataType, sizeof(struct ns8__SubjectConfirmationDataType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__SubjectConfirmationDataType(struct soap *soap, struct ns8__SubjectConfirmationDataType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__SubjectConfirmationDataType);
  if (soap_out_PointerTons8__SubjectConfirmationDataType(soap, tag?tag:"ns8:SubjectConfirmationDataType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__SubjectConfirmationDataType ** SOAP_FMAC4 soap_get_PointerTons8__SubjectConfirmationDataType(struct soap *soap, struct ns8__SubjectConfirmationDataType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__SubjectConfirmationDataType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons8__SubjectConfirmationType(struct soap *soap, struct ns8__SubjectConfirmationType **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons8__SubjectConfirmationType))
    soap_serialize_PointerTons8__SubjectConfirmationType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons8__SubjectConfirmationType(struct soap *soap, const char *tag, int id, struct ns8__SubjectConfirmationType **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons8__SubjectConfirmationType);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons8__SubjectConfirmationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__SubjectConfirmationType *** SOAP_FMAC4 soap_in_PointerToPointerTons8__SubjectConfirmationType(struct soap *soap, const char *tag, struct ns8__SubjectConfirmationType ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__SubjectConfirmationType ***)soap_malloc(soap, sizeof(struct ns8__SubjectConfirmationType **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons8__SubjectConfirmationType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__SubjectConfirmationType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons8__SubjectConfirmationType, sizeof(struct ns8__SubjectConfirmationType *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons8__SubjectConfirmationType(struct soap *soap, struct ns8__SubjectConfirmationType **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons8__SubjectConfirmationType);
  if (soap_out_PointerToPointerTons8__SubjectConfirmationType(soap, tag?tag:"ns8:SubjectConfirmationType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__SubjectConfirmationType *** SOAP_FMAC4 soap_get_PointerToPointerTons8__SubjectConfirmationType(struct soap *soap, struct ns8__SubjectConfirmationType ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons8__SubjectConfirmationType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__SubjectConfirmationType(struct soap *soap, struct ns8__SubjectConfirmationType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__SubjectConfirmationType))
    soap_serialize_ns8__SubjectConfirmationType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__SubjectConfirmationType(struct soap *soap, const char *tag, int id, struct ns8__SubjectConfirmationType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__SubjectConfirmationType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__SubjectConfirmationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__SubjectConfirmationType ** SOAP_FMAC4 soap_in_PointerTons8__SubjectConfirmationType(struct soap *soap, const char *tag, struct ns8__SubjectConfirmationType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__SubjectConfirmationType **)soap_malloc(soap, sizeof(struct ns8__SubjectConfirmationType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__SubjectConfirmationType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__SubjectConfirmationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__SubjectConfirmationType, sizeof(struct ns8__SubjectConfirmationType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__SubjectConfirmationType(struct soap *soap, struct ns8__SubjectConfirmationType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__SubjectConfirmationType);
  if (soap_out_PointerTons8__SubjectConfirmationType(soap, tag?tag:"ns8:SubjectConfirmationType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__SubjectConfirmationType ** SOAP_FMAC4 soap_get_PointerTons8__SubjectConfirmationType(struct soap *soap, struct ns8__SubjectConfirmationType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__SubjectConfirmationType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__EncryptedElementType(struct soap *soap, struct ns8__EncryptedElementType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__EncryptedElementType))
    soap_serialize_ns8__EncryptedElementType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__EncryptedElementType(struct soap *soap, const char *tag, int id, struct ns8__EncryptedElementType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__EncryptedElementType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__EncryptedElementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__EncryptedElementType ** SOAP_FMAC4 soap_in_PointerTons8__EncryptedElementType(struct soap *soap, const char *tag, struct ns8__EncryptedElementType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__EncryptedElementType **)soap_malloc(soap, sizeof(struct ns8__EncryptedElementType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__EncryptedElementType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__EncryptedElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__EncryptedElementType, sizeof(struct ns8__EncryptedElementType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__EncryptedElementType(struct soap *soap, struct ns8__EncryptedElementType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__EncryptedElementType);
  if (soap_out_PointerTons8__EncryptedElementType(soap, tag?tag:"ns8:EncryptedElementType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__EncryptedElementType ** SOAP_FMAC4 soap_get_PointerTons8__EncryptedElementType(struct soap *soap, struct ns8__EncryptedElementType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__EncryptedElementType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__BaseIDAbstractType(struct soap *soap, struct ns8__BaseIDAbstractType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__BaseIDAbstractType))
    soap_serialize_ns8__BaseIDAbstractType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__BaseIDAbstractType(struct soap *soap, const char *tag, int id, struct ns8__BaseIDAbstractType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__BaseIDAbstractType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__BaseIDAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__BaseIDAbstractType ** SOAP_FMAC4 soap_in_PointerTons8__BaseIDAbstractType(struct soap *soap, const char *tag, struct ns8__BaseIDAbstractType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__BaseIDAbstractType **)soap_malloc(soap, sizeof(struct ns8__BaseIDAbstractType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__BaseIDAbstractType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__BaseIDAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__BaseIDAbstractType, sizeof(struct ns8__BaseIDAbstractType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__BaseIDAbstractType(struct soap *soap, struct ns8__BaseIDAbstractType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__BaseIDAbstractType);
  if (soap_out_PointerTons8__BaseIDAbstractType(soap, tag?tag:"ns8:BaseIDAbstractType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__BaseIDAbstractType ** SOAP_FMAC4 soap_get_PointerTons8__BaseIDAbstractType(struct soap *soap, struct ns8__BaseIDAbstractType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__BaseIDAbstractType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns8__union_AssertionType(struct soap *soap, struct __ns8__union_AssertionType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE___ns8__union_AssertionType))
    soap_serialize___ns8__union_AssertionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns8__union_AssertionType(struct soap *soap, const char *tag, int id, struct __ns8__union_AssertionType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns8__union_AssertionType);
  if (id < 0)
    return soap->error;
  return soap_out___ns8__union_AssertionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns8__union_AssertionType ** SOAP_FMAC4 soap_in_PointerTo__ns8__union_AssertionType(struct soap *soap, const char *tag, struct __ns8__union_AssertionType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct __ns8__union_AssertionType **)soap_malloc(soap, sizeof(struct __ns8__union_AssertionType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in___ns8__union_AssertionType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct __ns8__union_AssertionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns8__union_AssertionType, sizeof(struct __ns8__union_AssertionType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns8__union_AssertionType(struct soap *soap, struct __ns8__union_AssertionType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns8__union_AssertionType);
  if (soap_out_PointerTo__ns8__union_AssertionType(soap, tag?tag:"-ns8:union-AssertionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns8__union_AssertionType ** SOAP_FMAC4 soap_get_PointerTo__ns8__union_AssertionType(struct soap *soap, struct __ns8__union_AssertionType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo__ns8__union_AssertionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__AttributeStatementType(struct soap *soap, struct ns8__AttributeStatementType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__AttributeStatementType))
    soap_serialize_ns8__AttributeStatementType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__AttributeStatementType(struct soap *soap, const char *tag, int id, struct ns8__AttributeStatementType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__AttributeStatementType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__AttributeStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__AttributeStatementType ** SOAP_FMAC4 soap_in_PointerTons8__AttributeStatementType(struct soap *soap, const char *tag, struct ns8__AttributeStatementType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__AttributeStatementType **)soap_malloc(soap, sizeof(struct ns8__AttributeStatementType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__AttributeStatementType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__AttributeStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__AttributeStatementType, sizeof(struct ns8__AttributeStatementType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__AttributeStatementType(struct soap *soap, struct ns8__AttributeStatementType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__AttributeStatementType);
  if (soap_out_PointerTons8__AttributeStatementType(soap, tag?tag:"ns8:AttributeStatementType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AttributeStatementType ** SOAP_FMAC4 soap_get_PointerTons8__AttributeStatementType(struct soap *soap, struct ns8__AttributeStatementType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__AttributeStatementType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__AuthzDecisionStatementType(struct soap *soap, struct ns8__AuthzDecisionStatementType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__AuthzDecisionStatementType))
    soap_serialize_ns8__AuthzDecisionStatementType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__AuthzDecisionStatementType(struct soap *soap, const char *tag, int id, struct ns8__AuthzDecisionStatementType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__AuthzDecisionStatementType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__AuthzDecisionStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__AuthzDecisionStatementType ** SOAP_FMAC4 soap_in_PointerTons8__AuthzDecisionStatementType(struct soap *soap, const char *tag, struct ns8__AuthzDecisionStatementType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__AuthzDecisionStatementType **)soap_malloc(soap, sizeof(struct ns8__AuthzDecisionStatementType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__AuthzDecisionStatementType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__AuthzDecisionStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__AuthzDecisionStatementType, sizeof(struct ns8__AuthzDecisionStatementType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__AuthzDecisionStatementType(struct soap *soap, struct ns8__AuthzDecisionStatementType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__AuthzDecisionStatementType);
  if (soap_out_PointerTons8__AuthzDecisionStatementType(soap, tag?tag:"ns8:AuthzDecisionStatementType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AuthzDecisionStatementType ** SOAP_FMAC4 soap_get_PointerTons8__AuthzDecisionStatementType(struct soap *soap, struct ns8__AuthzDecisionStatementType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__AuthzDecisionStatementType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__AuthnStatementType(struct soap *soap, struct ns8__AuthnStatementType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__AuthnStatementType))
    soap_serialize_ns8__AuthnStatementType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__AuthnStatementType(struct soap *soap, const char *tag, int id, struct ns8__AuthnStatementType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__AuthnStatementType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__AuthnStatementType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__AuthnStatementType ** SOAP_FMAC4 soap_in_PointerTons8__AuthnStatementType(struct soap *soap, const char *tag, struct ns8__AuthnStatementType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__AuthnStatementType **)soap_malloc(soap, sizeof(struct ns8__AuthnStatementType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__AuthnStatementType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__AuthnStatementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__AuthnStatementType, sizeof(struct ns8__AuthnStatementType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__AuthnStatementType(struct soap *soap, struct ns8__AuthnStatementType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__AuthnStatementType);
  if (soap_out_PointerTons8__AuthnStatementType(soap, tag?tag:"ns8:AuthnStatementType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AuthnStatementType ** SOAP_FMAC4 soap_get_PointerTons8__AuthnStatementType(struct soap *soap, struct ns8__AuthnStatementType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__AuthnStatementType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__StatementAbstractType(struct soap *soap, struct ns8__StatementAbstractType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__StatementAbstractType))
    soap_serialize_ns8__StatementAbstractType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__StatementAbstractType(struct soap *soap, const char *tag, int id, struct ns8__StatementAbstractType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__StatementAbstractType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__StatementAbstractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__StatementAbstractType ** SOAP_FMAC4 soap_in_PointerTons8__StatementAbstractType(struct soap *soap, const char *tag, struct ns8__StatementAbstractType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__StatementAbstractType **)soap_malloc(soap, sizeof(struct ns8__StatementAbstractType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__StatementAbstractType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__StatementAbstractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__StatementAbstractType, sizeof(struct ns8__StatementAbstractType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__StatementAbstractType(struct soap *soap, struct ns8__StatementAbstractType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__StatementAbstractType);
  if (soap_out_PointerTons8__StatementAbstractType(soap, tag?tag:"ns8:StatementAbstractType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__StatementAbstractType ** SOAP_FMAC4 soap_get_PointerTons8__StatementAbstractType(struct soap *soap, struct ns8__StatementAbstractType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__StatementAbstractType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__AdviceType(struct soap *soap, struct ns8__AdviceType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__AdviceType))
    soap_serialize_ns8__AdviceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__AdviceType(struct soap *soap, const char *tag, int id, struct ns8__AdviceType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__AdviceType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__AdviceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__AdviceType ** SOAP_FMAC4 soap_in_PointerTons8__AdviceType(struct soap *soap, const char *tag, struct ns8__AdviceType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__AdviceType **)soap_malloc(soap, sizeof(struct ns8__AdviceType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__AdviceType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__AdviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__AdviceType, sizeof(struct ns8__AdviceType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__AdviceType(struct soap *soap, struct ns8__AdviceType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__AdviceType);
  if (soap_out_PointerTons8__AdviceType(soap, tag?tag:"ns8:AdviceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AdviceType ** SOAP_FMAC4 soap_get_PointerTons8__AdviceType(struct soap *soap, struct ns8__AdviceType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__AdviceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__ConditionsType(struct soap *soap, struct ns8__ConditionsType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__ConditionsType))
    soap_serialize_ns8__ConditionsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__ConditionsType(struct soap *soap, const char *tag, int id, struct ns8__ConditionsType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__ConditionsType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__ConditionsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__ConditionsType ** SOAP_FMAC4 soap_in_PointerTons8__ConditionsType(struct soap *soap, const char *tag, struct ns8__ConditionsType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__ConditionsType **)soap_malloc(soap, sizeof(struct ns8__ConditionsType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__ConditionsType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__ConditionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__ConditionsType, sizeof(struct ns8__ConditionsType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__ConditionsType(struct soap *soap, struct ns8__ConditionsType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__ConditionsType);
  if (soap_out_PointerTons8__ConditionsType(soap, tag?tag:"ns8:ConditionsType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ConditionsType ** SOAP_FMAC4 soap_get_PointerTons8__ConditionsType(struct soap *soap, struct ns8__ConditionsType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__ConditionsType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__SubjectType(struct soap *soap, struct ns8__SubjectType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__SubjectType))
    soap_serialize_ns8__SubjectType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__SubjectType(struct soap *soap, const char *tag, int id, struct ns8__SubjectType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__SubjectType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__SubjectType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__SubjectType ** SOAP_FMAC4 soap_in_PointerTons8__SubjectType(struct soap *soap, const char *tag, struct ns8__SubjectType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__SubjectType **)soap_malloc(soap, sizeof(struct ns8__SubjectType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__SubjectType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__SubjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__SubjectType, sizeof(struct ns8__SubjectType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__SubjectType(struct soap *soap, struct ns8__SubjectType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__SubjectType);
  if (soap_out_PointerTons8__SubjectType(soap, tag?tag:"ns8:SubjectType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__SubjectType ** SOAP_FMAC4 soap_get_PointerTons8__SubjectType(struct soap *soap, struct ns8__SubjectType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__SubjectType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__Signature(struct soap *soap, struct ds__SignatureType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__ds__Signature))
    soap_serialize__ds__Signature(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__Signature(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__Signature);
  if (id < 0)
    return soap->error;
  return soap_out__ds__Signature(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTo_ds__Signature(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__ds__Signature(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__Signature, sizeof(struct ds__SignatureType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__Signature(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ds__Signature);
  if (soap_out_PointerTo_ds__Signature(soap, tag?tag:"ds:Signature", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTo_ds__Signature(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_ds__Signature(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__NameIDType(struct soap *soap, struct ns8__NameIDType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__NameIDType))
    soap_serialize_ns8__NameIDType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__NameIDType(struct soap *soap, const char *tag, int id, struct ns8__NameIDType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__NameIDType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__NameIDType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__NameIDType ** SOAP_FMAC4 soap_in_PointerTons8__NameIDType(struct soap *soap, const char *tag, struct ns8__NameIDType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__NameIDType **)soap_malloc(soap, sizeof(struct ns8__NameIDType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__NameIDType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__NameIDType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__NameIDType, sizeof(struct ns8__NameIDType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__NameIDType(struct soap *soap, struct ns8__NameIDType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__NameIDType);
  if (soap_out_PointerTons8__NameIDType(soap, tag?tag:"ns8:NameIDType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__NameIDType ** SOAP_FMAC4 soap_get_PointerTons8__NameIDType(struct soap *soap, struct ns8__NameIDType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__NameIDType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xenc__EncryptedKey(struct soap *soap, struct xenc__EncryptedKeyType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__xenc__EncryptedKey))
    soap_serialize__xenc__EncryptedKey(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xenc__EncryptedKey(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xenc__EncryptedKey);
  if (id < 0)
    return soap->error;
  return soap_out__xenc__EncryptedKey(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_in_PointerTo_xenc__EncryptedKey(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct xenc__EncryptedKeyType **)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__xenc__EncryptedKey(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct xenc__EncryptedKeyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xenc__EncryptedKey, sizeof(struct xenc__EncryptedKeyType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xenc__EncryptedKey(struct soap *soap, struct xenc__EncryptedKeyType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xenc__EncryptedKey);
  if (soap_out_PointerTo_xenc__EncryptedKey(soap, tag?tag:"xenc:EncryptedKey", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_get_PointerTo_xenc__EncryptedKey(struct soap *soap, struct xenc__EncryptedKeyType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_xenc__EncryptedKey(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__FaultCauseType(struct soap *soap, struct ns7__FaultCauseType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns7__FaultCauseType))
    soap_serialize_ns7__FaultCauseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__FaultCauseType(struct soap *soap, const char *tag, int id, struct ns7__FaultCauseType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__FaultCauseType);
  if (id < 0)
    return soap->error;
  return soap_out_ns7__FaultCauseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns7__FaultCauseType ** SOAP_FMAC4 soap_in_PointerTons7__FaultCauseType(struct soap *soap, const char *tag, struct ns7__FaultCauseType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns7__FaultCauseType **)soap_malloc(soap, sizeof(struct ns7__FaultCauseType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns7__FaultCauseType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns7__FaultCauseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__FaultCauseType, sizeof(struct ns7__FaultCauseType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__FaultCauseType(struct soap *soap, struct ns7__FaultCauseType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__FaultCauseType);
  if (soap_out_PointerTons7__FaultCauseType(soap, tag?tag:"ns7:FaultCauseType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__FaultCauseType ** SOAP_FMAC4 soap_get_PointerTons7__FaultCauseType(struct soap *soap, struct ns7__FaultCauseType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons7__FaultCauseType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ErrorCodeType(struct soap *soap, struct ns7__ErrorCodeType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ErrorCodeType))
    soap_serialize_ns7__ErrorCodeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ErrorCodeType(struct soap *soap, const char *tag, int id, struct ns7__ErrorCodeType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ErrorCodeType);
  if (id < 0)
    return soap->error;
  return soap_out_ns7__ErrorCodeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns7__ErrorCodeType ** SOAP_FMAC4 soap_in_PointerTons7__ErrorCodeType(struct soap *soap, const char *tag, struct ns7__ErrorCodeType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns7__ErrorCodeType **)soap_malloc(soap, sizeof(struct ns7__ErrorCodeType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns7__ErrorCodeType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns7__ErrorCodeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ErrorCodeType, sizeof(struct ns7__ErrorCodeType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ErrorCodeType(struct soap *soap, struct ns7__ErrorCodeType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ErrorCodeType);
  if (soap_out_PointerTons7__ErrorCodeType(soap, tag?tag:"ns7:ErrorCodeType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__ErrorCodeType ** SOAP_FMAC4 soap_get_PointerTons7__ErrorCodeType(struct soap *soap, struct ns7__ErrorCodeType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons7__ErrorCodeType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__authConditionType(struct soap *soap, struct ns6__authConditionType **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__authConditionType))
    soap_serialize_PointerTons6__authConditionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons6__authConditionType(struct soap *soap, const char *tag, int id, struct ns6__authConditionType **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__authConditionType);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons6__authConditionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__authConditionType *** SOAP_FMAC4 soap_in_PointerToPointerTons6__authConditionType(struct soap *soap, const char *tag, struct ns6__authConditionType ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns6__authConditionType ***)soap_malloc(soap, sizeof(struct ns6__authConditionType **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons6__authConditionType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns6__authConditionType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__authConditionType, sizeof(struct ns6__authConditionType *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__authConditionType(struct soap *soap, struct ns6__authConditionType **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__authConditionType);
  if (soap_out_PointerToPointerTons6__authConditionType(soap, tag?tag:"ns6:authConditionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__authConditionType *** SOAP_FMAC4 soap_get_PointerToPointerTons6__authConditionType(struct soap *soap, struct ns6__authConditionType ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons6__authConditionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__authConditionType(struct soap *soap, struct ns6__authConditionType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns6__authConditionType))
    soap_serialize_ns6__authConditionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__authConditionType(struct soap *soap, const char *tag, int id, struct ns6__authConditionType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__authConditionType);
  if (id < 0)
    return soap->error;
  return soap_out_ns6__authConditionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__authConditionType ** SOAP_FMAC4 soap_in_PointerTons6__authConditionType(struct soap *soap, const char *tag, struct ns6__authConditionType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns6__authConditionType **)soap_malloc(soap, sizeof(struct ns6__authConditionType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns6__authConditionType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns6__authConditionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__authConditionType, sizeof(struct ns6__authConditionType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__authConditionType(struct soap *soap, struct ns6__authConditionType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__authConditionType);
  if (soap_out_PointerTons6__authConditionType(soap, tag?tag:"ns6:authConditionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__authConditionType ** SOAP_FMAC4 soap_get_PointerTons6__authConditionType(struct soap *soap, struct ns6__authConditionType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons6__authConditionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons8__AttributeType(struct soap *soap, struct ns8__AttributeType **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons8__AttributeType))
    soap_serialize_PointerTons8__AttributeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons8__AttributeType(struct soap *soap, const char *tag, int id, struct ns8__AttributeType **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons8__AttributeType);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons8__AttributeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__AttributeType *** SOAP_FMAC4 soap_in_PointerToPointerTons8__AttributeType(struct soap *soap, const char *tag, struct ns8__AttributeType ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__AttributeType ***)soap_malloc(soap, sizeof(struct ns8__AttributeType **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons8__AttributeType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__AttributeType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons8__AttributeType, sizeof(struct ns8__AttributeType *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons8__AttributeType(struct soap *soap, struct ns8__AttributeType **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons8__AttributeType);
  if (soap_out_PointerToPointerTons8__AttributeType(soap, tag?tag:"ns8:AttributeType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AttributeType *** SOAP_FMAC4 soap_get_PointerToPointerTons8__AttributeType(struct soap *soap, struct ns8__AttributeType ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons8__AttributeType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__AttributeType(struct soap *soap, struct ns8__AttributeType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns8__AttributeType))
    soap_serialize_ns8__AttributeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__AttributeType(struct soap *soap, const char *tag, int id, struct ns8__AttributeType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__AttributeType);
  if (id < 0)
    return soap->error;
  return soap_out_ns8__AttributeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__AttributeType ** SOAP_FMAC4 soap_in_PointerTons8__AttributeType(struct soap *soap, const char *tag, struct ns8__AttributeType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns8__AttributeType **)soap_malloc(soap, sizeof(struct ns8__AttributeType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns8__AttributeType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns8__AttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__AttributeType, sizeof(struct ns8__AttributeType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__AttributeType(struct soap *soap, struct ns8__AttributeType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__AttributeType);
  if (soap_out_PointerTons8__AttributeType(soap, tag?tag:"ns8:AttributeType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__AttributeType ** SOAP_FMAC4 soap_get_PointerTons8__AttributeType(struct soap *soap, struct ns8__AttributeType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons8__AttributeType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__subjectAttributes(struct soap *soap, struct ns6__subjectAttributes *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns6__subjectAttributes))
    soap_serialize_ns6__subjectAttributes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__subjectAttributes(struct soap *soap, const char *tag, int id, struct ns6__subjectAttributes *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__subjectAttributes);
  if (id < 0)
    return soap->error;
  return soap_out_ns6__subjectAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__subjectAttributes ** SOAP_FMAC4 soap_in_PointerTons6__subjectAttributes(struct soap *soap, const char *tag, struct ns6__subjectAttributes **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns6__subjectAttributes **)soap_malloc(soap, sizeof(struct ns6__subjectAttributes *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns6__subjectAttributes(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns6__subjectAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__subjectAttributes, sizeof(struct ns6__subjectAttributes), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__subjectAttributes(struct soap *soap, struct ns6__subjectAttributes *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__subjectAttributes);
  if (soap_out_PointerTons6__subjectAttributes(soap, tag?tag:"ns6:subjectAttributes", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__subjectAttributes ** SOAP_FMAC4 soap_get_PointerTons6__subjectAttributes(struct soap *soap, struct ns6__subjectAttributes **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons6__subjectAttributes(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean_(struct soap *soap, enum xsd__boolean_ *const*a) {
  soap_reference(soap, *a, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean_(struct soap *soap, const char *tag, int id, enum xsd__boolean_ *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean_);
  if (id < 0)
    return soap->error;
  return soap_out_xsd__boolean_(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean_ ** SOAP_FMAC4 soap_in_PointerToxsd__boolean_(struct soap *soap, const char *tag, enum xsd__boolean_ **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (enum xsd__boolean_ **)soap_malloc(soap, sizeof(enum xsd__boolean_ *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_xsd__boolean_(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (enum xsd__boolean_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean_, sizeof(enum xsd__boolean_), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean_(struct soap *soap, enum xsd__boolean_ *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean_);
  if (soap_out_PointerToxsd__boolean_(soap, tag?tag:"xsd:boolean", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean_ ** SOAP_FMAC4 soap_get_PointerToxsd__boolean_(struct soap *soap, enum xsd__boolean_ **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToxsd__boolean_(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo))
    soap_serialize_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, const char *tag, struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo **)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlaneSwitchingCapabilitySpecificInfo, sizeof(struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo);
  if (soap_out_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag?tag:"ns5:CtrlPlaneSwitchingCapabilitySpecificInfo", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(struct soap *soap, struct ns5__CtrlPlaneSwitchingCapabilitySpecificInfo **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlaneSwitchingCapabilitySpecificInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__Duration(struct soap *soap, struct ns5__Duration *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__Duration))
    soap_serialize_ns5__Duration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__Duration(struct soap *soap, const char *tag, int id, struct ns5__Duration *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__Duration);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__Duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__Duration ** SOAP_FMAC4 soap_in_PointerTons5__Duration(struct soap *soap, const char *tag, struct ns5__Duration **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__Duration **)soap_malloc(soap, sizeof(struct ns5__Duration *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__Duration(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__Duration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Duration, sizeof(struct ns5__Duration), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__Duration(struct soap *soap, struct ns5__Duration *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__Duration);
  if (soap_out_PointerTons5__Duration(soap, tag?tag:"ns5:Duration", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__Duration ** SOAP_FMAC4 soap_get_PointerTons5__Duration(struct soap *soap, struct ns5__Duration **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__Duration(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__TimeContent(struct soap *soap, struct ns5__TimeContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__TimeContent))
    soap_serialize_ns5__TimeContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__TimeContent(struct soap *soap, const char *tag, int id, struct ns5__TimeContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__TimeContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__TimeContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__TimeContent ** SOAP_FMAC4 soap_in_PointerTons5__TimeContent(struct soap *soap, const char *tag, struct ns5__TimeContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__TimeContent **)soap_malloc(soap, sizeof(struct ns5__TimeContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__TimeContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__TimeContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__TimeContent, sizeof(struct ns5__TimeContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__TimeContent(struct soap *soap, struct ns5__TimeContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__TimeContent);
  if (soap_out_PointerTons5__TimeContent(soap, tag?tag:"ns5:TimeContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__TimeContent ** SOAP_FMAC4 soap_get_PointerTons5__TimeContent(struct soap *soap, struct ns5__TimeContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__TimeContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons5__CtrlPlaneNextHopContent(struct soap *soap, struct ns5__CtrlPlaneNextHopContent **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons5__CtrlPlaneNextHopContent))
    soap_serialize_PointerTons5__CtrlPlaneNextHopContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons5__CtrlPlaneNextHopContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneNextHopContent **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons5__CtrlPlaneNextHopContent);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons5__CtrlPlaneNextHopContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneNextHopContent *** SOAP_FMAC4 soap_in_PointerToPointerTons5__CtrlPlaneNextHopContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneNextHopContent ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneNextHopContent ***)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneNextHopContent **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons5__CtrlPlaneNextHopContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneNextHopContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons5__CtrlPlaneNextHopContent, sizeof(struct ns5__CtrlPlaneNextHopContent *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons5__CtrlPlaneNextHopContent(struct soap *soap, struct ns5__CtrlPlaneNextHopContent **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons5__CtrlPlaneNextHopContent);
  if (soap_out_PointerToPointerTons5__CtrlPlaneNextHopContent(soap, tag?tag:"ns5:CtrlPlaneNextHopContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneNextHopContent *** SOAP_FMAC4 soap_get_PointerToPointerTons5__CtrlPlaneNextHopContent(struct soap *soap, struct ns5__CtrlPlaneNextHopContent ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons5__CtrlPlaneNextHopContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlaneNextHopContent(struct soap *soap, struct ns5__CtrlPlaneNextHopContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlaneNextHopContent))
    soap_serialize_ns5__CtrlPlaneNextHopContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlaneNextHopContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneNextHopContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlaneNextHopContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlaneNextHopContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneNextHopContent ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlaneNextHopContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneNextHopContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneNextHopContent **)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneNextHopContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlaneNextHopContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneNextHopContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlaneNextHopContent, sizeof(struct ns5__CtrlPlaneNextHopContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlaneNextHopContent(struct soap *soap, struct ns5__CtrlPlaneNextHopContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlaneNextHopContent);
  if (soap_out_PointerTons5__CtrlPlaneNextHopContent(soap, tag?tag:"ns5:CtrlPlaneNextHopContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneNextHopContent ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlaneNextHopContent(struct soap *soap, struct ns5__CtrlPlaneNextHopContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlaneNextHopContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons5__CtrlPlaneHopContent(struct soap *soap, struct ns5__CtrlPlaneHopContent **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons5__CtrlPlaneHopContent))
    soap_serialize_PointerTons5__CtrlPlaneHopContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons5__CtrlPlaneHopContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneHopContent **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons5__CtrlPlaneHopContent);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons5__CtrlPlaneHopContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneHopContent *** SOAP_FMAC4 soap_in_PointerToPointerTons5__CtrlPlaneHopContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneHopContent ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneHopContent ***)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneHopContent **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons5__CtrlPlaneHopContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneHopContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons5__CtrlPlaneHopContent, sizeof(struct ns5__CtrlPlaneHopContent *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons5__CtrlPlaneHopContent(struct soap *soap, struct ns5__CtrlPlaneHopContent **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons5__CtrlPlaneHopContent);
  if (soap_out_PointerToPointerTons5__CtrlPlaneHopContent(soap, tag?tag:"ns5:CtrlPlaneHopContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneHopContent *** SOAP_FMAC4 soap_get_PointerToPointerTons5__CtrlPlaneHopContent(struct soap *soap, struct ns5__CtrlPlaneHopContent ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons5__CtrlPlaneHopContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlaneHopContent(struct soap *soap, struct ns5__CtrlPlaneHopContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlaneHopContent))
    soap_serialize_ns5__CtrlPlaneHopContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlaneHopContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneHopContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlaneHopContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlaneHopContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneHopContent ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlaneHopContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneHopContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneHopContent **)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneHopContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlaneHopContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneHopContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlaneHopContent, sizeof(struct ns5__CtrlPlaneHopContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlaneHopContent(struct soap *soap, struct ns5__CtrlPlaneHopContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlaneHopContent);
  if (soap_out_PointerTons5__CtrlPlaneHopContent(soap, tag?tag:"ns5:CtrlPlaneHopContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneHopContent ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlaneHopContent(struct soap *soap, struct ns5__CtrlPlaneHopContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlaneHopContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlaneSwcapContent(struct soap *soap, struct ns5__CtrlPlaneSwcapContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlaneSwcapContent))
    soap_serialize_ns5__CtrlPlaneSwcapContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlaneSwcapContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneSwcapContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlaneSwcapContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlaneSwcapContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneSwcapContent ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlaneSwcapContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneSwcapContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneSwcapContent **)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneSwcapContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlaneSwcapContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneSwcapContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlaneSwcapContent, sizeof(struct ns5__CtrlPlaneSwcapContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlaneSwcapContent(struct soap *soap, struct ns5__CtrlPlaneSwcapContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlaneSwcapContent);
  if (soap_out_PointerTons5__CtrlPlaneSwcapContent(soap, tag?tag:"ns5:CtrlPlaneSwcapContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneSwcapContent ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlaneSwcapContent(struct soap *soap, struct ns5__CtrlPlaneSwcapContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlaneSwcapContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons5__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns5__CtrlPlaneAdministrativeGroup **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons5__CtrlPlaneAdministrativeGroup))
    soap_serialize_PointerTons5__CtrlPlaneAdministrativeGroup(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons5__CtrlPlaneAdministrativeGroup(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneAdministrativeGroup **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons5__CtrlPlaneAdministrativeGroup);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons5__CtrlPlaneAdministrativeGroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneAdministrativeGroup *** SOAP_FMAC4 soap_in_PointerToPointerTons5__CtrlPlaneAdministrativeGroup(struct soap *soap, const char *tag, struct ns5__CtrlPlaneAdministrativeGroup ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneAdministrativeGroup ***)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneAdministrativeGroup **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons5__CtrlPlaneAdministrativeGroup(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneAdministrativeGroup ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons5__CtrlPlaneAdministrativeGroup, sizeof(struct ns5__CtrlPlaneAdministrativeGroup *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons5__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns5__CtrlPlaneAdministrativeGroup **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons5__CtrlPlaneAdministrativeGroup);
  if (soap_out_PointerToPointerTons5__CtrlPlaneAdministrativeGroup(soap, tag?tag:"ns5:CtrlPlaneAdministrativeGroup", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneAdministrativeGroup *** SOAP_FMAC4 soap_get_PointerToPointerTons5__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns5__CtrlPlaneAdministrativeGroup ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons5__CtrlPlaneAdministrativeGroup(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns5__CtrlPlaneAdministrativeGroup *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlaneAdministrativeGroup))
    soap_serialize_ns5__CtrlPlaneAdministrativeGroup(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlaneAdministrativeGroup(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneAdministrativeGroup *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlaneAdministrativeGroup);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlaneAdministrativeGroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneAdministrativeGroup ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlaneAdministrativeGroup(struct soap *soap, const char *tag, struct ns5__CtrlPlaneAdministrativeGroup **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneAdministrativeGroup **)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneAdministrativeGroup *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlaneAdministrativeGroup(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneAdministrativeGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlaneAdministrativeGroup, sizeof(struct ns5__CtrlPlaneAdministrativeGroup), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns5__CtrlPlaneAdministrativeGroup *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlaneAdministrativeGroup);
  if (soap_out_PointerTons5__CtrlPlaneAdministrativeGroup(soap, tag?tag:"ns5:CtrlPlaneAdministrativeGroup", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneAdministrativeGroup ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlaneAdministrativeGroup(struct soap *soap, struct ns5__CtrlPlaneAdministrativeGroup **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlaneAdministrativeGroup(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlaneAddressContent(struct soap *soap, struct ns5__CtrlPlaneAddressContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlaneAddressContent))
    soap_serialize_ns5__CtrlPlaneAddressContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlaneAddressContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneAddressContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlaneAddressContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlaneAddressContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneAddressContent ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlaneAddressContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneAddressContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneAddressContent **)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneAddressContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlaneAddressContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneAddressContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlaneAddressContent, sizeof(struct ns5__CtrlPlaneAddressContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlaneAddressContent(struct soap *soap, struct ns5__CtrlPlaneAddressContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlaneAddressContent);
  if (soap_out_PointerTons5__CtrlPlaneAddressContent(soap, tag?tag:"ns5:CtrlPlaneAddressContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneAddressContent ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlaneAddressContent(struct soap *soap, struct ns5__CtrlPlaneAddressContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlaneAddressContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons5__CtrlPlaneLinkContent(struct soap *soap, struct ns5__CtrlPlaneLinkContent **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons5__CtrlPlaneLinkContent))
    soap_serialize_PointerTons5__CtrlPlaneLinkContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons5__CtrlPlaneLinkContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneLinkContent **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons5__CtrlPlaneLinkContent);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons5__CtrlPlaneLinkContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneLinkContent *** SOAP_FMAC4 soap_in_PointerToPointerTons5__CtrlPlaneLinkContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneLinkContent ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneLinkContent ***)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneLinkContent **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons5__CtrlPlaneLinkContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneLinkContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons5__CtrlPlaneLinkContent, sizeof(struct ns5__CtrlPlaneLinkContent *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons5__CtrlPlaneLinkContent(struct soap *soap, struct ns5__CtrlPlaneLinkContent **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons5__CtrlPlaneLinkContent);
  if (soap_out_PointerToPointerTons5__CtrlPlaneLinkContent(soap, tag?tag:"ns5:CtrlPlaneLinkContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneLinkContent *** SOAP_FMAC4 soap_get_PointerToPointerTons5__CtrlPlaneLinkContent(struct soap *soap, struct ns5__CtrlPlaneLinkContent ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons5__CtrlPlaneLinkContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlaneLinkContent(struct soap *soap, struct ns5__CtrlPlaneLinkContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlaneLinkContent))
    soap_serialize_ns5__CtrlPlaneLinkContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlaneLinkContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneLinkContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlaneLinkContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlaneLinkContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneLinkContent ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlaneLinkContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneLinkContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneLinkContent **)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneLinkContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlaneLinkContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneLinkContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlaneLinkContent, sizeof(struct ns5__CtrlPlaneLinkContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlaneLinkContent(struct soap *soap, struct ns5__CtrlPlaneLinkContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlaneLinkContent);
  if (soap_out_PointerTons5__CtrlPlaneLinkContent(soap, tag?tag:"ns5:CtrlPlaneLinkContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneLinkContent ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlaneLinkContent(struct soap *soap, struct ns5__CtrlPlaneLinkContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlaneLinkContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons5__CtrlPlanePortContent(struct soap *soap, struct ns5__CtrlPlanePortContent **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons5__CtrlPlanePortContent))
    soap_serialize_PointerTons5__CtrlPlanePortContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons5__CtrlPlanePortContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlanePortContent **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons5__CtrlPlanePortContent);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons5__CtrlPlanePortContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlanePortContent *** SOAP_FMAC4 soap_in_PointerToPointerTons5__CtrlPlanePortContent(struct soap *soap, const char *tag, struct ns5__CtrlPlanePortContent ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlanePortContent ***)soap_malloc(soap, sizeof(struct ns5__CtrlPlanePortContent **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons5__CtrlPlanePortContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlanePortContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons5__CtrlPlanePortContent, sizeof(struct ns5__CtrlPlanePortContent *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons5__CtrlPlanePortContent(struct soap *soap, struct ns5__CtrlPlanePortContent **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons5__CtrlPlanePortContent);
  if (soap_out_PointerToPointerTons5__CtrlPlanePortContent(soap, tag?tag:"ns5:CtrlPlanePortContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlanePortContent *** SOAP_FMAC4 soap_get_PointerToPointerTons5__CtrlPlanePortContent(struct soap *soap, struct ns5__CtrlPlanePortContent ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons5__CtrlPlanePortContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlanePortContent(struct soap *soap, struct ns5__CtrlPlanePortContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlanePortContent))
    soap_serialize_ns5__CtrlPlanePortContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlanePortContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlanePortContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlanePortContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlanePortContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlanePortContent ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlanePortContent(struct soap *soap, const char *tag, struct ns5__CtrlPlanePortContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlanePortContent **)soap_malloc(soap, sizeof(struct ns5__CtrlPlanePortContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlanePortContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlanePortContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlanePortContent, sizeof(struct ns5__CtrlPlanePortContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlanePortContent(struct soap *soap, struct ns5__CtrlPlanePortContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlanePortContent);
  if (soap_out_PointerTons5__CtrlPlanePortContent(soap, tag?tag:"ns5:CtrlPlanePortContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlanePortContent ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlanePortContent(struct soap *soap, struct ns5__CtrlPlanePortContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlanePortContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons5__CtrlPlaneNodeContent(struct soap *soap, struct ns5__CtrlPlaneNodeContent **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons5__CtrlPlaneNodeContent))
    soap_serialize_PointerTons5__CtrlPlaneNodeContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons5__CtrlPlaneNodeContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneNodeContent **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons5__CtrlPlaneNodeContent);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons5__CtrlPlaneNodeContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneNodeContent *** SOAP_FMAC4 soap_in_PointerToPointerTons5__CtrlPlaneNodeContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneNodeContent ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneNodeContent ***)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneNodeContent **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons5__CtrlPlaneNodeContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneNodeContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons5__CtrlPlaneNodeContent, sizeof(struct ns5__CtrlPlaneNodeContent *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons5__CtrlPlaneNodeContent(struct soap *soap, struct ns5__CtrlPlaneNodeContent **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons5__CtrlPlaneNodeContent);
  if (soap_out_PointerToPointerTons5__CtrlPlaneNodeContent(soap, tag?tag:"ns5:CtrlPlaneNodeContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneNodeContent *** SOAP_FMAC4 soap_get_PointerToPointerTons5__CtrlPlaneNodeContent(struct soap *soap, struct ns5__CtrlPlaneNodeContent ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons5__CtrlPlaneNodeContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlaneNodeContent(struct soap *soap, struct ns5__CtrlPlaneNodeContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlaneNodeContent))
    soap_serialize_ns5__CtrlPlaneNodeContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlaneNodeContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneNodeContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlaneNodeContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlaneNodeContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneNodeContent ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlaneNodeContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneNodeContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneNodeContent **)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneNodeContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlaneNodeContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneNodeContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlaneNodeContent, sizeof(struct ns5__CtrlPlaneNodeContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlaneNodeContent(struct soap *soap, struct ns5__CtrlPlaneNodeContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlaneNodeContent);
  if (soap_out_PointerTons5__CtrlPlaneNodeContent(soap, tag?tag:"ns5:CtrlPlaneNodeContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneNodeContent ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlaneNodeContent(struct soap *soap, struct ns5__CtrlPlaneNodeContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlaneNodeContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__Lifetime(struct soap *soap, struct ns5__Lifetime *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__Lifetime))
    soap_serialize_ns5__Lifetime(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__Lifetime(struct soap *soap, const char *tag, int id, struct ns5__Lifetime *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__Lifetime);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__Lifetime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__Lifetime ** SOAP_FMAC4 soap_in_PointerTons5__Lifetime(struct soap *soap, const char *tag, struct ns5__Lifetime **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__Lifetime **)soap_malloc(soap, sizeof(struct ns5__Lifetime *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__Lifetime(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__Lifetime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__Lifetime, sizeof(struct ns5__Lifetime), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__Lifetime(struct soap *soap, struct ns5__Lifetime *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__Lifetime);
  if (soap_out_PointerTons5__Lifetime(soap, tag?tag:"ns5:Lifetime", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__Lifetime ** SOAP_FMAC4 soap_get_PointerTons5__Lifetime(struct soap *soap, struct ns5__Lifetime **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__Lifetime(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons5__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns5__CtrlPlaneDomainSignatureContent **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons5__CtrlPlaneDomainSignatureContent))
    soap_serialize_PointerTons5__CtrlPlaneDomainSignatureContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons5__CtrlPlaneDomainSignatureContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneDomainSignatureContent **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons5__CtrlPlaneDomainSignatureContent);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons5__CtrlPlaneDomainSignatureContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneDomainSignatureContent *** SOAP_FMAC4 soap_in_PointerToPointerTons5__CtrlPlaneDomainSignatureContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneDomainSignatureContent ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneDomainSignatureContent ***)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneDomainSignatureContent **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons5__CtrlPlaneDomainSignatureContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneDomainSignatureContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons5__CtrlPlaneDomainSignatureContent, sizeof(struct ns5__CtrlPlaneDomainSignatureContent *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons5__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns5__CtrlPlaneDomainSignatureContent **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons5__CtrlPlaneDomainSignatureContent);
  if (soap_out_PointerToPointerTons5__CtrlPlaneDomainSignatureContent(soap, tag?tag:"ns5:CtrlPlaneDomainSignatureContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneDomainSignatureContent *** SOAP_FMAC4 soap_get_PointerToPointerTons5__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns5__CtrlPlaneDomainSignatureContent ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons5__CtrlPlaneDomainSignatureContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns5__CtrlPlaneDomainSignatureContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlaneDomainSignatureContent))
    soap_serialize_ns5__CtrlPlaneDomainSignatureContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlaneDomainSignatureContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneDomainSignatureContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlaneDomainSignatureContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlaneDomainSignatureContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneDomainSignatureContent ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlaneDomainSignatureContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneDomainSignatureContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneDomainSignatureContent **)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneDomainSignatureContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlaneDomainSignatureContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneDomainSignatureContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlaneDomainSignatureContent, sizeof(struct ns5__CtrlPlaneDomainSignatureContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns5__CtrlPlaneDomainSignatureContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlaneDomainSignatureContent);
  if (soap_out_PointerTons5__CtrlPlaneDomainSignatureContent(soap, tag?tag:"ns5:CtrlPlaneDomainSignatureContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneDomainSignatureContent ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlaneDomainSignatureContent(struct soap *soap, struct ns5__CtrlPlaneDomainSignatureContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlaneDomainSignatureContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons5__CtrlPlaneDomainContent(struct soap *soap, struct ns5__CtrlPlaneDomainContent **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons5__CtrlPlaneDomainContent))
    soap_serialize_PointerTons5__CtrlPlaneDomainContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons5__CtrlPlaneDomainContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneDomainContent **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons5__CtrlPlaneDomainContent);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons5__CtrlPlaneDomainContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneDomainContent *** SOAP_FMAC4 soap_in_PointerToPointerTons5__CtrlPlaneDomainContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneDomainContent ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneDomainContent ***)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneDomainContent **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons5__CtrlPlaneDomainContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneDomainContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons5__CtrlPlaneDomainContent, sizeof(struct ns5__CtrlPlaneDomainContent *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons5__CtrlPlaneDomainContent(struct soap *soap, struct ns5__CtrlPlaneDomainContent **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons5__CtrlPlaneDomainContent);
  if (soap_out_PointerToPointerTons5__CtrlPlaneDomainContent(soap, tag?tag:"ns5:CtrlPlaneDomainContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneDomainContent *** SOAP_FMAC4 soap_get_PointerToPointerTons5__CtrlPlaneDomainContent(struct soap *soap, struct ns5__CtrlPlaneDomainContent ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons5__CtrlPlaneDomainContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlaneDomainContent(struct soap *soap, struct ns5__CtrlPlaneDomainContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlaneDomainContent))
    soap_serialize_ns5__CtrlPlaneDomainContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlaneDomainContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneDomainContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlaneDomainContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlaneDomainContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneDomainContent ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlaneDomainContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneDomainContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneDomainContent **)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneDomainContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlaneDomainContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneDomainContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlaneDomainContent, sizeof(struct ns5__CtrlPlaneDomainContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlaneDomainContent(struct soap *soap, struct ns5__CtrlPlaneDomainContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlaneDomainContent);
  if (soap_out_PointerTons5__CtrlPlaneDomainContent(soap, tag?tag:"ns5:CtrlPlaneDomainContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneDomainContent ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlaneDomainContent(struct soap *soap, struct ns5__CtrlPlaneDomainContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlaneDomainContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons5__CtrlPlanePathContent(struct soap *soap, struct ns5__CtrlPlanePathContent **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons5__CtrlPlanePathContent))
    soap_serialize_PointerTons5__CtrlPlanePathContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons5__CtrlPlanePathContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlanePathContent **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons5__CtrlPlanePathContent);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons5__CtrlPlanePathContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlanePathContent *** SOAP_FMAC4 soap_in_PointerToPointerTons5__CtrlPlanePathContent(struct soap *soap, const char *tag, struct ns5__CtrlPlanePathContent ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlanePathContent ***)soap_malloc(soap, sizeof(struct ns5__CtrlPlanePathContent **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons5__CtrlPlanePathContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlanePathContent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons5__CtrlPlanePathContent, sizeof(struct ns5__CtrlPlanePathContent *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons5__CtrlPlanePathContent(struct soap *soap, struct ns5__CtrlPlanePathContent **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons5__CtrlPlanePathContent);
  if (soap_out_PointerToPointerTons5__CtrlPlanePathContent(soap, tag?tag:"ns5:CtrlPlanePathContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlanePathContent *** SOAP_FMAC4 soap_get_PointerToPointerTons5__CtrlPlanePathContent(struct soap *soap, struct ns5__CtrlPlanePathContent ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons5__CtrlPlanePathContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a) {
  soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt);
  if (id < 0)
    return soap->error;
  return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedInt);
  if (soap_out_PointerTounsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__Subscribe_SubscriptionPolicy(struct soap *soap, struct _ns3__Subscribe_SubscriptionPolicy *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy))
    soap_serialize__ns3__Subscribe_SubscriptionPolicy(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _ns3__Subscribe_SubscriptionPolicy *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy);
  if (id < 0)
    return soap->error;
  return soap_out__ns3__Subscribe_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns3__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_ns3__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _ns3__Subscribe_SubscriptionPolicy **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _ns3__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _ns3__Subscribe_SubscriptionPolicy *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__ns3__Subscribe_SubscriptionPolicy(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _ns3__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy, sizeof(struct _ns3__Subscribe_SubscriptionPolicy), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__Subscribe_SubscriptionPolicy(struct soap *soap, struct _ns3__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__Subscribe_SubscriptionPolicy);
  if (soap_out_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, tag?tag:"ns3:Subscribe-SubscriptionPolicy", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_ns3__Subscribe_SubscriptionPolicy(struct soap *soap, struct _ns3__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_ns3__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__NotificationMessageHolderType(struct soap *soap, struct ns3__NotificationMessageHolderType **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__NotificationMessageHolderType))
    soap_serialize_PointerTons3__NotificationMessageHolderType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, struct ns3__NotificationMessageHolderType **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__NotificationMessageHolderType);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons3__NotificationMessageHolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__NotificationMessageHolderType *** SOAP_FMAC4 soap_in_PointerToPointerTons3__NotificationMessageHolderType(struct soap *soap, const char *tag, struct ns3__NotificationMessageHolderType ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns3__NotificationMessageHolderType ***)soap_malloc(soap, sizeof(struct ns3__NotificationMessageHolderType **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons3__NotificationMessageHolderType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns3__NotificationMessageHolderType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__NotificationMessageHolderType, sizeof(struct ns3__NotificationMessageHolderType *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__NotificationMessageHolderType(struct soap *soap, struct ns3__NotificationMessageHolderType **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__NotificationMessageHolderType);
  if (soap_out_PointerToPointerTons3__NotificationMessageHolderType(soap, tag?tag:"ns3:NotificationMessageHolderType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__NotificationMessageHolderType *** SOAP_FMAC4 soap_get_PointerToPointerTons3__NotificationMessageHolderType(struct soap *soap, struct ns3__NotificationMessageHolderType ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons3__NotificationMessageHolderType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__NotificationMessageHolderType(struct soap *soap, struct ns3__NotificationMessageHolderType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns3__NotificationMessageHolderType))
    soap_serialize_ns3__NotificationMessageHolderType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, struct ns3__NotificationMessageHolderType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__NotificationMessageHolderType);
  if (id < 0)
    return soap->error;
  return soap_out_ns3__NotificationMessageHolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTons3__NotificationMessageHolderType(struct soap *soap, const char *tag, struct ns3__NotificationMessageHolderType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns3__NotificationMessageHolderType **)soap_malloc(soap, sizeof(struct ns3__NotificationMessageHolderType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns3__NotificationMessageHolderType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns3__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__NotificationMessageHolderType, sizeof(struct ns3__NotificationMessageHolderType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__NotificationMessageHolderType(struct soap *soap, struct ns3__NotificationMessageHolderType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__NotificationMessageHolderType);
  if (soap_out_PointerTons3__NotificationMessageHolderType(soap, tag?tag:"ns3:NotificationMessageHolderType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTons3__NotificationMessageHolderType(struct soap *soap, struct ns3__NotificationMessageHolderType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons3__NotificationMessageHolderType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a) {
  soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
  if (id < 0)
    return soap->error;
  return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_time(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
  if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTotime(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__SubscriptionPolicyType(struct soap *soap, struct ns3__SubscriptionPolicyType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns3__SubscriptionPolicyType))
    soap_serialize_ns3__SubscriptionPolicyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, struct ns3__SubscriptionPolicyType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__SubscriptionPolicyType);
  if (id < 0)
    return soap->error;
  return soap_out_ns3__SubscriptionPolicyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTons3__SubscriptionPolicyType(struct soap *soap, const char *tag, struct ns3__SubscriptionPolicyType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns3__SubscriptionPolicyType **)soap_malloc(soap, sizeof(struct ns3__SubscriptionPolicyType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns3__SubscriptionPolicyType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns3__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__SubscriptionPolicyType, sizeof(struct ns3__SubscriptionPolicyType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__SubscriptionPolicyType(struct soap *soap, struct ns3__SubscriptionPolicyType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__SubscriptionPolicyType);
  if (soap_out_PointerTons3__SubscriptionPolicyType(soap, tag?tag:"ns3:SubscriptionPolicyType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTons3__SubscriptionPolicyType(struct soap *soap, struct ns3__SubscriptionPolicyType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons3__SubscriptionPolicyType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FilterType(struct soap *soap, struct ns3__FilterType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns3__FilterType))
    soap_serialize_ns3__FilterType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FilterType(struct soap *soap, const char *tag, int id, struct ns3__FilterType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__FilterType);
  if (id < 0)
    return soap->error;
  return soap_out_ns3__FilterType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__FilterType ** SOAP_FMAC4 soap_in_PointerTons3__FilterType(struct soap *soap, const char *tag, struct ns3__FilterType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns3__FilterType **)soap_malloc(soap, sizeof(struct ns3__FilterType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns3__FilterType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns3__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__FilterType, sizeof(struct ns3__FilterType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FilterType(struct soap *soap, struct ns3__FilterType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__FilterType);
  if (soap_out_PointerTons3__FilterType(soap, tag?tag:"ns3:FilterType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__FilterType ** SOAP_FMAC4 soap_get_PointerTons3__FilterType(struct soap *soap, struct ns3__FilterType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons3__FilterType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__MessageType(struct soap *soap, struct ns3__MessageType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns3__MessageType))
    soap_serialize_ns3__MessageType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__MessageType(struct soap *soap, const char *tag, int id, struct ns3__MessageType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__MessageType);
  if (id < 0)
    return soap->error;
  return soap_out_ns3__MessageType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__MessageType ** SOAP_FMAC4 soap_in_PointerTons3__MessageType(struct soap *soap, const char *tag, struct ns3__MessageType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns3__MessageType **)soap_malloc(soap, sizeof(struct ns3__MessageType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns3__MessageType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns3__MessageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__MessageType, sizeof(struct ns3__MessageType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__MessageType(struct soap *soap, struct ns3__MessageType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__MessageType);
  if (soap_out_PointerTons3__MessageType(soap, tag?tag:"ns3:MessageType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__MessageType ** SOAP_FMAC4 soap_get_PointerTons3__MessageType(struct soap *soap, struct ns3__MessageType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons3__MessageType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
    soap_serialize_wsa5__EndpointReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType);
  if (id < 0)
    return soap->error;
  return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__EndpointReferenceType);
  if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__QueryExpressionType(struct soap *soap, struct ns3__QueryExpressionType **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__QueryExpressionType))
    soap_serialize_PointerTons3__QueryExpressionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__QueryExpressionType(struct soap *soap, const char *tag, int id, struct ns3__QueryExpressionType **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__QueryExpressionType);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons3__QueryExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__QueryExpressionType *** SOAP_FMAC4 soap_in_PointerToPointerTons3__QueryExpressionType(struct soap *soap, const char *tag, struct ns3__QueryExpressionType ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns3__QueryExpressionType ***)soap_malloc(soap, sizeof(struct ns3__QueryExpressionType **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons3__QueryExpressionType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns3__QueryExpressionType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__QueryExpressionType, sizeof(struct ns3__QueryExpressionType *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__QueryExpressionType(struct soap *soap, struct ns3__QueryExpressionType **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__QueryExpressionType);
  if (soap_out_PointerToPointerTons3__QueryExpressionType(soap, tag?tag:"ns3:QueryExpressionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__QueryExpressionType *** SOAP_FMAC4 soap_get_PointerToPointerTons3__QueryExpressionType(struct soap *soap, struct ns3__QueryExpressionType ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons3__QueryExpressionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__QueryExpressionType(struct soap *soap, struct ns3__QueryExpressionType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns3__QueryExpressionType))
    soap_serialize_ns3__QueryExpressionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__QueryExpressionType(struct soap *soap, const char *tag, int id, struct ns3__QueryExpressionType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__QueryExpressionType);
  if (id < 0)
    return soap->error;
  return soap_out_ns3__QueryExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTons3__QueryExpressionType(struct soap *soap, const char *tag, struct ns3__QueryExpressionType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns3__QueryExpressionType **)soap_malloc(soap, sizeof(struct ns3__QueryExpressionType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns3__QueryExpressionType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns3__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__QueryExpressionType, sizeof(struct ns3__QueryExpressionType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__QueryExpressionType(struct soap *soap, struct ns3__QueryExpressionType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__QueryExpressionType);
  if (soap_out_PointerTons3__QueryExpressionType(soap, tag?tag:"ns3:QueryExpressionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTons3__QueryExpressionType(struct soap *soap, struct ns3__QueryExpressionType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons3__QueryExpressionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__TopicExpressionType(struct soap *soap, struct ns3__TopicExpressionType **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__TopicExpressionType))
    soap_serialize_PointerTons3__TopicExpressionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__TopicExpressionType(struct soap *soap, const char *tag, int id, struct ns3__TopicExpressionType **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__TopicExpressionType);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons3__TopicExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__TopicExpressionType *** SOAP_FMAC4 soap_in_PointerToPointerTons3__TopicExpressionType(struct soap *soap, const char *tag, struct ns3__TopicExpressionType ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns3__TopicExpressionType ***)soap_malloc(soap, sizeof(struct ns3__TopicExpressionType **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons3__TopicExpressionType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns3__TopicExpressionType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__TopicExpressionType, sizeof(struct ns3__TopicExpressionType *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__TopicExpressionType(struct soap *soap, struct ns3__TopicExpressionType **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__TopicExpressionType);
  if (soap_out_PointerToPointerTons3__TopicExpressionType(soap, tag?tag:"ns3:TopicExpressionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__TopicExpressionType *** SOAP_FMAC4 soap_get_PointerToPointerTons3__TopicExpressionType(struct soap *soap, struct ns3__TopicExpressionType ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons3__TopicExpressionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TopicExpressionType(struct soap *soap, struct ns3__TopicExpressionType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TopicExpressionType))
    soap_serialize_ns3__TopicExpressionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TopicExpressionType(struct soap *soap, const char *tag, int id, struct ns3__TopicExpressionType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TopicExpressionType);
  if (id < 0)
    return soap->error;
  return soap_out_ns3__TopicExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTons3__TopicExpressionType(struct soap *soap, const char *tag, struct ns3__TopicExpressionType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns3__TopicExpressionType **)soap_malloc(soap, sizeof(struct ns3__TopicExpressionType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns3__TopicExpressionType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns3__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TopicExpressionType, sizeof(struct ns3__TopicExpressionType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TopicExpressionType(struct soap *soap, struct ns3__TopicExpressionType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__TopicExpressionType);
  if (soap_out_PointerTons3__TopicExpressionType(soap, tag?tag:"ns3:TopicExpressionType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTons3__TopicExpressionType(struct soap *soap, struct ns3__TopicExpressionType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons3__TopicExpressionType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__pathInfo(struct soap *soap, struct ns1__pathInfo *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__pathInfo))
    soap_serialize_ns1__pathInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__pathInfo(struct soap *soap, const char *tag, int id, struct ns1__pathInfo *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__pathInfo);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__pathInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__pathInfo ** SOAP_FMAC4 soap_in_PointerTons1__pathInfo(struct soap *soap, const char *tag, struct ns1__pathInfo **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__pathInfo **)soap_malloc(soap, sizeof(struct ns1__pathInfo *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__pathInfo(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__pathInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__pathInfo, sizeof(struct ns1__pathInfo), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__pathInfo(struct soap *soap, struct ns1__pathInfo *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__pathInfo);
  if (soap_out_PointerTons1__pathInfo(soap, tag?tag:"ns1:pathInfo", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__pathInfo ** SOAP_FMAC4 soap_get_PointerTons1__pathInfo(struct soap *soap, struct ns1__pathInfo **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__pathInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__optionalConstraintValue(struct soap *soap, struct ns1__optionalConstraintValue *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__optionalConstraintValue))
    soap_serialize_ns1__optionalConstraintValue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__optionalConstraintValue(struct soap *soap, const char *tag, int id, struct ns1__optionalConstraintValue *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__optionalConstraintValue);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__optionalConstraintValue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__optionalConstraintValue ** SOAP_FMAC4 soap_in_PointerTons1__optionalConstraintValue(struct soap *soap, const char *tag, struct ns1__optionalConstraintValue **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__optionalConstraintValue **)soap_malloc(soap, sizeof(struct ns1__optionalConstraintValue *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__optionalConstraintValue(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__optionalConstraintValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__optionalConstraintValue, sizeof(struct ns1__optionalConstraintValue), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__optionalConstraintValue(struct soap *soap, struct ns1__optionalConstraintValue *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__optionalConstraintValue);
  if (soap_out_PointerTons1__optionalConstraintValue(soap, tag?tag:"ns1:optionalConstraintValue", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__optionalConstraintValue ** SOAP_FMAC4 soap_get_PointerTons1__optionalConstraintValue(struct soap *soap, struct ns1__optionalConstraintValue **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__optionalConstraintValue(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__localDetails(struct soap *soap, struct ns1__localDetails *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__localDetails))
    soap_serialize_ns1__localDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__localDetails(struct soap *soap, const char *tag, int id, struct ns1__localDetails *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__localDetails);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__localDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__localDetails ** SOAP_FMAC4 soap_in_PointerTons1__localDetails(struct soap *soap, const char *tag, struct ns1__localDetails **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__localDetails **)soap_malloc(soap, sizeof(struct ns1__localDetails *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__localDetails(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__localDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__localDetails, sizeof(struct ns1__localDetails), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__localDetails(struct soap *soap, struct ns1__localDetails *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__localDetails);
  if (soap_out_PointerTons1__localDetails(soap, tag?tag:"ns1:localDetails", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__localDetails ** SOAP_FMAC4 soap_get_PointerTons1__localDetails(struct soap *soap, struct ns1__localDetails **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__localDetails(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mplsInfo(struct soap *soap, struct ns1__mplsInfo *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mplsInfo))
    soap_serialize_ns1__mplsInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mplsInfo(struct soap *soap, const char *tag, int id, struct ns1__mplsInfo *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mplsInfo);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__mplsInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mplsInfo ** SOAP_FMAC4 soap_in_PointerTons1__mplsInfo(struct soap *soap, const char *tag, struct ns1__mplsInfo **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__mplsInfo **)soap_malloc(soap, sizeof(struct ns1__mplsInfo *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__mplsInfo(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__mplsInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mplsInfo, sizeof(struct ns1__mplsInfo), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mplsInfo(struct soap *soap, struct ns1__mplsInfo *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mplsInfo);
  if (soap_out_PointerTons1__mplsInfo(soap, tag?tag:"ns1:mplsInfo", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mplsInfo ** SOAP_FMAC4 soap_get_PointerTons1__mplsInfo(struct soap *soap, struct ns1__mplsInfo **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__mplsInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__layer3Info(struct soap *soap, struct ns1__layer3Info *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__layer3Info))
    soap_serialize_ns1__layer3Info(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__layer3Info(struct soap *soap, const char *tag, int id, struct ns1__layer3Info *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__layer3Info);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__layer3Info(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__layer3Info ** SOAP_FMAC4 soap_in_PointerTons1__layer3Info(struct soap *soap, const char *tag, struct ns1__layer3Info **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__layer3Info **)soap_malloc(soap, sizeof(struct ns1__layer3Info *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__layer3Info(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__layer3Info **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__layer3Info, sizeof(struct ns1__layer3Info), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__layer3Info(struct soap *soap, struct ns1__layer3Info *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__layer3Info);
  if (soap_out_PointerTons1__layer3Info(soap, tag?tag:"ns1:layer3Info", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__layer3Info ** SOAP_FMAC4 soap_get_PointerTons1__layer3Info(struct soap *soap, struct ns1__layer3Info **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__layer3Info(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__layer2Info(struct soap *soap, struct ns1__layer2Info *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__layer2Info))
    soap_serialize_ns1__layer2Info(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__layer2Info(struct soap *soap, const char *tag, int id, struct ns1__layer2Info *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__layer2Info);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__layer2Info(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__layer2Info ** SOAP_FMAC4 soap_in_PointerTons1__layer2Info(struct soap *soap, const char *tag, struct ns1__layer2Info **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__layer2Info **)soap_malloc(soap, sizeof(struct ns1__layer2Info *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__layer2Info(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__layer2Info **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__layer2Info, sizeof(struct ns1__layer2Info), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__layer2Info(struct soap *soap, struct ns1__layer2Info *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__layer2Info);
  if (soap_out_PointerTons1__layer2Info(soap, tag?tag:"ns1:layer2Info", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__layer2Info ** SOAP_FMAC4 soap_get_PointerTons1__layer2Info(struct soap *soap, struct ns1__layer2Info **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__layer2Info(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlanePathContent(struct soap *soap, struct ns5__CtrlPlanePathContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlanePathContent))
    soap_serialize_ns5__CtrlPlanePathContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlanePathContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlanePathContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlanePathContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlanePathContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlanePathContent ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlanePathContent(struct soap *soap, const char *tag, struct ns5__CtrlPlanePathContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlanePathContent **)soap_malloc(soap, sizeof(struct ns5__CtrlPlanePathContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlanePathContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlanePathContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlanePathContent, sizeof(struct ns5__CtrlPlanePathContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlanePathContent(struct soap *soap, struct ns5__CtrlPlanePathContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlanePathContent);
  if (soap_out_PointerTons5__CtrlPlanePathContent(soap, tag?tag:"ns5:CtrlPlanePathContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlanePathContent ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlanePathContent(struct soap *soap, struct ns5__CtrlPlanePathContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlanePathContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__resDetails(struct soap *soap, struct ns1__resDetails **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__resDetails))
    soap_serialize_PointerTons1__resDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__resDetails(struct soap *soap, const char *tag, int id, struct ns1__resDetails **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__resDetails);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons1__resDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__resDetails *** SOAP_FMAC4 soap_in_PointerToPointerTons1__resDetails(struct soap *soap, const char *tag, struct ns1__resDetails ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__resDetails ***)soap_malloc(soap, sizeof(struct ns1__resDetails **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons1__resDetails(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__resDetails ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__resDetails, sizeof(struct ns1__resDetails *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__resDetails(struct soap *soap, struct ns1__resDetails **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__resDetails);
  if (soap_out_PointerToPointerTons1__resDetails(soap, tag?tag:"ns1:resDetails", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__resDetails *** SOAP_FMAC4 soap_get_PointerToPointerTons1__resDetails(struct soap *soap, struct ns1__resDetails ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons1__resDetails(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__vlanTag(struct soap *soap, struct ns1__vlanTag **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__vlanTag))
    soap_serialize_PointerTons1__vlanTag(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__vlanTag(struct soap *soap, const char *tag, int id, struct ns1__vlanTag **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__vlanTag);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons1__vlanTag(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__vlanTag *** SOAP_FMAC4 soap_in_PointerToPointerTons1__vlanTag(struct soap *soap, const char *tag, struct ns1__vlanTag ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__vlanTag ***)soap_malloc(soap, sizeof(struct ns1__vlanTag **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons1__vlanTag(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__vlanTag ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__vlanTag, sizeof(struct ns1__vlanTag *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__vlanTag(struct soap *soap, struct ns1__vlanTag **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__vlanTag);
  if (soap_out_PointerToPointerTons1__vlanTag(soap, tag?tag:"ns1:vlanTag", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__vlanTag *** SOAP_FMAC4 soap_get_PointerToPointerTons1__vlanTag(struct soap *soap, struct ns1__vlanTag ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons1__vlanTag(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__vlanTag(struct soap *soap, struct ns1__vlanTag *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__vlanTag))
    soap_serialize_ns1__vlanTag(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__vlanTag(struct soap *soap, const char *tag, int id, struct ns1__vlanTag *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__vlanTag);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__vlanTag(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__vlanTag ** SOAP_FMAC4 soap_in_PointerTons1__vlanTag(struct soap *soap, const char *tag, struct ns1__vlanTag **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__vlanTag **)soap_malloc(soap, sizeof(struct ns1__vlanTag *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__vlanTag(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__vlanTag **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__vlanTag, sizeof(struct ns1__vlanTag), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__vlanTag(struct soap *soap, struct ns1__vlanTag *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__vlanTag);
  if (soap_out_PointerTons1__vlanTag(soap, tag?tag:"ns1:vlanTag", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__vlanTag ** SOAP_FMAC4 soap_get_PointerTons1__vlanTag(struct soap *soap, struct ns1__vlanTag **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__vlanTag(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns1__listRequest_sequence(struct soap *soap, struct __ns1__listRequest_sequence *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE___ns1__listRequest_sequence))
    soap_serialize___ns1__listRequest_sequence(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns1__listRequest_sequence(struct soap *soap, const char *tag, int id, struct __ns1__listRequest_sequence *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns1__listRequest_sequence);
  if (id < 0)
    return soap->error;
  return soap_out___ns1__listRequest_sequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns1__listRequest_sequence ** SOAP_FMAC4 soap_in_PointerTo__ns1__listRequest_sequence(struct soap *soap, const char *tag, struct __ns1__listRequest_sequence **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct __ns1__listRequest_sequence **)soap_malloc(soap, sizeof(struct __ns1__listRequest_sequence *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in___ns1__listRequest_sequence(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct __ns1__listRequest_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns1__listRequest_sequence, sizeof(struct __ns1__listRequest_sequence), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns1__listRequest_sequence(struct soap *soap, struct __ns1__listRequest_sequence *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns1__listRequest_sequence);
  if (soap_out_PointerTo__ns1__listRequest_sequence(soap, tag?tag:"-ns1:listRequest-sequence", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns1__listRequest_sequence ** SOAP_FMAC4 soap_get_PointerTo__ns1__listRequest_sequence(struct soap *soap, struct __ns1__listRequest_sequence **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo__ns1__listRequest_sequence(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_string))
    soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
  if (id < 0)
    return soap->error;
  return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_string(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
  if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTostring(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CtrlPlaneTopologyContent(struct soap *soap, struct ns5__CtrlPlaneTopologyContent *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CtrlPlaneTopologyContent))
    soap_serialize_ns5__CtrlPlaneTopologyContent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CtrlPlaneTopologyContent(struct soap *soap, const char *tag, int id, struct ns5__CtrlPlaneTopologyContent *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CtrlPlaneTopologyContent);
  if (id < 0)
    return soap->error;
  return soap_out_ns5__CtrlPlaneTopologyContent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__CtrlPlaneTopologyContent ** SOAP_FMAC4 soap_in_PointerTons5__CtrlPlaneTopologyContent(struct soap *soap, const char *tag, struct ns5__CtrlPlaneTopologyContent **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns5__CtrlPlaneTopologyContent **)soap_malloc(soap, sizeof(struct ns5__CtrlPlaneTopologyContent *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns5__CtrlPlaneTopologyContent(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns5__CtrlPlaneTopologyContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CtrlPlaneTopologyContent, sizeof(struct ns5__CtrlPlaneTopologyContent), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CtrlPlaneTopologyContent(struct soap *soap, struct ns5__CtrlPlaneTopologyContent *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CtrlPlaneTopologyContent);
  if (soap_out_PointerTons5__CtrlPlaneTopologyContent(soap, tag?tag:"ns5:CtrlPlaneTopologyContent", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__CtrlPlaneTopologyContent ** SOAP_FMAC4 soap_get_PointerTons5__CtrlPlaneTopologyContent(struct soap *soap, struct ns5__CtrlPlaneTopologyContent **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons5__CtrlPlaneTopologyContent(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__resDetails(struct soap *soap, struct ns1__resDetails *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__resDetails))
    soap_serialize_ns1__resDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__resDetails(struct soap *soap, const char *tag, int id, struct ns1__resDetails *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__resDetails);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__resDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__resDetails ** SOAP_FMAC4 soap_in_PointerTons1__resDetails(struct soap *soap, const char *tag, struct ns1__resDetails **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__resDetails **)soap_malloc(soap, sizeof(struct ns1__resDetails *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__resDetails(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__resDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__resDetails, sizeof(struct ns1__resDetails), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__resDetails(struct soap *soap, struct ns1__resDetails *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__resDetails);
  if (soap_out_PointerTons1__resDetails(soap, tag?tag:"ns1:resDetails", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__resDetails ** SOAP_FMAC4 soap_get_PointerTons1__resDetails(struct soap *soap, struct ns1__resDetails **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__resDetails(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__optionalConstraintType(struct soap *soap, struct ns1__optionalConstraintType **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__optionalConstraintType))
    soap_serialize_PointerTons1__optionalConstraintType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__optionalConstraintType(struct soap *soap, const char *tag, int id, struct ns1__optionalConstraintType **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__optionalConstraintType);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTons1__optionalConstraintType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__optionalConstraintType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__optionalConstraintType(struct soap *soap, const char *tag, struct ns1__optionalConstraintType ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__optionalConstraintType ***)soap_malloc(soap, sizeof(struct ns1__optionalConstraintType **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTons1__optionalConstraintType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__optionalConstraintType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__optionalConstraintType, sizeof(struct ns1__optionalConstraintType *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__optionalConstraintType(struct soap *soap, struct ns1__optionalConstraintType **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__optionalConstraintType);
  if (soap_out_PointerToPointerTons1__optionalConstraintType(soap, tag?tag:"ns1:optionalConstraintType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__optionalConstraintType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__optionalConstraintType(struct soap *soap, struct ns1__optionalConstraintType ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTons1__optionalConstraintType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__optionalConstraintType(struct soap *soap, struct ns1__optionalConstraintType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__optionalConstraintType))
    soap_serialize_ns1__optionalConstraintType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__optionalConstraintType(struct soap *soap, const char *tag, int id, struct ns1__optionalConstraintType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__optionalConstraintType);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__optionalConstraintType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__optionalConstraintType ** SOAP_FMAC4 soap_in_PointerTons1__optionalConstraintType(struct soap *soap, const char *tag, struct ns1__optionalConstraintType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__optionalConstraintType **)soap_malloc(soap, sizeof(struct ns1__optionalConstraintType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__optionalConstraintType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__optionalConstraintType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__optionalConstraintType, sizeof(struct ns1__optionalConstraintType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__optionalConstraintType(struct soap *soap, struct ns1__optionalConstraintType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__optionalConstraintType);
  if (soap_out_PointerTons1__optionalConstraintType(soap, tag?tag:"ns1:optionalConstraintType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__optionalConstraintType ** SOAP_FMAC4 soap_get_PointerTons1__optionalConstraintType(struct soap *soap, struct ns1__optionalConstraintType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__optionalConstraintType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__reservedConstraintType(struct soap *soap, struct ns1__reservedConstraintType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__reservedConstraintType))
    soap_serialize_ns1__reservedConstraintType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__reservedConstraintType(struct soap *soap, const char *tag, int id, struct ns1__reservedConstraintType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__reservedConstraintType);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__reservedConstraintType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__reservedConstraintType ** SOAP_FMAC4 soap_in_PointerTons1__reservedConstraintType(struct soap *soap, const char *tag, struct ns1__reservedConstraintType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__reservedConstraintType **)soap_malloc(soap, sizeof(struct ns1__reservedConstraintType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__reservedConstraintType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__reservedConstraintType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__reservedConstraintType, sizeof(struct ns1__reservedConstraintType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__reservedConstraintType(struct soap *soap, struct ns1__reservedConstraintType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__reservedConstraintType);
  if (soap_out_PointerTons1__reservedConstraintType(soap, tag?tag:"ns1:reservedConstraintType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__reservedConstraintType ** SOAP_FMAC4 soap_get_PointerTons1__reservedConstraintType(struct soap *soap, struct ns1__reservedConstraintType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__reservedConstraintType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__userRequestConstraintType(struct soap *soap, struct ns1__userRequestConstraintType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns1__userRequestConstraintType))
    soap_serialize_ns1__userRequestConstraintType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__userRequestConstraintType(struct soap *soap, const char *tag, int id, struct ns1__userRequestConstraintType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__userRequestConstraintType);
  if (id < 0)
    return soap->error;
  return soap_out_ns1__userRequestConstraintType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__userRequestConstraintType ** SOAP_FMAC4 soap_in_PointerTons1__userRequestConstraintType(struct soap *soap, const char *tag, struct ns1__userRequestConstraintType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns1__userRequestConstraintType **)soap_malloc(soap, sizeof(struct ns1__userRequestConstraintType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns1__userRequestConstraintType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns1__userRequestConstraintType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__userRequestConstraintType, sizeof(struct ns1__userRequestConstraintType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__userRequestConstraintType(struct soap *soap, struct ns1__userRequestConstraintType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__userRequestConstraintType);
  if (soap_out_PointerTons1__userRequestConstraintType(soap, tag?tag:"ns1:userRequestConstraintType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__userRequestConstraintType ** SOAP_FMAC4 soap_get_PointerTons1__userRequestConstraintType(struct soap *soap, struct ns1__userRequestConstraintType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons1__userRequestConstraintType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__messagePropertiesType(struct soap *soap, struct ns6__messagePropertiesType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ns6__messagePropertiesType))
    soap_serialize_ns6__messagePropertiesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__messagePropertiesType(struct soap *soap, const char *tag, int id, struct ns6__messagePropertiesType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__messagePropertiesType);
  if (id < 0)
    return soap->error;
  return soap_out_ns6__messagePropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__messagePropertiesType ** SOAP_FMAC4 soap_in_PointerTons6__messagePropertiesType(struct soap *soap, const char *tag, struct ns6__messagePropertiesType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ns6__messagePropertiesType **)soap_malloc(soap, sizeof(struct ns6__messagePropertiesType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ns6__messagePropertiesType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ns6__messagePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__messagePropertiesType, sizeof(struct ns6__messagePropertiesType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__messagePropertiesType(struct soap *soap, struct ns6__messagePropertiesType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__messagePropertiesType);
  if (soap_out_PointerTons6__messagePropertiesType(soap, tag?tag:"ns6:messagePropertiesType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__messagePropertiesType ** SOAP_FMAC4 soap_get_PointerTons6__messagePropertiesType(struct soap *soap, struct ns6__messagePropertiesType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTons6__messagePropertiesType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, char *const*a, const char *type) {
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_in_ns3__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, char **a, const char *type) {
  char **p;
  p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType, 1, -1, -1);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType);
  if (soap_out_ns3__AbsoluteOrRelativeTimeType(soap, tag?tag:"byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__AbsoluteOrRelativeTimeType(struct soap *soap, char **p, const char *tag, const char *type) {
  if ((p = soap_in_ns3__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
    soap_serialize__wsse__Security(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security);
  if (id < 0)
    return soap->error;
  return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Security);
  if (soap_out_PointerTo_wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
    soap_serialize_ds__SignatureType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureType);
  if (soap_out_PointerTods__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptedKeyType))
    soap_serialize_xenc__EncryptedKeyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptedKeyType);
  if (id < 0)
    return soap->error;
  return soap_out_xenc__EncryptedKeyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct xenc__EncryptedKeyType **)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_xenc__EncryptedKeyType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct xenc__EncryptedKeyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptedKeyType);
  if (soap_out_PointerToxenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToxenc__EncryptedKeyType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
    soap_serialize__wsse__BinarySecurityToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken);
  if (id < 0)
    return soap->error;
  return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__BinarySecurityToken);
  if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
    soap_serialize__wsse__UsernameToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken);
  if (id < 0)
    return soap->error;
  return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__UsernameToken);
  if (soap_out_PointerTo_wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
    soap_serialize__wsu__Timestamp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp);
  if (id < 0)
    return soap->error;
  return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsu__Timestamp);
  if (soap_out_PointerTo_wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
    soap_serialize__wsse__Embedded(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded);
  if (id < 0)
    return soap->error;
  return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Embedded);
  if (soap_out_PointerTo_wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
    soap_serialize__wsse__KeyIdentifier(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier);
  if (id < 0)
    return soap->error;
  return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__KeyIdentifier);
  if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
    soap_serialize__wsse__Reference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference);
  if (id < 0)
    return soap->error;
  return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Reference);
  if (soap_out_PointerTo_wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
    soap_serialize__wsse__Password(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password);
  if (id < 0)
    return soap->error;
  return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Password);
  if (soap_out_PointerTo_wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
    soap_serialize__wsa5__FaultTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo);
  if (id < 0)
    return soap->error;
  return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__FaultTo);
  if (soap_out_PointerTo_wsa5__FaultTo(soap, tag?tag:"wsa5:FaultTo", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
    soap_serialize__wsa5__ReplyTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo);
  if (id < 0)
    return soap->error;
  return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__ReplyTo);
  if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag?tag:"wsa5:ReplyTo", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
    soap_serialize__wsa5__From(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From);
  if (id < 0)
    return soap->error;
  return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__From);
  if (soap_out_PointerTo_wsa5__From(soap, tag?tag:"wsa5:From", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
    soap_serialize__wsa5__RelatesTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo);
  if (id < 0)
    return soap->error;
  return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__RelatesTo);
  if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag?tag:"wsa5:RelatesTo", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__ProblemHeaderQName(struct soap *soap, const char *tag, int id, char *const*a, const char *type) {
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__wsa5__ProblemHeaderQName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_in__wsa5__ProblemHeaderQName(struct soap *soap, const char *tag, char **a, const char *type) {
  char **p;
  p = soap_instring(soap, tag, a, type, SOAP_TYPE__wsa5__ProblemHeaderQName, 2, -1, -1);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemHeaderQName(struct soap *soap, char *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa5__ProblemHeaderQName);
  if (soap_out__wsa5__ProblemHeaderQName(soap, tag?tag:"byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__wsa5__ProblemHeaderQName(struct soap *soap, char **p, const char *tag, const char *type) {
  if ((p = soap_in__wsa5__ProblemHeaderQName(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
    soap_serialize_wsa5__MetadataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType);
  if (id < 0)
    return soap->error;
  return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__MetadataType);
  if (soap_out_PointerTowsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
    soap_serialize_wsa5__ReferenceParametersType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType);
  if (id < 0)
    return soap->error;
  return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__ReferenceParametersType);
  if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type) {
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type) {
  char **p;
  p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, -1, -1);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
  if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag?tag:"byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type) {
  if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type) {
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type) {
  char **p;
  p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, -1, -1);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
  if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag?tag:"byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type) {
  if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__xenc__ReferenceList))
    soap_serialize__xenc__ReferenceList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, int id, struct _xenc__ReferenceList *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xenc__ReferenceList);
  if (id < 0)
    return soap->error;
  return soap_out__xenc__ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_in_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _xenc__ReferenceList **)soap_malloc(soap, sizeof(struct _xenc__ReferenceList *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__xenc__ReferenceList(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _xenc__ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xenc__ReferenceList);
  if (soap_out_PointerTo_xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_get_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_xenc__ReferenceList(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE___xenc__union_ReferenceList))
    soap_serialize___xenc__union_ReferenceList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, struct __xenc__union_ReferenceList *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___xenc__union_ReferenceList);
  if (id < 0)
    return soap->error;
  return soap_out___xenc__union_ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_in_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct __xenc__union_ReferenceList **)soap_malloc(soap, sizeof(struct __xenc__union_ReferenceList *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in___xenc__union_ReferenceList(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct __xenc__union_ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__xenc__union_ReferenceList);
  if (soap_out_PointerTo__xenc__union_ReferenceList(soap, tag?tag:"-xenc:union-ReferenceList", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_get_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo__xenc__union_ReferenceList(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_xenc__ReferenceType))
    soap_serialize_xenc__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, int id, struct xenc__ReferenceType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__ReferenceType);
  if (id < 0)
    return soap->error;
  return soap_out_xenc__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct xenc__ReferenceType **)soap_malloc(soap, sizeof(struct xenc__ReferenceType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_xenc__ReferenceType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct xenc__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__ReferenceType);
  if (soap_out_PointerToxenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToxenc__ReferenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertyType))
    soap_serialize_xenc__EncryptionPropertyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertyType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertyType);
  if (id < 0)
    return soap->error;
  return soap_out_xenc__EncryptionPropertyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct xenc__EncryptionPropertyType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertyType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_xenc__EncryptionPropertyType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct xenc__EncryptionPropertyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionPropertyType);
  if (soap_out_PointerToxenc__EncryptionPropertyType(soap, tag?tag:"xenc:EncryptionPropertyType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToxenc__EncryptionPropertyType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_xenc__TransformsType))
    soap_serialize_xenc__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__TransformsType(struct soap *soap, const char *tag, int id, struct xenc__TransformsType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__TransformsType);
  if (id < 0)
    return soap->error;
  return soap_out_xenc__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_in_PointerToxenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct xenc__TransformsType **)soap_malloc(soap, sizeof(struct xenc__TransformsType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_xenc__TransformsType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct xenc__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__TransformsType);
  if (soap_out_PointerToxenc__TransformsType(soap, tag?tag:"xenc:TransformsType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_get_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToxenc__TransformsType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherReferenceType))
    soap_serialize_xenc__CipherReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, int id, struct xenc__CipherReferenceType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherReferenceType);
  if (id < 0)
    return soap->error;
  return soap_out_xenc__CipherReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct xenc__CipherReferenceType **)soap_malloc(soap, sizeof(struct xenc__CipherReferenceType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_xenc__CipherReferenceType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct xenc__CipherReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__CipherReferenceType);
  if (soap_out_PointerToxenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToxenc__CipherReferenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertiesType))
    soap_serialize_xenc__EncryptionPropertiesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertiesType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertiesType);
  if (id < 0)
    return soap->error;
  return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct xenc__EncryptionPropertiesType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertiesType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_xenc__EncryptionPropertiesType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct xenc__EncryptionPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionPropertiesType);
  if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToxenc__EncryptionPropertiesType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherDataType))
    soap_serialize_xenc__CipherDataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, int id, struct xenc__CipherDataType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherDataType);
  if (id < 0)
    return soap->error;
  return soap_out_xenc__CipherDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct xenc__CipherDataType **)soap_malloc(soap, sizeof(struct xenc__CipherDataType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_xenc__CipherDataType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct xenc__CipherDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__CipherDataType);
  if (soap_out_PointerToxenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToxenc__CipherDataType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__ds__KeyInfo))
    soap_serialize__ds__KeyInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__KeyInfo);
  if (id < 0)
    return soap->error;
  return soap_out__ds__KeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__ds__KeyInfo(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ds__KeyInfo);
  if (soap_out_PointerTo_ds__KeyInfo(soap, tag?tag:"ds:KeyInfo", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_ds__KeyInfo(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionMethodType))
    soap_serialize_xenc__EncryptionMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionMethodType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionMethodType);
  if (id < 0)
    return soap->error;
  return soap_out_xenc__EncryptionMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct xenc__EncryptionMethodType **)soap_malloc(soap, sizeof(struct xenc__EncryptionMethodType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_xenc__EncryptionMethodType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct xenc__EncryptionMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionMethodType);
  if (soap_out_PointerToxenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToxenc__EncryptionMethodType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
    soap_serialize_ds__X509IssuerSerialType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509IssuerSerialType);
  if (soap_out_PointerTods__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
    soap_serialize_ds__RSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RSAKeyValueType);
  if (soap_out_PointerTods__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
    soap_serialize_ds__DSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DSAKeyValueType);
  if (soap_out_PointerTods__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
    soap_serialize_ds__TransformType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformType);
  if (soap_out_PointerTods__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
    soap_serialize_ds__DigestMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DigestMethodType);
  if (soap_out_PointerTods__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
    soap_serialize_ds__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformsType);
  if (soap_out_PointerTods__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a) {
  soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
  if (id < 0)
    return soap->error;
  return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_int(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
  if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToint(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
    soap_serialize_PointerTods__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType);
  if (id < 0)
    return soap->error;
  return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTods__ReferenceType, sizeof(struct ds__ReferenceType *), 1);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTods__ReferenceType);
  if (soap_out_PointerToPointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type) {
  if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
    soap_serialize_ds__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__ReferenceType);
  if (soap_out_PointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
    soap_serialize_ds__SignatureMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureMethodType);
  if (soap_out_PointerTods__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
    soap_serialize_ds__CanonicalizationMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__CanonicalizationMethodType);
  if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
    soap_serialize__wsse__SecurityTokenReference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference);
  if (id < 0)
    return soap->error;
  return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__SecurityTokenReference);
  if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
    soap_serialize_ds__X509DataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509DataType);
  if (soap_out_PointerTods__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
    soap_serialize_ds__RetrievalMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RetrievalMethodType);
  if (soap_out_PointerTods__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
    soap_serialize_ds__KeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyValueType);
  if (soap_out_PointerTods__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
    soap_serialize__c14n__InclusiveNamespaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces);
  if (id < 0)
    return soap->error;
  return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces);
  if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
    soap_serialize_ds__KeyInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyInfoType);
  if (soap_out_PointerTods__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a) {
  if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
    soap_serialize_ds__SignedInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type) {
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType);
  if (id < 0)
    return soap->error;
  return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type) {
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#') {
    soap_revert(soap);
    if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
      return NULL;
  }
  else {
    a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignedInfoType);
  if (soap_out_PointerTods__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type) {
  if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type) {
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type) {
  char **p;
  p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
  if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type) {
  if ((p = soap_in__QName(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a) {
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
  *a = SOAP_DEFAULT_string;
#else
  *a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a) {
  soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type) {
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type) {
  char **p;
  p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
  return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type) {
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
  if (soap_out_string(soap, tag?tag:"byte", id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type) {
  if ((p = soap_in_string(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of oscars6C.c */
